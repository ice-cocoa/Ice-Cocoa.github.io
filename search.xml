<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/05/29/%E9%98%85%E8%AF%BB/%E6%AD%8C%E8%AF%8D--%E5%A4%95%E9%A2%9C%EF%BC%88%E6%9C%88%E5%85%89%E8%8A%B1%EF%BC%89/</url>
    <content><![CDATA[<p>作词 : 竹中三佳<br>作曲 : 竹中三佳</p>
<p>能登麻美子</p>
<p>庭に咲き始めた夕顔に<br>要是在庭院里初开的夕颜上<br>水を打ってあげたら<br>洒上晶莹的水珠<br>遊びに出かけていた猫が<br>在外玩耍的伊织<br>帰ってきたわ「おかえり」<br>就会踏进玄关“欢迎回来”<br>ほら見てごらん 雲のさざなみ<br>看吧天空中云彩的涟漪<br>杏色やむらさき<br>呈现着杏黄色和绛紫色<br>沈む夕陽に染まってキレイ<br>西沉的夕阳给天空带来了一抹绮丽<br>まるで夢か幻<br>这一切宛如梦幻一般<br>風は どこから<br>风从哪里来呢<br>吹いてくるのでしょう<br>从何处吹来呢<br>遠い 海を渡り<br>或许穿越了远方的大海<br>長い旅をするの<br>经历了长途跋涉<br>ふと気がつけば 時計の針は<br>突然想到<br>あの人が戻る時間<br>那个人回来的时候<br>お腹の虫も鳴いてるはずよ<br>也一定饿了吧<br>今日は何を作ろう<br>今天的晚饭做什么好呢？<br>そら耳かしら 誰かの声が<br>侧耳倾听是那个人的声音<br>留守録にメッセージ<br>电话中的留言<br>今にあの人あわてて言うわ<br>他匆忙地只说了一句<br>「夕飯はいらない」と<br>“不回来吃晚饭了”<br>風はどこまで<br>风无论到哪里<br>吹いてゆくのでしょう<br>将吹向何处<br>いつか こんな日々も<br>何时又能在这样的日子里<br>なつかしくなるの<br>带来令人眷恋的愁绪<br>ぼっかり空いた時間を一人<br>悠闲空余的时间里<br>持て余すベランダに<br>凉台无法承受我的寂寞<br>一番星がまたたき出した<br>天空中第一颗星星露出了光芒<br>きっと晴れる 明日も<br>明日一定是个晴天吧<br>風はゆく どこへ<br>风吹向何处<br>誰も知らない<br>无人知晓</p>
<p>庭に咲き始めた夕顔に<br><strong>ni wa</strong> ni sa ki ha ji me ta <strong>yu u ga o</strong> ni<br>水を打ってあげたら<br>mi zu wo u tte a ge ta ra<br>遊びに出かけていた猫が<br>a so bi ni de ka ke te i ta ne ko ga<br>帰ってきたわ「おかえり」<br>ka e tte ki ta wa「o ka e ri」<br>ほら見てごらん 雲のさざなみ<br>ho ra mi te go ra n ku mo no sa za na mi<br>杏色やむらさき<br>a n zu i ro ya mu ra sa ki<br>沈む夕陽に染まってキレイ<br><strong>shi zu mu</strong> yu u hi ni <strong>so</strong> ma tte ki re i<br>まるで夢か幻<br>ma ru de yu me ka ma bo ro shi<br>風は どこから<br>ka ze wa do ko ka ra<br>吹いてくるのでしょう<br>fu i te ku ru no de sho u<br>遠い 海を渡り<br>to o i u mi wo wa ta ri<br>長い旅をするの<br>na ga i ta bi wo su ru no<br>ふと気がつけば 時計の針は<br>fu to ki ga tsu ke ba to ke i no <strong>ha ri</strong> wa<br>あの人が戻る時間<br>a no hi to ga <strong>mo do ru</strong> ji ko ku<br>お腹の虫も鳴いてるはずよ<br><strong>o na ka</strong> no mu shi mo na i te ru ha zu yo<br>今日は何を作ろう<br>kyo u wa na ni wo tsu ku ro u<br>そら耳かしら 誰かの声が<br>so ra mi mi ka shi ra da re ka no ko e ga<br>留守録にメッセージ<br><strong>ru su ro ku</strong> ni me ssee ji<br>今にあの人あわてて言うわ<br>i ma ni a no hi to a wa te te i u wa<br>「夕飯はいらない」と<br>「<strong>yu u ha n</strong> wa i ra na i」to<br>風はどこまで<br>ka ze wa do ko ma de<br>吹いてゆくのでしょう<br>fu i te yu ku no de sho u<br>いつか こんな日々も<br>i tsu ka ko n na hi bi mo<br>なつかしくなるの<br>na tsu ka shi ku na ru no<br>ぼっかり空いた時間を一人<br>bo kka ri <strong>a i ta</strong> ji ka n wo hi to ri<br>持て余すベランダに<br>mo te <strong>a ma</strong> su be ra n da ni<br>一番星がまたたき出した<br>i chi ba n ho shi ga ma ta ta ki da shi ta<br>きっと晴れる 明日も<br>ki tto ha re ru a shi ta mo<br>風はゆく どこへ<br>ka ze wa yu ku do ko e<br>誰も知らない<br>da re mo shi ra na i</p>
<p>庭に咲き始めた夕顔（yuu ga o）に<br>水を打ってあげたら<br>遊びに出かけていた猫が<br>帰ってきたわ「おかえり」<br>ほら見てごらん 雲のさざなみ<br>杏色やむらさき<br>沈む（shizu mu）夕陽に染（so）まってキレイ<br>まるで夢か幻<br>風は どこから<br>吹いてくるのでしょう<br>遠い 海を渡り<br>長い旅をするの<br>ふと気がつけば 時計の針（hari）は<br>あの人が戻る時間<br>お腹の虫も鳴いてるはずよ<br>今日は何を作ろう<br>そら耳かしら 誰かの声（koe）が<br>留守録にメッセージ<br>今にあの人あわてて言うわ<br>「夕飯（yuuhan）はいらない」と<br>風はどこまで<br>吹いてゆくのでしょう<br>いつか こんな日々も<br>なつかしくなるの<br>ぼっかり空いた（aita）時間を一人<br>持て余（ame）すベランダに<br>一番星がまたたき出した<br>きっと晴れる 明日も<br>風はゆく どこへ<br>誰も知らない</p>
]]></content>
  </entry>
  <entry>
    <title>协程与异步流</title>
    <url>/2023/05/16/%E5%AD%A6%E4%B9%A0/python/python%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5/%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%B5%81/</url>
    <content><![CDATA[<p>可等待对象，主要是协程和任务的基础知识。以及异步通信流的基础</p>
<span id="more"></span>

<h1 id="可等待对象简述"><a href="#可等待对象简述" class="headerlink" title="可等待对象简述"></a>可等待对象简述</h1><p>可等待对象主要有三类：Coroutine(协程)、Task(任务)、Future。可等待对象是可以在 await 中执行的对象。要构造一个协程，使用关键字 async def 即可定义协程；要构造一个任务，则必须显示使用 asyncio.create_task(<em>some_coroutine</em>) 来把一个协程封装为任务。</p>
<p>任务对象和协程的关系，参考：”Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 完成，被打包的协程将恢复执行。”</p>
<p>关键字 async&#x2F;await 构成的语法，让异步可行。关键字async声明一个函数为协程，而仅有可等待对象可以被 await。其中 await 的作用是，等待 await <em>awaitaeble</em> 中的 <em>awaitable</em> 执行结束（判断方式应该是一个特殊类型的返回值，这里姑且理解为等待执行结束）</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h2 id="运行一个协程"><a href="#运行一个协程" class="headerlink" title="运行一个协程"></a>运行一个协程</h2><p>创建一个协程的方法是，使用 async 关键字声明。要真正运行一个协程，有两种方式，第一种是 asyncio.run(<em>coroutine</em>) ，它会直接尝试运行这个协程；第二章是 asyncio.create_task(<em>coroutine</em>) ，它会把协程加入到循环事件集中，在循环事件集的控制下执行协程（此时这个协程对外已经被包装成Task）</p>
<p>如果一个协程没有加入循环事件集，那么尽管它可以使用 await asyncio.sleep(<em>delay_time</em>)，实际效果和阻塞主线程类似，此时和 time.sleep(<em>delay_time</em>) 用上去并无区别。循环事件集是一个偏低层的概念，后续在研究</p>
<p>run方式下，使用 await asyncio.sleep() 效果等同于 time.sleep()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期输出</span></span><br><span class="line"><span class="comment"># started at 17:13:52</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># finished at 17:13:55</span></span><br></pre></td></tr></table></figure>

<p>create_task 方式下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期输出</span></span><br><span class="line"><span class="comment"># started at 17:14:32</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># finished at 17:14:34</span></span><br></pre></td></tr></table></figure>

<h2 id="创建任务的解释"><a href="#创建任务的解释" class="headerlink" title="创建任务的解释"></a>创建任务的解释</h2><p>上一节已记录了使用create_task把一个协程封装为Task，然后就可以异步执行了。这里再详细分析一下</p>
<p>asyncio.create_task(<em>core,*,name&#x3D;None</em>) 将core协程封装为一个Task对象，该协程可以被调度执行，返回该Task对象。name不为None时，将使用Task.set_name()来设为任务的名称。该Task会在 get_running_loop() 返回的事件循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError</p>
<p><strong>重要</strong>：建议保存指向这个Task对象的引用，以避免任务在执行过程中消失。事件循环将只保留对任务的弱引用。未在其他地方被引用的任务可能在任何时候被作为垃圾回收。如果需要后台任务执行后不会被垃圾回收，需要收集到一个“后台任务”集中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">background_tasks = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    task = asyncio.create_task(some_coro(param=i))</span><br><span class="line">    <span class="comment"># 把任务加入到这个集合中，以保留强引用</span></span><br><span class="line">    background_tasks.add(task)</span><br><span class="line">    <span class="comment"># 同时为了避免任务结束后，对象一直存在着，还需要添加回调函数，以在任务结束后移除自身引用</span></span><br><span class="line">    task.add_done_callback(background_tasks.discard)</span><br></pre></td></tr></table></figure>

<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p>coroutine asyncio.sleep(<em>delay, result&#x3D;None</em>) 阻塞delay指定的秒数。如果指定了result，则当协程完成时将result返回给调用者。sleep() 总是会挂起当前任务，以允许其他任务运行，因此一个delay为0的休眠可以提供一个经过优化的路径以允许其他任务运行，这可避免一直停留在在一个长期运行的函数，使事件循环更加“流畅”</p>
<p>这个函数会隐式地获取当前正在运行的事件循环，即无需手动传入loop参数</p>
<h1 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h1><h2 id="有序并发"><a href="#有序并发" class="headerlink" title="有序并发"></a>有序并发</h2><p>awaitable asyncio.gather(*aws, return_exceptions&#x3D;False)<br>有序“并发”运行aws序列中的可等待对象(通常用于协程)。如果aws中的某个可等待对象为协程，它将自动被作为一个任务调度，那么gather的功能此时相当于，把传入的所有协程都加入到循环事件集中，可被调度</p>
<p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序传入顺序一致。</p>
<p>如果return_exceptions为False(默认)，所引发的首个异常会立即传播给等待gather的任务，其他可等待对象不会被取消。如果return_exceptions为False，异常会和成功的结果一样处理，并聚合到结果列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">name, number</span>):</span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;number&#125;</span>), currently i=<span class="subst">&#123;i&#125;</span>...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    L = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2), currently i=2...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3), currently i=2...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4), currently i=2...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3), currently i=3...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4), currently i=3...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4), currently i=4...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br><span class="line"><span class="comment">#     [2, 6, 24]</span></span><br></pre></td></tr></table></figure>

<h2 id="屏蔽取消-暂时不需要"><a href="#屏蔽取消-暂时不需要" class="headerlink" title="屏蔽取消(暂时不需要)"></a>屏蔽取消(暂时不需要)</h2><h2 id="限时等待"><a href="#限时等待" class="headerlink" title="限时等待"></a>限时等待</h2><p>coroutine asyncio.wait_for(<em>aw, timeout</em>) 如果aw是一个协程，那么将会被作为任务调度。timeout也可以为None，此时无限等待。如果要避免任务取消，需要为aw包围一个shield函数。如果任务超时，任务将<strong>取消</strong>,并引发 asyncio.TimeoutError</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">eternity</span>():</span><br><span class="line">    <span class="comment"># 睡眠一小时</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yay!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 等待1秒</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;timeout!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预取:</span></span><br><span class="line"><span class="comment"># timeout!</span></span><br></pre></td></tr></table></figure>

<h2 id="等待一个任务集"><a href="#等待一个任务集" class="headerlink" title="等待一个任务集"></a>等待一个任务集</h2><p>coroutine asyncio.wait(<em>aws, *, timeout&#x3D;None, return_when&#x3D;ALL_COMPLETED</em>) aws为内容为可等待对象的可迭代对象，等待return_when的条件为真时，返回两个Task（也可能是Future）集合，分别为完成的任务集合、未完成的任务集合。此时未完成的任务不会再被调度执行。用法为： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">done, pending = <span class="keyword">await</span> asyncio.wait(aws)</span><br></pre></td></tr></table></figure>

<p>函数不会引发超时错误，如果发生超时，则未完成Task（或Future）会在随后返回。</p>
<p>小误区：如果要判断某个协程是否位于done、或者pending，不能直接用 <span>if core in done</span>，因为core为协程类型，done通常为任务类型。所以如果要进行这样的判断，需要实现把协程封装为任务，把这个任务加入aws这个需要等待的任务集中</p>
<p>return_when有这些取值：FIRST_COMPLETED、FIRSR_EXCEPTION、ALL_COMPLETED</p>
<h1 id="在线程中运行"><a href="#在线程中运行" class="headerlink" title="在线程中运行"></a>在线程中运行</h1><p>coroutine asyncio.to_thread(*func, /, <em>args, **kwargs</em>) 能够让这个函数在不同线程中运行，当前 contextvars.Context 会被传播，允许在不同的线程中访问来自事件循环的上下文变量。这个函数返回一个协程，与一般协程的不同之处在于，它会运行在另一个线程中，不会阻塞当前事件循环，仅会阻塞主线程中的await</p>
<p>通常当func为io密集函数时，才使用这种方法，这样就不会阻塞事件循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">blocking_io</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start blocking_io at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;blocking_io complete at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started main at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        asyncio.to_thread(blocking_io), <span class="comment">#不会阻塞事件循环，但是会阻塞这个await</span></span><br><span class="line">        asyncio.sleep(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished main at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># started main at 19:50:53</span></span><br><span class="line"><span class="comment"># start blocking_io at 19:50:53</span></span><br><span class="line"><span class="comment"># blocking_io complete at 19:50:54</span></span><br><span class="line"><span class="comment"># finished main at 19:50:54</span></span><br></pre></td></tr></table></figure>


<h1 id="跨线程调度（更加复杂的协程功能，一般无需）"><a href="#跨线程调度（更加复杂的协程功能，一般无需）" class="headerlink" title="跨线程调度（更加复杂的协程功能，一般无需）"></a>跨线程调度（更加复杂的协程功能，一般无需）</h1><p>给出的跨线程调度函数的具体作用是，向指定的事件循环，线程安全地提交一个协程</p>
<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><h2 id="内省获得Task"><a href="#内省获得Task" class="headerlink" title="内省获得Task"></a>内省获得Task</h2><p>asyncio.current_task(<em>loop&#x3D;None</em>) 返回当前运行的Task实例，如果没有则返回None。如果loop传入None，则使用 get_running_loop() 获取当前事件循环</p>
<p>asyncio.all_tasks(<em>loop&#x3D;None</em>) 返回事件循环中未完成的Task实例。如果loop为None，则会使用当前的事件循环</p>
<h2 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a>Task对象</h2><p>class asyncio.Task(<em>core, *, loop&#x3D;None, name&#x3D;None</em>) 一个与Future类似的对象，可封装协程，非线程安全。Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个Future对象，Task对象会挂起该协程的执行并等待该Future对象完成。当该Future对象完成，被打包的协程将恢复执行</p>
<p>创建一个Task对象，通常使用 asyncio.create_task(<em>core</em>)， 或者低层级的loop.create_task(<em>core</em>)，使用这两种推荐的方法会把协程封装为Task，并加入到事件循环中。不建议直接创建Task对象。</p>
<p>要取消一个正在运行的Task可以使用 Task.cancel()取消，成功取消将使该Task对象抛出一个 CancelledError 异常给打包的协程。如果取消期间一个协程正在等待一个Future对象，该Future对象也将被取消。使用 asyncio.shield(aw) 可以保护Task对应的协程不会被取消。使用 Task.cancelled()来检测Task是否成功被取消，如果打包的协程没有抑制CancelledError异常，且确实被取消，那么返回True</p>
<p>Task 对象支持 contextvars 模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。这意味着另起线程并在其中运行Task，并接受主线程中事件循环的管理是可行的。</p>
<p>事件循环使用协同日程调度：每次循环仅会运行一个Task。这个更加深入的理解需要参考事件循环和Future，这里无需过多研究。</p>
<h2 id="Task的取消机制"><a href="#Task的取消机制" class="headerlink" title="Task的取消机制"></a>Task的取消机制</h2><p>方法 cancel(<em>msg&#x3D;None</em>) 请求取消Task对象这会在下一轮事件循环中抛出 CancelledError异常给被封包的协程。协程在之后有机会进行清理，也可以使用 try … … except CancelledError … finally 代码块抑制异常来拒绝请求。因此不同于Future.cancel()，Task.cancel()不保证 Task 会被取消，但仍然不鼓励这么做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cancel_me</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): before sleep&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): cancel sleep&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span>       <span class="comment"># 重要：如果这里不raise，异常就会被抑制，该协程的剩余代码还会继续执行</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): after sleep&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;main(): cancel_me is cancelled now&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Task方法"><a href="#Task方法" class="headerlink" title="Task方法"></a>Task方法</h2><p>上面几节提及到了 cancel(), cancelled() 这两个方法。以下是其余方法</p>
<p>done() 如果Task已完成则返回True。协程返回一个值、引发一个异常，或者Task本身被取消，都被视为“已完成”</p>
<p>result() 返回Task的结果。Task已完成则返回协程的值（如果是协程的异常，则会重新引发；如果Task取消，也会重新引发CancelledError），Task结果还不可得，则引发 InvalidStateError</p>
<p>add_done_callback(*callback, <em>, context&#x3D;None</em>) 添加一个回调，将在Task对象完成时被运行。一个典型的用法是 <span>task.add_done_callback(background_tasks.discard)</span>，其中 background_tasks 是一个自定义的，存储Task引用的集合。事先存储Task引用，避免引用回收导致的任务取消，以及Task完成后移除引用，以保证占用资源顺利回收。</p>
<p>remove_done_callback(*callback, <em>, context&#x3D;None</em>) 移除一个回调函数。</p>
<p>get_core()返回包装的协程对象</p>
<p>print_stack(<em>*, limit&#x3D;None, file&#x3D;None</em>) 打印此 Task 对象的栈或回溯，它会在内部调用get_stack方法以获取栈框架。file是io流，默认是sys.stderr</p>
<h1 id="异步流通信"><a href="#异步流通信" class="headerlink" title="异步流通信"></a>异步流通信</h1><p>异步通信流是用于处理网络连接的支持 async&#x2F;await 的高层级原语，来自asyncio模块，允许发送和接收数据，而不需要使用回调或低级协议和传输。使用流时通常无需手动实例化，在 asyncio.open_connection 等函数建立连接时，会自动返回的一对读写流</p>
<p>一套使用asyncio模块的异步通信流的完整流程，一般包括：B方开启服务等待连接，A方发起连接，连接双方保持监听对方的writer流，双方使用writer流立即“发送”数据，双方使用reader流按await方式接收数据</p>
<h2 id="建立流通信双方的连接"><a href="#建立流通信双方的连接" class="headerlink" title="建立流通信双方的连接"></a>建立流通信双方的连接</h2><p>coroutine asyncio.open_connection(<em>host&#x3D;None, port&#x3D;None, *, limit&#x3D;None, ssl&#x3D;None, family&#x3D;0, proto&#x3D;0, flags&#x3D;0, sock&#x3D;None, local_addr&#x3D;None, server_hostname&#x3D;None, ssl_handshake_timeout&#x3D;None, happy_eyeballs_delay&#x3D;None, interleave&#x3D;None</em>) 建立网络连接并返回一对 (StreamReader, StreamWriter) 实例。<br>参数 limit确定reader流的缓冲区大小，默认64KiB，其余参数传入 loop.create_connection()</p>
<p>coroutine asyncio.start_server(<em>client_connected_cb, host&#x3D;None, port&#x3D;None, *, limit&#x3D;None, family&#x3D;socket.AF_UNSPEC, flags&#x3D;socket.AI_PASSIVE, sock&#x3D;None, backlog&#x3D;100, ssl&#x3D;None, reuse_address&#x3D;None, reuse_port&#x3D;None, ssl_handshake_timeout&#x3D;None, start_serving&#x3D;True</em>) 启动套接字监听服务。</p>
<p>参数client_connected_cb是一个回调函数，当一个新的客户端连接建立时，它会接收一对 (StreamReader, StreamWriter)实例作为参数。这个回调函数可以是一个普通函数，也可以是一个协程，此时会自动作为Task被调度</p>
<p>参数limit确定返回的reader流的缓冲区大小，默认64KiB。除回调函数和limit这两个参数，其余都传入loop.create_server()</p>
<p>todo问题：start_server会在何时返回一对流</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python并发和异步</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>内嵌数据库sqlite3</title>
    <url>/2023/05/10/%E5%AD%A6%E4%B9%A0/python/python%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/%E5%86%85%E5%B5%8C%E6%95%B0%E6%8D%AE%E5%BA%93sqlite3/</url>
    <content><![CDATA[<p>一个轻量级的内嵌数据库，网络服务不是作为主要功能时，使用它更加便于管理</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SQLite本是一个C语言库，提供轻量级的基于磁盘的数据库，它不需要独立的服务器进程（因为所在程序本身即可通过库接口打开和控制数据库）。应用程序可以使用 SQLite 作为内部数据存储，也可以把它迁移到大型数据库。</p>
<p>使用需使用导入语句 <span>import sqlite3</span></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>sqlite3.connect(<em>database, timeout&#x3D;5.0, detect_types&#x3D;0, isolation_level&#x3D;’DEFERRED’, check_same_thread&#x3D;True, factory&#x3D;sqlite3.Connection, cached_statements&#x3D;128, uri&#x3D;False</em>) 打开到数据库的一个连接，返回一个 sqlite3.Connection</p>
<ul>
<li>database是一个路径类(path-like)对象，通常是一个作为数据库的文件路径。如果传递 “:memory:”, 则是直接在内存中开启一个数据库</li>
<li>timeout:float 最大尝试连接时间，sqlite数据库在已有连接的某些情况下，可能会锁住，无法进行其他连接</li>
<li>detect_types:int 可以是 PARSE_DECLTYPES 或 PARSE_COLNAMES，都是python类型到数据库类型的转换格式</li>
<li>isolation_level:(str|None) 为连接的隔离等级，控制事务是否或者如何打开。可以是 “DEFERRED”(推迟，默认), “EXCLUSIVE”(排他), “IMMEDIATE”(立即), None(禁用隐式打开事务)</li>
<li>check_same_thread:bool 默认为True，表示只有创建这个连接的的线程才能使用该连接；如果为False，则可以在多线程中共享连接，但同步问题需要由用户去管理</li>
<li>cached_statements:int 这个连接的内部缓存的语句数量，默认为100</li>
<li>uri:bool 如果设置为true，则database参数解释为一个文件路径。。。</li>
</ul>
<p>class sqlite3.Connection 数据库连接对象，每次打开数据库(connect())都会创建一个数据库连接对象。数据库连接对象在一般情景下的作用是1事务控制，和创建Cursor对象（通过它来执行sql语句和获取结果）。连接对象有“短语句方法”，即在语法上省略创建Cursor的语句，实际隐式创建Cursor来执行sql语句，个人感觉在此处无需记录</p>
<p><strong>使用上下文管理对象管理连接</strong>：注意，这里的管理的作用是，当sql语句多次execute后，在with末尾时（作为一个事务）自动提交，以及提交的事务出现错误时自动进行回退。连接对象需要在with关键字的范围外，进行连接和关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">con.execute(<span class="string">&quot;create table lang (id integer primary key, name varchar unique)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># con.rollback() 会自动在报错后调用</span></span><br><span class="line"><span class="comment"># 报错仍然会发出</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        con.execute(<span class="string">&quot;insert into lang(name) values (?)&quot;</span>, (<span class="string">&quot;Python&quot;</span>,))</span><br><span class="line"><span class="keyword">except</span> sqlite3.IntegrityError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;couldn&#x27;t add Python twice&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个上下文管理对象仅用于事务的自动提交和回退，不会管理连接对象的打开和关闭</span></span><br><span class="line"><span class="comment"># 所以需要体提前打开连接对象，在所有结束后手动关闭</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>


<h2 id="事务控制相关"><a href="#事务控制相关" class="headerlink" title="事务控制相关"></a>事务控制相关</h2><p>事务处理方式主要有： None, “DEFERRED”, “IMMEDIATE”, “EXCLUSIVE”，通常在创建连接对象时传入，设置于sqlite3.Connection.isolation_level属性 。对应着如下的控制行为：</p>
<ul>
<li>None  事务不会被隐式打开，处于自动提交模式，这时每条sql语句都是一个事务</li>
<li>“DEFERRED”  事务会被隐式打开。未覆盖isolation_level参数时，默认实现”DEFERRED”。存在一定规则的等待，见下文分析</li>
<li>“IMMEDIATE”  事务会被隐式打开。每次excute都会立即开启一个事务执行。会阻塞其他的写操作</li>
<li>“EXCLUSIVE”  事务会被隐式打开。在WAL模式下，和”IMMEDIATE” 效果相同</li>
</ul>
<p>如果选择隐式打开事务，那么使用commit和rollback方法分别提交和回滚挂起的事务。在事务隐式打开的情况下，通常使用关键字with来管理事务，会在即将退出范围时自动调用commit，以及出错时自动回滚，所以无需不讨论commit和rollback</p>
<p>**重点讨论”DEFERRED”**。在第一次调用execute时，就隐式开启一个事务，如果第一个操作是读，那么开启一个读事务，如果遇到写语句则升级（没有新建事务）为写事务。</p>
<h2 id="数据库路径相关"><a href="#数据库路径相关" class="headerlink" title="数据库路径相关"></a>数据库路径相关</h2><p>数据库路径基本有两种方式。一种是直接一个路径类型的参数，如 “test.db”期望的是当前工作目录下的一个数据库；另一种是指定 连接对象传入参数 uri&#x3D;True, 此时使用的数据库参数形如 “file:mem1?mode&#x3D;memory&amp;cache&#x3D;shared”</p>
<p>如果使用默认的路径类参数，除了一般的 “test.db” 这样的路径类参数，还可以是 “:memory:” 这个特殊参数，指定数据库存在于内存中。</p>
<p>URI类参数给出的例子有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">con0 = sqlite3.connect(<span class="string">&quot;file:template.db?mode=ro&quot;</span>, uri=<span class="literal">True</span>)</span><br><span class="line">con1 = sqlite3.connect(<span class="string">&quot;file:mem1?mode=memory&amp;cache=shared&quot;</span>, uri=<span class="literal">True</span>)</span><br><span class="line">con2 = sqlite3.connect(<span class="string">&quot;file:mem1?mode=memory&amp;cache=shared&quot;</span>, uri=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>URIs类参数详情需要另查<a href="https://www.sqlite.org/uri.html">文档</a></p>
<h2 id="Cursor对象执行sql语句"><a href="#Cursor对象执行sql语句" class="headerlink" title="Cursor对象执行sql语句"></a>Cursor对象执行sql语句</h2><p>在sqlite中直接进行sql语句执行和结果获取的是 class sqlite3.Cursor 对象。它可以执行sql语句并且管理返回结果。Cursor对象本身是可迭代的，意味着可以使用in关键字，迭代已执行sql语句的cursor对象，来获取每一行结果（一个Row对象）</p>
<p>Cursor.excute(<em>sql,paramaters&#x3D;(),&#x2F;</em>) 执行单个sql语句，sql语句中使用占位符映射到参数，其中第二个参数为元组类型</p>
<p>Cursor.excutemany(<em>sql,paramaters&#x3D;(),&#x2F;</em>) 可以执行多个sql语句，要求占位符映射的参数为sequence、map等可迭代类型作为参数（其元素也是元组），它等价于迭代调用execute</p>
<p>Cursor.excutescript(<em>sql_scipt</em>) 示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur.executescript(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    begin;</span></span><br><span class="line"><span class="string">    create table person(firstname, lastname, age);</span></span><br><span class="line"><span class="string">    create table book(title, author, published);</span></span><br><span class="line"><span class="string">    create table publisher(name, address);</span></span><br><span class="line"><span class="string">    commit;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Cursor.fetchone() 返回一个表示下一行内容的Row对象（类似元组），如果没有则返回None</p>
<p>同理 Cursor.fetchmany(<em>size&#x3D;cursor.arraysize</em>) 返回一个list，元素数量尽可能足够size，由于性能优化，最好使用 cursor.arraysize 属性（默认值为1）。获取不到时获得一个空列表</p>
<p>同理 Cursor.fetchall() 获得剩下的所有行，返回一个list</p>
<p>Cursor.close() 关闭这个cursor对象，此时不会关闭连接。最好在关闭连接前，也关闭一下这个。</p>
<p>属性Cursor.rowcount，只读，且仅当用excute或excutemany“增删改替”时会设置，返回受影响的行数。同理，属性Curosr.lastrowid制度且仅当用excute“增替”时会设置，返回最后一次成功操作的行id</p>
<p>属性Cursor.description, 只读，返回</p>
<h2 id="结果查看-Row对象"><a href="#结果查看-Row对象" class="headerlink" title="结果查看-Row对象"></a>结果查看-Row对象</h2><p>class sqlite3.Row 一个Row对象性质如同一个元组，可以当成元组使用。此外，还可以设置 Connect.row_factory 设置格式，但没必要</p>
<p>Row.keys() 返回一个list，对应一行的所有列名</p>
<h1 id="操作指引"><a href="#操作指引" class="headerlink" title="操作指引"></a>操作指引</h1><h2 id="查询语句中使用占位符"><a href="#查询语句中使用占位符" class="headerlink" title="查询语句中使用占位符"></a>查询语句中使用占位符</h2><p>使用占位符避免遭受sql注入。占位符有两种模式，一种是问号占位符，另一种是变量名占位符。它们的功能相同，仅是风格不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">&quot;create table lang (name, first_appeared)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问号风格占位符。参数通常为元组，执行many时使用元组的list</span></span><br><span class="line">cur.execute(<span class="string">&quot;insert into lang values (?, ?)&quot;</span>, (<span class="string">&quot;C&quot;</span>, <span class="number">1972</span>))</span><br><span class="line"></span><br><span class="line">lang_list = [</span><br><span class="line">    (<span class="string">&quot;Fortran&quot;</span>, <span class="number">1957</span>),</span><br><span class="line">    (<span class="string">&quot;Python&quot;</span>, <span class="number">1991</span>),</span><br><span class="line">    (<span class="string">&quot;Go&quot;</span>, <span class="number">2009</span>),</span><br><span class="line">]</span><br><span class="line">cur.executemany(<span class="string">&quot;insert into lang values (?, ?)&quot;</span>, lang_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量名风格占位符。参数为字典</span></span><br><span class="line">cur.execute(<span class="string">&quot;select * from lang where first_appeared=:year&quot;</span>, &#123;<span class="string">&quot;year&quot;</span>: <span class="number">1972</span>&#125;)</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>

<h2 id="使用适配器-python类型转为数据库类型"><a href="#使用适配器-python类型转为数据库类型" class="headerlink" title="使用适配器(python类型转为数据库类型)"></a>使用适配器(python类型转为数据库类型)</h2><p>对象可以自己设置一个适配器，其函数为 __conform__(self, protocol) ，只要在需要自动转换的类中添加这个函数，即可实现自动适配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__conform__</span>(<span class="params">self, protocol</span>):</span><br><span class="line">        <span class="keyword">if</span> protocol <span class="keyword">is</span> sqlite3.PrepareProtocol:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;%f;%f&quot;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, -<span class="number">3.2</span>)</span><br><span class="line">cur.execute(<span class="string">&quot;select ?&quot;</span>, (p,))</span><br><span class="line"><span class="built_in">print</span>(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>

<p>还可以注册适配器，使用模块函数 sqlite3.register_adapter(<em>python_object, adapter</em>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adapt_point</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%f;%f&quot;</span> % (point.x, point.y)</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br></pre></td></tr></table></figure>

<h2 id="使用转换器（数据库类型转换为python类型）"><a href="#使用转换器（数据库类型转换为python类型）" class="headerlink" title="使用转换器（数据库类型转换为python类型）"></a>使用转换器（数据库类型转换为python类型）</h2><p>自定义的转换器，只能通过显示注册的方法。使用 sqlite3.register_converter(<em>colname, converter</em>)，其中 colname 是字符串类型的对应列名，converter是自定义转换器</p>
<p>一个转换器如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_point</span>(<span class="params">s</span>):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="built_in">float</span>, s.split(<span class="string">b&quot;;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br></pre></td></tr></table></figure>

<h2 id="注册一对适配器、转换器实现python对象存取"><a href="#注册一对适配器、转换器实现python对象存取" class="headerlink" title="注册一对适配器、转换器实现python对象存取"></a>注册一对适配器、转换器实现python对象存取</h2><p>以下样例中展示了声明类型(sqlite3.PARSE_DECLTYPES)、指定类名sqlite3.PARSE_COLNAMES) 这两种情况下创建表，且字段类型为python对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adapt_point</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;point.x&#125;</span>;<span class="subst">&#123;point.y&#125;</span>&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_point</span>(<span class="params">s</span>):</span><br><span class="line">    x, y = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, s.split(<span class="string">b&quot;;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the adapter and converter</span></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line">sqlite3.register_converter(<span class="string">&quot;point&quot;</span>, convert_point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) Parse using declared types</span></span><br><span class="line">p = Point(<span class="number">4.0</span>, -<span class="number">3.2</span>)</span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>, detect_types=sqlite3.PARSE_DECLTYPES)</span><br><span class="line">cur = con.execute(<span class="string">&quot;create table test(p point)&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;insert into test(p) values (?)&quot;</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">&quot;select p from test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;with declared types:&quot;</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) Parse using column names</span></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>, detect_types=sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.execute(<span class="string">&quot;create table test(p)&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;insert into test(p) values (?)&quot;</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">&#x27;select p as &quot;p [point]&quot; from test&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;with column names:&quot;</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>


<p>datetime 模块中的 date 和 datetime 类型自带默认适配器和转换器，这里不记录</p>
<h2 id="通过名称而非索引访问Row对象内容"><a href="#通过名称而非索引访问Row对象内容" class="headerlink" title="通过名称而非索引访问Row对象内容"></a>通过名称而非索引访问Row对象内容</h2><p>sqlite3.Row有这样的特性，执行sql语句时通过特定语法，其结果对应的“元组”不仅可以被正常索引，也可以被名称访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur.execute(<span class="string">&quot;select &#x27;John&#x27; as name, 42 as age&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">0</span>] == row[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="string">&quot;name&quot;</span>] == row[<span class="string">&quot;nAmE&quot;</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">&quot;AgE&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用这种访问方式，可以比较好的提高代码可读性，也可以避免某些低级错误；是比较推荐的</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python数据持久化</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化模块pickle</title>
    <url>/2023/05/07/%E5%AD%A6%E4%B9%A0/python/python%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97pickle/</url>
    <content><![CDATA[<p>数据持久化的pickle模块</p>
<span id="more"></span>

<h1 id="pickle与其他的持久化的比较"><a href="#pickle与其他的持久化的比较" class="headerlink" title="pickle与其他的持久化的比较"></a>pickle与其他的持久化的比较</h1><p>与marshal模块比较：marshal序列化的方法更加原始，其存在主要是支持python的 .pyc 文件。在序列化python对象时首选是pickle</p>
<p>与JSON模块比较：两者有本质不同，JSON是一个文本序列化协议，且在python和python外广泛应用；pickle是一个二进制序列化格式，仅用于python对象的序列化</p>
<p>此外，有关数据库相关的持久化操作，通常数据库都会提供适当的转换器接口，允许用户定义 python类型 到 数据库数据类型 的互相转换，似乎没有必要通过pickle模块。如sqlite3允许用户定义 __conform__，或者通过注册的方法，来自定义python类型到数据库类型的转化；允许用户定义 </p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python数据持久化</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>异步IO</title>
    <url>/2023/05/06/%E5%AD%A6%E4%B9%A0/python/python%E7%BD%91%E7%BB%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<p>使用 async&#x2F;await 语法进行异步IO</p>
<span id="more"></span>

<p>简单的异步IO用法，其中关键字await只能在关键字async标记的函数中使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello ...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;... World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>asyncio是用来编写并发代码的库，使用async&#x2F;await语法，提供了一组<strong>高级</strong>API用于：</p>
<ul>
<li>协程</li>
<li>控制子进程</li>
<li>通过队列实现分布式任务</li>
<li>同步原语以并发</li>
</ul>
<p>还有<strong>低层级</strong>API以支持库和框架：</p>
<ul>
<li>创建和管理事件循环</li>
<li>使用transports实现高效率协议</li>
<li>用async&#x2F;await桥接基于回调的库和代码</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python网络和进程间通信</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>日志常用指引</title>
    <url>/2023/05/04/%E5%AD%A6%E4%B9%A0/python/python%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E6%8C%87%E5%BC%95/</url>
    <content><![CDATA[<p>日志工具logging的记录。本文仅记录通常用法，不深入研究</p>
<span id="more"></span>

<h1 id="日志基础"><a href="#日志基础" class="headerlink" title="日志基础"></a>日志基础</h1><h2 id="默认记录器的日志记录过程"><a href="#默认记录器的日志记录过程" class="headerlink" title="默认记录器的日志记录过程"></a>默认记录器的日志记录过程</h2><p>标题说的“日志记录过程”包括日志的 记录（仅存在于内存），过滤，格式化，处理（转储、转发等）这四个步骤。</p>
<p>日志有五个经典级别，从上往下严重性逐渐增加：</p>
<ol>
<li>DEBUG（仅用于调试）</li>
<li>INFO（一般信息）</li>
<li>WARNING（警告信息，这是默认级别）</li>
<li>ERROR（错误，已影响到系统）</li>
<li>CRITICAL（关键，系统已不能正常运行）</li>
</ol>
<p>日志记录器会按级别记录这五类信息。下面用默认的日志记录器去记录日志，记录的内容会按照 默认格式，默认级别WARNING，打印到默认位置（即控制台）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">&#x27;Watch out!&#x27;</span>)  </span><br><span class="line">logging.info(<span class="string">&#x27;I told you so&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台输出内容   WARNING:root:Watch out!</span></span><br></pre></td></tr></table></figure>

<h2 id="配置默认记录器"><a href="#配置默认记录器" class="headerlink" title="配置默认记录器"></a>配置默认记录器</h2><p>记录日志到文件：在代码中添加 <span>logging.basicConfig(filename&#x3D;’example.log’, encoding&#x3D;’utf-8’, level&#x3D;logging.DEBUG)</span></p>
<p>记录变量数据，内容要用格式化字符串，如： <span> logging.warning(‘%s before you %s’, ‘Look’, ‘leap!’) </span></p>
<p>指定格式，格式中可以额外添加时间，如： <span> format&#x3D;’%(levelname)s: ‘%(asctime)s – %(message)s’ </span>，这样可能会是这样的格式：<span>INFO: 2010-12-12 11:41:42,612 – is when this event was logged.</span></p>
<h1 id="模块化日志"><a href="#模块化日志" class="headerlink" title="模块化日志"></a>模块化日志</h1><p>模块化的日志记录过程分工明确，有记录器、处理器、过滤器和格式器</p>
<h2 id="模块化的记录器命名"><a href="#模块化的记录器命名" class="headerlink" title="模块化的记录器命名"></a>模块化的记录器命名</h2><p>推荐命名记录器的方式是，使用当前所处的（带上层级结构的）模块名。默认的记录器 logging，来自logging包且直接使用logging.debug()、logging.info() 记录是根记录器，在输出中打印为 “root”，其余如在模块 A.B 中的，可以命名为 A.B，那么要用下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块名相同时，返回的是同一个记录器引用</span></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;A.B&quot;</span>)</span><br><span class="line"><span class="comment"># 或通过  __name__ 获得模块名</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p>如果需要细分，甚至可以再额外添加类的范围，如命名 “A.B.ClassX”</p>
<h2 id="记录器"><a href="#记录器" class="headerlink" title="记录器"></a>记录器</h2><p>记录器是 Logger 类的实例，它向应用程序公开了debug~critical五种级别的日记记录方法，通过这五种方法应用程序完成日志的记录。其次，会根据添加在它身上的过滤器进行筛选，确认要处理的日志。然后，把筛选后的日志记录发送到处理器上</p>
<p>获取记录器，使用 logging.getLogger(<em>logger_name</em>) 返回指定名称的记录器实例的引用，否则返回根记录器实例的引用。如果多次调用的指定名称相同，它们返回的是同一个实例的引用。</p>
<p>指定的记录器名称按点分级，如 “foo.bar” 是 “foo” 的子记录器，那么 “foo” 如果没有自定义级别，则会沿用父级的级别，且会把消息传播到父级（父级的处理器会处理这个消息，除非指定propagate属性为False）</p>
<p>记录器最常见的配置方法：</p>
<ul>
<li>Logger.setLevel()  这相当于创建一个简单的过滤器并应用于本记录器对象。这并不会影响 debug()~critical() 这些日志的记录行为，仅在发送到处理器这一过程中有意义</li>
<li>Logger.addHandler(), Logger.removeHandler() 添加和删除处理器对象</li>
<li>Logger.addFilter(), Logger.removeFilter() 添加和删除过滤器对象。Logger.setLevel()已经起到了足够的过滤作用了，很多时候无需再用这两个方法添加过滤器</li>
</ul>
<p>记录器向应用程序公开的日志记录方法：</p>
<ul>
<li>Logger.debug(), Logger.info(), Logger.warning(), Logger.error(), Logger.critical()</li>
<li>仅允许在异常处理语句中使用：Logger.exception() 级别和error相同，但还会额外记录堆栈信息</li>
<li>自定义日志级别时使用： Logger.log()</li>
</ul>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>处理器对象 Handler 负责把过滤好的日志消息发送到指定目标（如标准输出流、本地文件、一个网络端口）。通常都使用内置处理器类作为参数，不需要用户实例化处理器对象</p>
<p>内置处理器对象可用以下方法：</p>
<ul>
<li>setLevel()  此处的setLevel用于筛选已经接收到的日志，记录器处的setLevel用于筛选发送给处理器的日志</li>
<li>setFormatter() 添加一个格式器对象，决定发送日志消息的格式</li>
<li>addFilter() 和 removeFilter()</li>
</ul>
<p>常见的处理器会在下方另起一节整理</p>
<h2 id="格式器"><a href="#格式器" class="headerlink" title="格式器"></a>格式器</h2><p>logging.Formatter.<strong>init</strong>(<em>fmt&#x3D;None, datefmt&#x3D;None, style&#x3D;’%’</em>)  格式器的构造函数有三个可选参数：消息格式字符串，日期格式字符串，样式指示符。</p>
<p>消息格式字符串内可用的日志相关的变量存放在LogRecord对象里，使用 %(&lt;attr_name&gt;)s 即可引用。常用的属性有：消息message、时间asctime、消息等级levelname、记录器名称name</p>
<p>日期格式字符串默认为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%Y-%m-%d %H:%M:%S</span><br></pre></td></tr></table></figure>

<p>实例化一个格式器后，即可传递给处理器使用。处理器通过 Handler.setFromatter(<em>my_fromatter</em>) 即成功传递</p>
<h2 id="过滤器（暂时用不到这么详细的）"><a href="#过滤器（暂时用不到这么详细的）" class="headerlink" title="过滤器（暂时用不到这么详细的）"></a>过滤器（暂时用不到这么详细的）</h2><p>当基于记录器级别和处理器级别的过滤不足够时，可以提供 Filter过滤器</p>
<h2 id="配置日志记录"><a href="#配置日志记录" class="headerlink" title="配置日志记录"></a>配置日志记录</h2><p>配置模块化的日志记录过程，1) 可以用代码实现记录器、过滤器、处理器、格式器，2) 也可以写成配置文件读取，3) 也可以写成一个字典读取。</p>
<p>后面两种方法这里不研究也不记录（和第一种方法也本质相同，仅是从文件方便维护），第一种方法的一个完整例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建以一个日志记录器</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simple_example&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建控制台处理器，并设置处理的日志等级</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建格式器</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台处理器添加格式器</span></span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志记录器添加刚刚创建的控制台处理器</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行日志记录</span></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>) </span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;warn message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;critical message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果日志配置文件因为某些原因找不到了，那么默认行为是把日志 存储在 logging.lastResort，仅在 sys.stderr 输出</p>
<h1 id="有用的处理器"><a href="#有用的处理器" class="headerlink" title="有用的处理器"></a>有用的处理器</h1><p>通常使用不考虑自定义日志级别和自定义处理器，通常使用以下处理器即可。注意，给记录器添加处理器时，无需实例化，仅需把处理器类传入：</p>
<p>class logging.StreamHandler(<em>stream&#x3D;None</em>) 可将日志记录输出发送到数据流例如 sys.stdout, sys.stderr(默认) 或任何文件类对象</p>
<p>class logging.FileHandler(<em>filename, mode&#x3D;’a’, encoding&#x3D;None, delay&#x3D;False, errors&#x3D;None</em>) 可将日志记录输出到磁盘文件中</p>
<p>class logging.NullHandler() 不进行任何处理操作，仅用于特殊需要时，如开发库时没有提供日志文件，但又不需要输出到 sys.stderr，此时添加它可以禁止输出</p>
<p>class logging.handlers.BaseRotatingHandler(<em>filename, mode, encoding&#x3D;None, delay&#x3D;False, errors&#x3D;None</em>)  基础日志轮换处理器。它有两个常用的子处理器RotatingFileHandler 和 TimedRotatingFileHandler。此外，如果要定制化日志轮换处理器，应该由这个类派生。（目前为止，没有发现可以自定义日志分割方式的方法，那么不妨换种思路，每个要记录在不同日志文件的代码区域，可以使用不同的记录器去记录）</p>
<p>class logging.handlers.RotatingFileHandler(<em>filename, mode&#x3D;’a’, maxBytes&#x3D;0, backupCount&#x3D;0, encoding&#x3D;None, delay&#x3D;False, errors&#x3D;None</em>)  基于文件大小的日志轮换处理器，如果日志文件超过一定大小，那么会转储一个新的日志文件，其日志文件命名如 app.log(当前正在记录的), app.log.1, app.log.2, … , app.log.backupCount</p>
<p>class logging.handlers.TimedRotatingFileHandler(<em>filename, when&#x3D;’h’, interval&#x3D;1, backupCount&#x3D;0, encoding&#x3D;None, delay&#x3D;False, utc&#x3D;False, atTime&#x3D;None, errors&#x3D;None</em>)  基于时间的日志轮换处理器，每个一段时间会转储一个新的日志文件，其日志文件命名同基于文件大小的。参数when可以是”S”、”M”、”H”、”D”、”W0”-“W6”(可指定atTime)、”midnight”(可指定atTime)</p>
<p>class logging.handlers.SMTPHandler(<em>mailhost, fromaddr, toaddrs, subject, credentials&#x3D;None, secure&#x3D;None, timeout&#x3D;1.0</em>)  mailhost指定smtp服务器地址，如果是非标准smtp服务器端口，则mailhost传入(host,port)元组，否则直接传入一个ip或域名字符串即可。fromaddr和toaddr分别为发件人地址和收件人地址，收件人地址为收件人的邮箱。subject为邮件主题。credentials可能是一个(username,password)元组。secure仅当使用TLS时，传入一个元组，该元组可能为空，可能仅有一个密钥元组，也可能是一组密钥对的作为两个元素</p>
<p>SocketHandler发送到TCP套接字、DatagramHandler发送到UDP套接字、MemoryHandler发送到内存、HTTPHandler发送到web服务器、QueueHandler发送日志到一个队列，与QueueListener配套使用，用于多线程处理问题。</p>
<h1 id="使用任意对象作为消息"><a href="#使用任意对象作为消息" class="headerlink" title="使用任意对象作为消息"></a>使用任意对象作为消息</h1><p>这个条件是，所用的对象可以被序列化，拥有 __str()__ 方法</p>
<h1 id="简单优化"><a href="#简单优化" class="headerlink" title="简单优化"></a>简单优化</h1><p>使用 Logger.isEnabledFor(<em>level</em>) 进行判断当前记录器的记录等级，可以避免同时进行的消耗资源的操作。：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> logger.isEnabledFor(logging.DEBUG):</span><br><span class="line">    logger.debug(<span class="string">&#x27;Message with %s, %s&#x27;</span>, expensive_func1(),</span><br><span class="line">                                        expensive_func2())</span><br></pre></td></tr></table></figure>

<p>还可以在记录时禁止收集一些信息：</p>
<table>
<thead>
<tr>
<th>不想收集的内容</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>调用来源信息</td>
<td>logging._srcfile设置为None</td>
</tr>
<tr>
<td>线程信息</td>
<td>logging.logThreads设置为False</td>
</tr>
<tr>
<td>当前进程ID(os.getpid())</td>
<td>logging.logProcesses设置为False</td>
</tr>
<tr>
<td>进程名称</td>
<td>logging.logMultiprocessing设置为False</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python日志</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>底层网络接口socket</title>
    <url>/2023/04/27/%E5%AD%A6%E4%B9%A0/python/python%E7%BD%91%E7%BB%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3socket/</url>
    <content><![CDATA[<p>BSD（Berkeley）套接字应用程序接口，简称套接字，主要用于实现进程间通讯。所用的socket模块的行为可能因平台不同而异常，因为调用的是操作系统的套接字API</p>
<span id="more"></span>






]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python网络和进程间通信</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>ctypes-与C兼容的外部库</title>
    <url>/2023/04/25/%E5%AD%A6%E4%B9%A0/python/python%E5%B0%8F%E8%AE%B0/ctypes-%E4%B8%8EC%E5%85%BC%E5%AE%B9%E7%9A%84%E5%A4%96%E9%83%A8%E5%BA%93/</url>
    <content><![CDATA[<p>ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python小记</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>观《白色巨塔》有感</title>
    <url>/2023/04/21/%E9%98%85%E8%AF%BB/%E8%A7%82%E3%80%8A%E7%99%BD%E8%89%B2%E5%B7%A8%E5%A1%94%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>机缘巧合下，看了《白色巨塔》这一电视剧，有所感触</p>
<span id="more"></span>

<h1 id="2023年4月22日看到第11集有感"><a href="#2023年4月22日看到第11集有感" class="headerlink" title="2023年4月22日看到第11集有感"></a>2023年4月22日看到第11集有感</h1><p>看到了很多，又说不出来，幸运的是已经有所长大，不会从一个行为去单纯地去批评一个角色，也因而感慨良多不知从何组织言语。里见医生的正义和理想有时用力过度令人反感，但最终还是讨厌不起来；一个饱食人间烟火，为作为医生面临的种种现状烦恼，他的作为却出淤泥而不染。也想借用财前五郎和别人交流的一段话来看待里见:<br><span><br><br>&amp;emsp;&amp;emsp;财前：他似乎不想成名，但又不是懒惰，单纯地为了患者为了医学，全力付出所学，真的有这种人吗？<br><br>&amp;emsp;&amp;emsp;花森：你怎么觉得呢？<br><br>&amp;emsp;&amp;emsp;财前：一定是骗人的，我是为自己而活的，每个人不都是这样吗？<br><br>&amp;emsp;&amp;emsp;花森：是呢<br><br>&amp;emsp;&amp;emsp;财前：我会很困扰的，若他不是撒谎的话，我会很困扰的.<br><span><br>财前相信自己的一套做法是正确的，可是面对里间纯粹的作为医生的理念，他却无法否定，哪怕后来当上教授，他也没有否定掉里见的理想。</p>
<p>看电视剧的时候，涉及到一场拜托财前的秘密手术的“告密”，弹幕中随后谈及现实生活中能不能和里间做同事。我的想法是这样的，若是心中向美，便可寻求成为朋友，里间坚守信念的同时并非不进人情，他不会否定心中的别人心中的恶，但是会希望别人慢慢摒除心中的恶；他可以接受人的自私、贪婪、傲慢、势利，在自己保持信念的同时，希望可以慢慢改变他人。他的眼中也并非事事都分好坏，正是他的善良会与现实交织，所以也会一直纠结迷茫和烦恼。他真的是一个好朋友啊，会理解你，不会过分要求你，但衷心希望你变好；你看到他坚守信念的样子，不知不觉也会前往。如果要被卷入纠纷，若是实力不济，躲藏风波也是理所当然，里见也不会因此有所偏见。正是出淤泥而不染，却不躲避和轻视污泥；正是他得以出淤泥而不染的坦然和纯粹，和愿意出于淤泥的包容与洞察，作为一个朋友是永远是合适的。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>字节类对象</title>
    <url>/2023/04/19/%E5%AD%A6%E4%B9%A0/python/python%E5%B0%8F%E8%AE%B0/%E5%AD%97%E8%8A%82%E7%B1%BB%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>字节类对象应该按照c的理解</p>
<span id="more"></span>

<p>支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 bytes、bytearray 和 array.array 对象，以及许多普通 memoryview 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 bytearray 以及 bytearray 的 memoryview。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 bytes 以及 bytes 对象的 memoryview。</p>
<p>一个缓冲如果是 C 连续 或 Fortran 连续 就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python小记</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2023/04/19/%E5%AD%A6%E4%B9%A0/python/python%E5%B0%8F%E8%AE%B0/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="python的赋值操作"><a href="#python的赋值操作" class="headerlink" title="python的赋值操作"></a>python的赋值操作</h1><p>Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，最好要拷贝副本。为此应使用拷贝操作</p>
<h1 id="拷贝操作"><a href="#拷贝操作" class="headerlink" title="拷贝操作"></a>拷贝操作</h1><p>来自 Lib&#x2F;copy.py ，使用时<span>import copy</span>即可</p>
<p>接口摘要：</p>
<ul>
<li>copy.copy(<em>x</em>) 返回浅层复制的对象</li>
<li>copy.deepcopy(<em>x[, memo]</em>) 返回深层赋值的对象</li>
<li>exception copy.Error  针对模块特定错误引发</li>
</ul>
<p>深、浅赋值的区别仅与符合对象相关。因为复合对象存储的项可能仅是另一个对象的引用，故浅层复制会复制引用；深层复制则会尝试递归地复制所有内容，这对直接或间接包含自身的复合对象来说会导致无限递归。更为复杂且不常用的内容不再记述</p>
<p>字典的浅层复制可以用 dict.copy()，列表的浅层复制可以使用切片 copied_list &#x3D; list[:] </p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python小记</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>基于进程的并发Process</title>
    <url>/2023/04/19/%E5%AD%A6%E4%B9%A0/python/python%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>multiprocessing 包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了全局解释器锁，因此充分利用机器的多核。该模块提供了部分与 threading 使用方式类似的API以产生进程</p>
<span id="more"></span>

<h1 id="Process类和异常"><a href="#Process类和异常" class="headerlink" title="Process类和异常"></a>Process类和异常</h1><p>class multiprocessing.Process(group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;{}, *, daemon&#x3D;None)<br>其参数作用和 threading.Thread 相似，不再赘述。包括方法 run(),start(),join([<em>timeout</em>]),is_alive() ；属性 name, daemon 都与线程模块中的作用类似。</p>
<p>除了 threading.Thread API ，还有以下属性或方法：</p>
<ul>
<li>属性pid</li>
<li>属性exitcode  子进程的退出码</li>
<li>属性authkey  进程的身份验证密钥</li>
<li>属性sentinel 系统对象的数字句柄</li>
<li>方法terminate(),kill()</li>
<li>方法clase()   关闭Process对象，释放关联资源，如果底层进程仍在运行引发ValueError</li>
</ul>
<p><strong>异常</strong> </p>
<ul>
<li>exception multiprocessing.ProcessError 所有multiprocessing异常的基类</li>
<li>exception multiprocessing.BufferTooShort 缓冲区太小导致无法读取消息</li>
<li>exception multiprocessing.AuthenticationError 身份验证错误</li>
<li>exception multiprocessing.TimeoutError 有方法超时</li>
</ul>
<h1 id="进程间通信-管道和队列"><a href="#进程间通信-管道和队列" class="headerlink" title="进程间通信-管道和队列"></a>进程间通信-管道和队列</h1><p>使用多进程时，一般使用消息机制实现进程间通信，尽可能避免使用同步原语。消息机制有包含：管道Pipe可用于两个进程间通信，队列Queue用于多进程通信</p>
<h2 id="管道Pipe和Connection对象"><a href="#管道Pipe和Connection对象" class="headerlink" title="管道Pipe和Connection对象"></a>管道Pipe和Connection对象</h2><p>管道 <span>multiprocessing.Pipe([<em>duplex</em>])</span> 返回一对 Connection 对象(conn1, conn2) 分别表示管道的两端。duplex默认为True，这表示管道是双向的</p>
<p>class multiprocessing.connection.Connection 对象通常由multiprocessing.Pipe()创建，允许收发可以序列化的对象或字符串。它们可以看作面向消息的连接套接字。Connection对象支持上下文管理协议，__enter__()返回连接对象，__exit__()会调用close()</p>
<p>send(<em>obj</em>) 发送一个对象到连接的另一端，可用recv()获取。发送的对象必须是可序列化的，过大的对象(接近32MiB+，这取决于操作系统 )有可能引发ValueError异常。</p>
<p>recv() 返回另一端使用send()发送的对象，该方法会一直阻塞直到获取资源。如果关闭连接，或者没有资源可接受，将抛出EOFError异常</p>
<p>fileno() 返回由连接对象使用的文件描述符</p>
<p>close() 关闭连接对象。当连接对象被垃圾回收时会自动调用</p>
<p>poll([<em>timeout</em>]) 返回连接对象是否有可以读取的数据，未指定timeout则立马返回。此外，若想查询一些列Connection, socket.socket或其他对象，那么要使用 multiprocessing.connection.wait(<em>object_list[, timeout&#x3D;None]</em>)，一旦列表中的对象有可读取数据，那么就返回这个对象</p>
<p>send_bytes(<em>buffer[,offset[,size]]</em>) 从一个字节类对象(bytes-like object)中取出字节数组并作为一条完整消息发送。过大的缓冲区可能会引起ValueError异常</p>
<p>recv_bytes(<em>[maxlength]</em>) 以字符串形式返回接收到的字节数据。如果指定了maxlength，当消息长于maxlength时会抛出OSError，此时该连接对象不再可读。</p>
<p>recv_bytes_into(<em>buffer[, offset]</em>)<br>将一条完整的字节数据消息读入buffer中并返回消息的字节数。此方法在接收到数据前将一直阻塞。如果连接对象被对端关闭或者没有数据可读取，将抛出EOFError异常。如果缓冲区太小，会引发BufferTooShort</p>
<h2 id="消息队列Queue"><a href="#消息队列Queue" class="headerlink" title="消息队列Queue"></a>消息队列Queue</h2><p>class multiprocessing.Queue(<em>[maxsize]</em>)  返回一个由一个管道、少量锁、少量信号量实现的共享队列实例。当一个进程将一个对象放进队列中时，一个写入线程会启动并将对象从缓冲区写入管道中。通常超时引发 queue.Empty 和 queue.Full。消息队列中有很多方法和标准库中的queue.Queue相似，如put, get</p>
<p>put(<em>obj[,block[,timeout]]</em>) 将obj放入队列，默认会阻塞直至有空的缓冲槽。如果block为False（等效于put_nowait(obj)），那么会直接尝试放入，若无法放入则引发 queue.Full</p>
<p>get(<em>[block[,timeout]]</em>) 从队列中取出并返回对象，如果可用则直接返回，否则阻塞直至有内容。如果block为False（等效于get_nowwait()），那么会直接尝试获取，无法获取则引发 queue.Empty</p>
<p>close() 指示当前进程将不会再往队列中放入元素。一旦缓冲区中的所有数据被写入管道之后，后台的写入线程会退出。这个方法在队列被gc回收时会自动调用。使用close()后，才可执行join_thread()，这个会阻塞当前进程直至后台的写入线程退出，确保缓冲区内容写入管道前，本进程不会退出从而导致写入线程意外结束。</p>
<p>还有Queue的子类的JoinableQueue，额外有task_done()和join(), 暂不关注</p>
<h1 id="multiprocessing模块函数"><a href="#multiprocessing模块函数" class="headerlink" title="multiprocessing模块函数"></a>multiprocessing模块函数</h1><p>上下文Context对象有和multiprocessing模块相同的API</p>
<p><strong>multiprocessing.active_children()</strong> 返回当前进程存活的子进程的列表.调用该方法有“等待”已经结束的进程的副作用。</p>
<p><strong>multiprocessing.cpu_count()</strong> 返回系统的CPU数量，效果等同于os.cpu_cout()。这和进程可用的CPU数量不同，进程可用的CPU数量可以由 len(os.sched_getaffinity(0)) 方法获得。</p>
<p><strong>multiprocessing.current_process()</strong> 返回当前进程对应的Processor对象</p>
<p><strong>multiprocessing.parent_process()</strong> 返回父进程对应的Processor对象</p>
<p><strong>multiprocessing.freeze_support()</strong> 提供冻结以产生windows可执行文件的支持。在</p>
<p><strong>multiprocessing.get_all_start_methods()</strong> 返回支持的启动方法列表。在Windows中，只有’spawn’是可用的；Unix平台总是支持’fork’和’spawn’，且’fork’是默认值</p>
<p><strong>multiprocessing.get_context(<em>method&#x3D;None</em>)</strong> 使用对应的method返回一个Context对象，该对象有着和multiprocessing同样的API</p>
<p><strong>multiprocessing.set_executable(executable)</strong> 设置在启动子进程时使用的 Python 解释器路径。默认使用 sys.executable，部分系统上这可能为空</p>
<p><strong>multiprocessing.set_start_method(method)</strong> 设置启动子进程的方法。可以是 ‘fork’,’spawn’或者’forkserver’。这最多启用一次，且需要由 <span>if__name__&#x3D;&#x3D;’<strong>main</strong>‘</span>保护</p>
<h1 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h1><p>在多进程中，也有和 threading 模块类似的同步类。相比在多线程中，同步对象并没有那么重要</p>
<h1 id="共享ctypes对象（暂时不记录，等待学习ctypes）"><a href="#共享ctypes对象（暂时不记录，等待学习ctypes）" class="headerlink" title="共享ctypes对象（暂时不记录，等待学习ctypes）"></a>共享ctypes对象（暂时不记录，等待学习ctypes）</h1><h1 id="管理器Manager"><a href="#管理器Manager" class="headerlink" title="管理器Manager"></a>管理器Manager</h1><p>管理器提供了一个服务，可以跨进程、跨机器共享函数和对象。管理器对象也支持上下文管理协议，__enter__() 启动服务进程并且返回管理器对象，__exit__()会调用shutdown() </p>
<h2 id="基础的管理器BaseManeger"><a href="#基础的管理器BaseManeger" class="headerlink" title="基础的管理器BaseManeger"></a>基础的管理器BaseManeger</h2><p>class multiprocessing.managers.BaseManager(<em>[address[, authkey]]</em>)  创建一个BaseManager对象，一旦创建需要及时start(), 或 get_server().serve_forever() 确保管理器对象对应的进程尽早启动。</p>
<p>参数address是管理器服务器的监听地址，传入一个元组，形式为 (‘domain’, port)，作为服务器时domain是仅允许指定域名联机，为空字符串时不限制；作为客户端时用于连接指定的服务器；port是管理器进程监听的端口。</p>
<p>参数authkey是认证标识，用于检查连接服务进程的请求合法性。必须是byte类型的字符串，如 b’abc’, 如果是None则使用current_process().authkey</p>
<p>start(<em>[initialize[, initargs]]</em>) 在当前进程创建一个管理器对象对应的子进程。可以指定一个初始化函数及其参数，子进程启动时执行初始化函数 initialize(*initargs) 。可以使用 shutdown()停止管理器对应进程，它可以被多次调用</p>
<p>get_server() 返回一个Server对象，它是管理器在后台控制的真实的服务，有address属性。Server可以执行serve_forver(), 它的功能应该和start类似</p>
<p>connect() 返一个本地管理器。在执行connect()前，这个本地管理器需要设置好“连接属性”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line">m = BaseManager(address=(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">50000</span>), authkey=<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">m.connect()</span><br></pre></td></tr></table></figure>

<p>管理器的核心，<strong>类函数</strong>–*<em>register(typeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])</em>  注册类型（通常是类）或可调用对象到BaseManeger类，这样其他连接到这个管理器的本地管理器都可以获取到这个可调用对象。参数typeid是字符串类型，用于唯一表示共享对象类型；参数callable是一个和typeid对应的可调用对象；proxytype是 BaseProxy的子类，可以根据typeid为共享对象创建一个代理，如果是None，则会自动创建一个代理类；其他参数难以理解，省略解释</p>
<h2 id="可同步进程的SyncManager（暂时不需要，不整理）"><a href="#可同步进程的SyncManager（暂时不需要，不整理）" class="headerlink" title="可同步进程的SyncManager（暂时不需要，不整理）"></a>可同步进程的SyncManager（暂时不需要，不整理）</h2><h2 id="注册共享类型或可调用对象"><a href="#注册共享类型或可调用对象" class="headerlink" title="注册共享类型或可调用对象"></a>注册共享类型或可调用对象</h2><p>注意，要共享一个类型或可调用对象，注册行为在本地管理器和服务器管理器都要进行，区别是，服务器管理器需要指明typeid和callable；本地管理器只需要typeid</p>
<p>基于BaseManeger派生一个子类，在子类上使用 register 注册可调用对象，是管理器对象创建共享可调用对象或共享类型的方式。以下代码使用自定义管理器注册一个共享类型和一个共享对象，打开服务后，由<strong>服务器端的管理器对象</strong>去访问共享类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathsClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyManager</span>(<span class="title class_ inherited__">BaseManager</span>):<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册行为，共享 MathsClass</span></span><br><span class="line">MyManager.register(<span class="string">&#x27;Maths&#x27;</span>,MathClass)</span><br><span class="line"><span class="comment"># 注册行为，共享一个队列对象</span></span><br><span class="line">MyManager.register(<span class="string">&#x27;get_queue&#x27;</span>,Queue())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 使用上下文管理协议，进入时启动服务并返回管理器对象；退出时shutdown()</span></span><br><span class="line">    <span class="keyword">with</span> MyManager(address=(<span class="string">&#x27;&#x27;</span>, <span class="number">50000</span>), authkey=<span class="string">b&#x27;abracadabra&#x27;</span>) <span class="keyword">as</span> manager:</span><br><span class="line">        maths = manager.Maths() <span class="comment"># 返回共享类型后，构建了一个MathsClass的对象</span></span><br><span class="line">        <span class="built_in">print</span>(maths.add(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">        q = manager.get_queue() <span class="comment"># 返回一个共享对象</span></span><br><span class="line">        q.put(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">        q.get()</span><br></pre></td></tr></table></figure>

<p>上面的服务端管理器启动了一会服务，并且可在本地直接使用管理器对象访问共享类型和共享对象。下面是一个<strong>客户端的管理器对象</strong>尝试访问共享对象的过程(上面的服务器启动片刻就退出了，下面假设服务器长时间运行)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueManager</span>(<span class="title class_ inherited__">BaseManager</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">QueueManager.register(<span class="string">&#x27;get_queue&#x27;</span>) <span class="comment"># 要访问远程共享资源，也要注册，此时不需要callable</span></span><br><span class="line">m = QueueManager(address=(<span class="string">&#x27;server_domain&#x27;</span>, <span class="number">50000</span>), authkey=<span class="string">b&#x27;abracadabra&#x27;</span>)</span><br><span class="line">m.connect()</span><br><span class="line">queue = m.get_queue()</span><br><span class="line">queue.put(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="代理对象-大概知道客户端获得的共享对象实际是一个“代理”，目前无需整理"><a href="#代理对象-大概知道客户端获得的共享对象实际是一个“代理”，目前无需整理" class="headerlink" title="代理对象(大概知道客户端获得的共享对象实际是一个“代理”，目前无需整理)"></a>代理对象(大概知道客户端获得的共享对象实际是一个“代理”，目前无需整理)</h2><p>在上述客户端获取远程共享类型或共享对象后，使用的“引用”实际是一个代理对象</p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>进程池可与使用 Pool 类执行提交给它的任务。最好用上下文管理协议去启用一个进程池子，否则容易导致进程在终结阶段挂起</p>
<p>class multiprocessing.pool.Pool(<em>[processes[, initializer[, initargs[, maxtasksperchild[, context]]]]]</em>) 一个进程池对象，它控制可以提交作业的工作进程池。它支持带有超时和回调的异步结果，以及一个并行的 map 实现。参数processes默认os.cpu_count()，为工作进程数量。工作进程将会在启动时调用 initializer(*initargs)。maxtasksperchild则表示一个工作进程结束时最大处理的任务数量。context可用于指定上下文，通常一个进程池由multiprocessing.Pool()或上下文对象的Pool(),此时上下文已被适当设置，无需再设</p>
<p>相关方法看不太懂，省略一下</p>
<h2 id="多进程模块的监听器及客户端"><a href="#多进程模块的监听器及客户端" class="headerlink" title="多进程模块的监听器及客户端"></a>多进程模块的监听器及客户端</h2><p>multiprocessing.connection 模块其实提供的用来操作socket或管道的。最基础的用法是通过它抽象出来的高级API来操作套接字或者管道。暂不关注</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python并发</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>基于线程的并发Threading</title>
    <url>/2023/04/13/%E5%AD%A6%E4%B9%A0/python/python%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>python并发有三种基本方式，基于线程的，基于进程的，基于协程的。目前尝试运用于负载测试中，考虑到并发数很容易达到上百上千，那么应该使用线程并发和协程并发。在机器性能仍有余力的情况下，线程并发模拟的压力更加稳定和准确</p>
<span id="more"></span>
<h1 id="模块函数（不是很重要，先放放）"><a href="#模块函数（不是很重要，先放放）" class="headerlink" title="模块函数（不是很重要，先放放）"></a>模块函数（不是很重要，先放放）</h1><h1 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h1><p>只需要初始化线程的local实例即可，并在其中存储值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mydata = threading.local()</span><br><span class="line">mydaya.x = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这个 mydaya.x &#x3D; 1 在每个线程中的值都是独立的，独属于该线程</p>
<h1 id="线程对象"><a href="#线程对象" class="headerlink" title="线程对象"></a>线程对象</h1><p><span>class threading.Thread(group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;{}, *, daemon&#x3D;None)</span></p>
<p><strong>传入参数</strong>有：</p>
<ul>
<li>group是保留内容；target指定run的内容；name指定线程名称</li>
<li>args和kwargs都是服务于目标函数，即作为target的参数</li>
<li>daemon默认None时继承线程的守护模式属性，主线程为不能是守护线程，所以自主线程创建的子线程必不是守护线程；非None则显示指定为守护线程</li>
</ul>
<p><strong>方法</strong>有：start(), run(), join(), is_alive(), isDaemon()<br>其中join()需要注意一下</p>
<p><strong>属性</strong>有：name线程名，多个线程可以用一样的名字；ident线程标识符，可另用get_ident() 获得；native_id线程ID，由内核分配，可另用get_native_id()获得；daemon是否为守护线程</p>
<h1 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h1><h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p>“上下文管理协议”是一个专用于锁管理的with语句。其中的锁可以是原始锁或是其子类，只需由acquire和release即可，具体是 Lock、RLock、Condition、Semaphore、BoundedSemaphore</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> some_lock:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">some_lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    some_lock.release()</span><br></pre></td></tr></table></figure>

<h2 id="原始锁"><a href="#原始锁" class="headerlink" title="原始锁"></a>原始锁</h2><p>这里的锁对象指的是原始锁，原始锁是一个在锁定时不属于特定线程的同步基元组件，是python中的最低级同步组件，它由底层多线程API模块_thread直接实现。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放</p>
<p>class threading.Lock 其构造函数是一个工厂函数，返回的是所在平台最有效版本的实例。以下方法构成了“锁”逻辑的最重要功能</p>
<p><strong>acquire(<em>blocking&#x3D;True, timeout&#x3D;-1</em>)</strong> 默认获得锁时会阻塞其他线程获得锁，成功上锁会返回true。如果指定timeout一个正值浮点数，则该锁最多会阻塞指定相应时间</p>
<p><strong>release()</strong> 释放一个锁。这个方法可以在任何线程中调用，即非a线程允许解除a线程的已经获得的锁，故需要注意使用，非必要应由持有锁的线程去解锁。当在未锁定的锁上发起调用时，会引发 RuntimeError。</p>
<p><strong>locked()</strong> 判断锁对象是否已经上锁</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>递归锁相比原始锁，多了上锁层数和解锁层数，还有必须由本线程才能完成最终release()</p>
<h2 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h2><p>class threading.Condition(lock&#x3D;None) 条件锁的底层锁默认为重入锁，也可以指定一个原始锁或重入锁。使用条件锁，可以有序地唤醒阻塞线程。相比原始锁，更适用于经常发生资源竞争且可能出现死锁的情况，因为原始锁被释放后，所有线程会一起抢夺资源，而条件锁能主动控制如何唤醒线程，且在阻塞状态时不占用竞争资源（如需要4个，可用2个，那么这个2个也会释放）</p>
<p><strong>wait(<em>timeout &#x3D; None</em>)</strong> 等待直到被通知或超过限时。调用这个方法时，会释放本身的锁，原先无锁则会引发 RuntimeError，然后陷入阻塞，直到被唤醒时才会<strong>尝试</strong>重新获得锁（注意，唤醒后不会直接获得锁，要等调用notify的线程等一会释放锁）。可见这里使用wait的<strong>前提</strong>是，判断到需要使用的资源不足；如果充足，主动进入阻塞是错误的，因为wait之后要被其他线程主动唤醒。当底层锁为RLock时，阻塞时的解锁和被唤醒的上锁有所区别</p>
<p><strong>wait_for(<em>predicate,timeout &#x3D; None</em>)</strong> 等待至条件为真，再进行wait，predicate是一个返回值为布尔的可调用对象。忽略超时功能时，调用wait_for相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> predicate():</span><br><span class="line">    cv.wait()</span><br></pre></td></tr></table></figure>

<p><strong>notify(<em>n&#x3D;1</em>)</strong> 默认唤醒一个等待这个条件的线程，要求已获得锁，否则引发RuntimeError。注意，唤醒其他线程后，仅仅是让它重新进入了阻塞状态，还需要手动释放锁。唤醒所有等待这个条件的线程使用 notify_all()</p>
<h2 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h2><p><strong>信号量通常用于保护数量有限的资源。</strong> class threading.Semaphore(<em>value&#x3D;1</em>) 一个信号量管理一个内部原子性计数器，表示当前剩余资源数量，当acquire()时递减，当release()时递增。计数器不会小于零，当acquire()发现计数为零时，会阻塞直到其他线程调用release()。</p>
<p><strong>acquire(<em>blocking&#x3D;True, timeout&#x3D;None</em>)</strong> 在默认情况下，如果计数器大于等于一，则计数减一并立即返回true；如果计数为零，则进入阻塞，直至被唤醒后返回true。每次release()后将会以不确定次序唤醒一个线程。如果超过时限会返回false</p>
<p><strong>release(<em>n&#x3D;1</em>)</strong> 释放一个信号量，并将计数加n</p>
<p>比较特殊的是有界信号量 class threading.BoundedSemaphore(<em>value&#x3D;1</em>)，它的作用是，保证资源数量不会大于指定值，用于保护数量有限且需要留有剩余的资源没有被超额请求</p>
<p>信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主线程中</span></span><br><span class="line">MaxConnections = <span class="number">5</span></span><br><span class="line">pool_sema = BoundedSemaphore(value=MaxConnections)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子线程中</span></span><br><span class="line"><span class="keyword">with</span> pool_sema:</span><br><span class="line">    conn = connectdb()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure>


<h1 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h1><h2 id="线程间简单通信"><a href="#线程间简单通信" class="headerlink" title="线程间简单通信"></a>线程间简单通信</h2><p>事件对象可以实现线程间最简单的通信，其通信内容仅是一个逻辑值，可以实现这样的机制：一个线程可以发出事件信号，而其他线程等待这个事件信号</p>
<p>class threading.Event 实现事件对象的类。事件对象管理一个内部标识，初始值为false。调用 set(), clear() 能够把内部标识置true，置false；调用 wait(timeout&#x3D;None) 让所在线程阻塞直至内部标识为true。使用 is_set() 可以判别内部标识</p>
<h2 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h2><p>class threading.Barrier(parties, action&#x3D;None, timeout&#x3D;None) 栅栏对象提供一个简单的同步原语，用于多个线程互相等待的情况，线程调用 wait() 方法后将阻塞，直到所有线程都调用了 wait() 方法，此时所有线程将被同时释放。如果提供了action参数，它会在所有线程被释放时在其中一个线程中自动调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Barrier(<span class="number">2</span>, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>():</span><br><span class="line">    start_server()</span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = accept_connection()</span><br><span class="line">        process_server_connection(connection)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>():</span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = make_connection()</span><br><span class="line">        process_client_connection(connection)</span><br></pre></td></tr></table></figure>

<p>wait(<em>timeout&#x3D;None</em>) 方法用于“冲击”栅栏，只有当足够数量的线程正在“冲击”栅栏时，才能成功“冲破”。这里timeout优先级高于构造栅栏的。成功“冲破”时返回一个 0 ~ parties-1 之间的和其他线程不同的唯一值，可以用它来执行只有个别线程能够执行的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = barrier.wait()</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 只有这个线程才会打印</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;passed the barrier&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>栅栏破损态</strong> 属性broken可以表示栅栏是否处于破损态。如果创建栅栏对象时制定了action，那么顺利冲破栅栏后会在释放其中一个线程时被调用，如果action引发了异常，那么栅栏对象会进入破损态；如果发生超时，也会进入破损态。栅栏对象破损后的任何wait()，或者reset()栅栏时仍有线程等待释放，将会引发 BrokenBarrierError 异常</p>
<p><strong>方法 reset()</strong> 重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 BrokenBarrierError 异常。如果栅栏损坏，最好废弃并重新创建一个</p>
<p><strong>方法 abort()</strong> 主动使栅栏处于破损态，可能在需要强制终止某个线程时使用。但刚好的方法是设置合理的超时时间</p>
<h1 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h1><p>定时器对象 class threading.Timer(interval, function, args&#x3D;None, kwargs&#x3D;None) 是线程类Thread的子类，因此可以像线程一样工作。与线程一样，通过调用 start() 方法启动定时器。而 cancel() 方法可以停止计时器（在计时结束前）。Timer类实现的功能是，经过一段时间执行函数的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">30.0</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># 过了30s就会执行hello函数</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python并发</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>识崩崩小圆帽有感</title>
    <url>/2023/04/10/%E9%98%85%E8%AF%BB/%E8%AF%86%E5%B4%A9%E5%B4%A9%E5%B0%8F%E5%9C%86%E5%B8%BD%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>原愚人众第六执行官散兵，其背景在稻妻已基本描绘完成，再待到须弥主线的间章，完成了“倾奇者-散兵-七叶寂照秘密主-流浪者-崩崩小圆帽”的转变</p>
<span id="more"></span>
<p>先说起名崩崩小圆帽的缘由。</p>
<p>散兵本是纯洁无暇的人偶，被雷电影遗弃在借景之馆，被踏鞴砂众人捡回，和他们相处时产生了人类的情感。可惜时日不长，踏鞴砂等人被博士利用，让散兵感觉到了背叛，随后与他为伴的“折翼小鸟”也不幸去世。随后他便以“复仇”为生，直到成为伪神前后，也是被痛恨和迷茫驱动，让他只能以成神作为目标。和小吉祥草王的合作，让他得知了真相，感到无比痛苦后遂趁机进入世界树，希望能消除有关自己的一切。</p>
<p>“任何人都不能自己抹除自己的存在”，散兵成为了流浪者，作为流浪者的散兵如白纸般纯洁。与他相遇前不久，他还在“雨天中赶路”，借由那位帮助他的店主话说，即是“没有目的地和目标的人，何必在雨中赶路，只需静静等待雨水过去”。可见流浪者内心还延续着对过去和自我的追逐，却不自知。</p>
<p>随后借由小吉祥草王的力量，让散兵和流浪者成为一体，散兵机缘巧合下，完成了否定自我，重识自我，最终接受自我的转变。借此他能和“现在的过去”了断，背负了过去种种一切的恶，与小草神的合作中得以走向未来。</p>
<p>作为出力不少的旅行者，有幸给他起个新名字，思考许久他在哲学意义上的转变，作为雷神孩子的过去，作为草神新孩子的新生，同秘密主成神后的神性，种种形容都展示着他的过去和现在；而我却只想他能重新拾起孩童般的纯真。偶然间感觉，崩崩小圆帽这个可爱有趣的名字，没有过去的罪恶，没有曾作为神的力量，也不是作为流浪者的他，是一个与他的背负无关的名字。我希望以“崩崩小圆帽”为名，让他暂时忘却所有，在我的小小的原想中作为一个孩子新生。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>获取url网络资源</title>
    <url>/2023/03/28/%E5%AD%A6%E4%B9%A0/python/python%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E8%8E%B7%E5%8F%96url%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>本文简单概述，如何利用urllib包获取网络资源</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>urllib.request</strong>是用于获取URL的python模块，它以urlopen函数作为通用接口，能够处理各种协议的URL。还有较为复杂的一些接口，如基础身份认证、cookies、代理等。</p>
<p>Python 获取 Web 资源的能力是分层的。urllib 用到的是 http.client 库，而后者又用到了套接字库，即设置套接字的默认属性，会影响到urllib</p>
<p>本文简述常用场景的使用方法，详细具体内容参见 urllib.request 文档。</p>
<h1 id="构造HTTP请求"><a href="#构造HTTP请求" class="headerlink" title="构造HTTP请求"></a>构造HTTP请求</h1><h2 id="请求URL资源"><a href="#请求URL资源" class="headerlink" title="请求URL资源"></a>请求URL资源</h2><p>推荐的方法是构造一个 urllib.request.Request 保存待发送的请求实体，然后使用 urllib.request.urlopen 访问对应资源。使用这种方法有助于后续步骤中的的头管理吗，cookie携带，以及请求体构造</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request除了http协议地址，也可接受其他URL方案，如ftp</span></span><br><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.ice-cocoa.net&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">    the_page = response.read()</span><br><span class="line">    <span class="built_in">print</span>(the_page.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#打印可能需要decode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#按照需要，转储临时文件</span></span><br><span class="line">    <span class="keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>) <span class="keyword">as</span> tmp_file:</span><br><span class="line">        shutil.copyfileobj(response, tmp_file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(tmp_file.name) <span class="keyword">as</span> html:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>HTTP两种基本的请求方法GET和POST。使用 urllib 进行GET请求携带参数，是在url中拼接完成的；进行POST请求则是在构造urllib.request.Request时，额外指定一个参数</p>
<p><strong>构造GET请求并携带参数:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造GET参数</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;cocoa&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;school&#x27;</span>] = <span class="string">&#x27;nju&#x27;</span></span><br><span class="line"><span class="comment">#需要urlencode</span></span><br><span class="line">url_values = urllib.parse.urlencode(data)</span><br><span class="line">pure_url = <span class="string">&#x27;http://www.ice-cocoa.net&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把GET参数拼接到url</span></span><br><span class="line">url = pure_url + <span class="string">&#x27;?&#x27;</span> + url_values</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">    the_page = response.read()</span><br></pre></td></tr></table></figure>

<p><strong>构造POST请求并携带参数:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造http的body内容</span></span><br><span class="line">values = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;cocoa&#x27;</span>&#125;</span><br><span class="line">valuse[<span class="string">&#x27;passwd&#x27;</span>] = <span class="string">&#x27;234&#x27;</span></span><br><span class="line"><span class="comment"># 需要urlencode</span></span><br><span class="line">body = urllib.parse.urlencode(values)</span><br><span class="line"><span class="comment"># 需要注意encode，只有body需要</span></span><br><span class="line">body = body.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求时携带body</span></span><br><span class="line">url = <span class="string">&#x27;http://www.ice-cocoa.net/regester.cgi&#x27;</span></span><br><span class="line">req = urllib.request.Request(url, body)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">   the_page = response.read()</span><br></pre></td></tr></table></figure>

<h2 id="头部信息"><a href="#头部信息" class="headerlink" title="头部信息"></a>头部信息</h2><p>在urllib中构造头部信息更为简单一些，无需让字典经过 urllib.parse.urlencode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;&#125;</span><br><span class="line">body = urllib.parse.urlencode(data)</span><br><span class="line">body = body.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头部信息，实际传入时直接传入字典即可</span></span><br><span class="line">headers = &#123;&#125;</span><br><span class="line">headers[<span class="string">&#x27;User-agent&#x27;</span>] = <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&#x27;</span></span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.ice-cocoa.net&#x27;</span>, data, headers)</span><br><span class="line">req.add_header(<span class="string">&#x27;Referer&#x27;</span>, <span class="string">&#x27;http://www.python.org/&#x27;</span>)<span class="comment">#也可以这样添加</span></span><br></pre></td></tr></table></figure>

<h2 id="响应信息"><a href="#响应信息" class="headerlink" title="响应信息"></a>响应信息</h2><p>获取的响应有如 url、status、headers的属性。其中url属性返回获取页面的真实url，因为urlopen或opener可能经过了一次重定向</p>
<h1 id="构造opener"><a href="#构造opener" class="headerlink" title="构造opener"></a>构造opener</h1><p>urlopen是默认的opener，可以自定义opener来注册所需的handler链（即和发起请求有关的一系列处理函数），通常情况下可能常用的是代理的handler。从现在的使用状况来说，这个没必要深入。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="访问服务器失败URLError"><a href="#访问服务器失败URLError" class="headerlink" title="访问服务器失败URLError"></a>访问服务器失败URLError</h2><p>触发URLError的原因，可能是网络不通，也可能是路由器转发失败，总之是没有和服务器建立连接。触发URLError的异常实例带有一个reason属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.wrongserver.com&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>: urllib.request.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure>

<h2 id="服务器错误HTTPError"><a href="#服务器错误HTTPError" class="headerlink" title="服务器错误HTTPError"></a>服务器错误HTTPError</h2><p>从服务器返回的HTTP响应都有一个状态码，HTTP错误就是服务器返回的由它处理不了的错误，典型的有 404页面无法找到，403请求遭到拒绝，401需要身份认证。</p>
<p>HTTPError实例会包含一个code，对应服务器返回的状态码。注意，HTTPError是URLError的子类，当URL是HTTP类型时，且含有HTTP错误时候会触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.python.org/fish.html&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    urllib.request.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.code)</span><br><span class="line">    <span class="built_in">print</span>(e.read())</span><br></pre></td></tr></table></figure>

<h2 id="捕获HTTPError和URLError错误"><a href="#捕获HTTPError和URLError错误" class="headerlink" title="捕获HTTPError和URLError错误"></a>捕获HTTPError和URLError错误</h2><p>鉴于HTTPError继承自URLError，所以捕获错误时需要注意先后顺序，即HTTPError在前。文档中推荐的方法是，捕获URLError，然后按照是否有’code’和’reason’来判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request, urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line">req = Request(someurl)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urlopen(req)</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(e, <span class="string">&#x27;reason&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;We failed to reach a server.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Reason: &#x27;</span>, e.reason)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">hasattr</span>(e, <span class="string">&#x27;code&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;The server couldn\&#x27;t fulfill the request.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error code: &#x27;</span>, e.code)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># everything is fine</span></span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>python网络请求</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>处理失败用例</title>
    <url>/2023/03/28/%E5%AD%A6%E4%B9%A0/python/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6pytest/%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[<p>pytest处理失败用例</p>
<span id="more"></span>

<h1 id="指定第N次失败后停止执行测试"><a href="#指定第N次失败后停止执行测试" class="headerlink" title="指定第N次失败后停止执行测试"></a>指定第N次失败后停止执行测试</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pytest -x     <span class="comment">#第1次遇到失败即停止</span></span><br><span class="line">$ pytesst --maxfail=<span class="number">7</span> <span class="comment">#第7次遇到失败即停止</span></span><br></pre></td></tr></table></figure>

<h1 id="在pytest中使用pdb"><a href="#在pytest中使用pdb" class="headerlink" title="在pytest中使用pdb"></a>在pytest中使用pdb</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>测试框架pytest</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter远程测试</title>
    <url>/2023/03/16/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/jmeter/jmeter%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>使用jmeter远程测试，一定程度模拟分布式压测</p>
<span id="more"></span>

<h1 id="实际操作流程"><a href="#实际操作流程" class="headerlink" title="实际操作流程"></a>实际操作流程</h1><p>控制端，即master端：</p>
<ol>
<li>假设已经有jmeter相应的环境</li>
<li>客户端调整 bin 目录内相关配置。其调整内容包括：<ul>
<li>jmeter.properties文件内，remote_hosts属性添加服务器ip和调整后的非默认端口(默认无需设置)</li>
<li>ssl证书生成和保存，有效期7天</li>
</ul>
</li>
<li>分发经过调整的jmeter目录。其调整内容包括：<ul>
<li>新的ssl证书</li>
<li>如果脚本内需要导入文件，建议保存到jmeter目录下。如存放在根目录的文件，使用时的引用路径为 “..\1MB.jpg”</li>
</ul>
</li>
<li>等待服务端启用jmeter服务器组件</li>
<li>客户端在GUI和非GUI命令下执行分布式测试，GUI模式下不会断开连接无需重启服务器，更加方便</li>
</ol>
<p>服务器端，即slave端：</p>
<ol>
<li>确保有java环境，且和控制端版本一致</li>
<li>禁用虚拟网卡（注意，服务器会默认使用虚拟网卡的ip）</li>
<li>保证1099端口通畅，防火墙允许通过，一般都问题。除非设置自定义用于远程控制的端口</li>
<li>解压压缩包至任意目录</li>
<li>（windows环境下）点击解压后目录  \apache-jmeter-5.5\bin\jmeter-server.bat 以启用服务。第一次点击可能出现防火墙的提示，确认该提示。出现问题则再确认第3步</li>
<li>保持服务窗口打开即可。每次断开连接都需要重启服务器</li>
</ol>
<h1 id="JMeter远程测试性质"><a href="#JMeter远程测试性质" class="headerlink" title="JMeter远程测试性质"></a>JMeter远程测试性质</h1><p>JMeter不会在服务器之间分配负载，客户端（master）会向每个服务器（slave）发送测试文件，之后每个服务器会运行相同的完整测试计划。如果测试计划中设置了1000线程并设置了6个服务器，那么最终会执行6000个线程。</p>
<p>远程模式因管理服务器需要会造成一定的开销，尽量让服务器都处于统一网段，减少网络造成的影响。使用远程管理比较多的服务器可能造成过载，当前版本JMeter使用的StrippedBatch模式，能比较节省远程测试资源，但是仍应该确认客户端没有过载。</p>
<h1 id="具体配置流程"><a href="#具体配置流程" class="headerlink" title="具体配置流程"></a>具体配置流程</h1><h2 id="客户端添加服务器IP"><a href="#客户端添加服务器IP" class="headerlink" title="客户端添加服务器IP"></a>客户端添加服务器IP</h2><p>在客户端编辑 <sapn>&#x2F;bin&#x2F;jmeter.properties</span>，在 remote_hosts 属性处以逗号分割添加服务器IP。在GUI模式下 RUN - Remote Start 下可以观察到是否成功配置该ip，可以让远程机运行空的测试来测试是否层成功连接</p>
<h2 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h2><p>使用 <span> .&#x2F;create-rmi-keystore.sh </span> ，输入相关内容后生成一个匹配的密钥库，把文件 <span> bin&#x2F;rmi_keystore.jks </span> 复制到用于分布式测试的每个JMeter服务器和客户端（也都是这个路径）</p>
<p>生成密钥:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> jmeter/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./create-rmi-keystore.sh</span></span><br></pre></td></tr></table></figure>

<p>生成的密钥有效期为7天，默认密码为changeit。密钥生成的默认位置在<span> bin&#x2F;rmi_keystore.jks </span>，在这个位置jmeter即可引用。或者另外设置”server.rmi.ssl.keystore.file”引用它。按这个路径，把这个密钥文件复制到用于测试的每个Jmeter服务器和客户端</p>
<h2 id="命令行模式启动slave机"><a href="#命令行模式启动slave机" class="headerlink" title="命令行模式启动slave机"></a>命令行模式启动slave机</h2><p>使用以下命令在多个远程服务器上执行测试用例，要求服务器组件已经打开。：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment">#调用配置在 /bin/jmeter.properties 的 remote_hosts 所有服务器</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jmeter -n -t script.jmx -r</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment">#指定配置在服务器列表的部分服务器</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment">#额外指定 -X 参数可以让服务器在测试结束时退出</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jmeter -n -t script.jmx -R server1_ip,server2_ip -x</span></span><br></pre></td></tr></table></figure>
<p>命令行模式下明显的缺点是，只能通过“中断”信息来停止测试，此时本机会转储测试结果，但<strong>不会正常停止受控服务器</strong>。导致重新执行该命令，会得到服务器繁忙的报错。GUI模式下，则有”Remote Stop All”的命令，告知服务器停止测试，之后还可继续执行下一个测试</p>
<h2 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h2><p>涉及远程测试的端口有三类，相关配置在 jmeter.properties 文件中：</p>
<ul>
<li>使用标准RMI端口1099，完成客户端到服务器的控制。服务端定义受控端口的属性为server.rmi.port；客户端定义用来控制服务器的端口的属性为server_port</li>
<li>服务端向客户端回传数据，客户端使用高位随机端口接收。定义在  client.rmi.localport，这和</li>
<li>服务器本身工作时占用的端口，客户端本身工作的端口，动态分配无需关注</li>
</ul>
<p>用以RMI连接的端口如果要成功工作，需要满足：1)在服务端使用RMI端口启用了rmiregistry，这个会随着服务器启动自动启用；2)在服务端服务器本身正常工作在server_port定义的端口上（这个和RMI端口不是一个，一般是动态分配的）；3)在客户端，保证remote_hosts字段 host:port和服务器实际ip、RMI端口一致</p>
<h2 id="服务端开启服务组件"><a href="#服务端开启服务组件" class="headerlink" title="服务端开启服务组件"></a>服务端开启服务组件</h2><p>使用默认安装包里的内容，windows点击 <span>bin&#x2F;jmeter-server.bat</span> 即可启用服务器组件；unix系运行 <span>bin&#x2F;jmeter-server</span></p>
<h2 id="指定不同的发送模式"><a href="#指定不同的发送模式" class="headerlink" title="指定不同的发送模式"></a>指定不同的发送模式</h2><p>测试时服务器的监听器会把结果发送到客户端，客户端会转写到指定文件中。旧版本JMeter的默认是，样本会在生成时同步发送给客户端，且在结果发回前所在线程无法继续，这可能会影响服务器测试的最大吞吐量。以下是可以优化这种情况的模式，比较推荐的是 Stripped，它会移除成功采样的responseData，这并不会影响对它的评估。</p>
<p>自JMeter2.9版本以后，默认传输方法为 StrippedBatch，即移除了成功采样的responseData的同时，使用Batch方法，在达到在采样数量阈值num_sample_threshold、时间阈值time_threshold两者其一时，发送一次储存的采样，这可以在服务器端配置。</p>
<h2 id="节点失败处理策略"><a href="#节点失败处理策略" class="headerlink" title="节点失败处理策略"></a>节点失败处理策略</h2><p>相关配置有：</p>
<ul>
<li>client.tries</li>
<li>client.retries_delay</li>
<li>client.continue_on_fail</li>
</ul>
<p>这些配置都是用于初始化时节点失败的策略，没有涉及测试执行过程中节点失败的策略。根据实际策略来看，应该是会忽略测试执行过程中失败的节点，就当它没回送信息一样。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>测试工具</category>
        <category>jmeter</category>
      </categories>
  </entry>
  <entry>
    <title>pytest核心功能</title>
    <url>/2023/03/01/%E5%AD%A6%E4%B9%A0/python/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6pytest/pytest%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>记录pytest的核心功能</p>
<span id="more"></span>

<h1 id="激活pytest"><a href="#激活pytest" class="headerlink" title="激活pytest"></a>激活pytest</h1><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>。。。整理一下get started里的</p>
<h2 id="选择待运行的测试计划"><a href="#选择待运行的测试计划" class="headerlink" title="选择待运行的测试计划"></a>选择待运行的测试计划</h2><p>。。。整理一下get started里的</p>
<h2 id="获取测试执行时间"><a href="#获取测试执行时间" class="headerlink" title="获取测试执行时间"></a>获取测试执行时间</h2><p>以下代码可以获得一个列表，显示执行时间超过1.0s的最慢的10个测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pytest --durations=10 --durations-min=1.0</span><br></pre></td></tr></table></figure>

<p>默认的，pytest不会展示执行时间太短的测试用例，除非传递 -vv 参数</p>
<h2 id="管理插件的加载（省略）"><a href="#管理插件的加载（省略）" class="headerlink" title="管理插件的加载（省略）"></a>管理插件的加载（省略）</h2><h2 id="从python代码来执行测试用例"><a href="#从python代码来执行测试用例" class="headerlink" title="从python代码来执行测试用例"></a>从python代码来执行测试用例</h2><p>使用 pytest.main() 函数来执行测试用例，不会引发 SystemExit<br>，但是会返回退出码。因此它的返回值可以用来被传递给其他函数。这个pytest.main()可以携带一个参数列表，就像命令行里的pytest也需要携带参数一样；此外还可以携带一个插件列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pytest_sessionfinish</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*** test run reporting finishing&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sys.exit(pytest.main([<span class="string">&quot;-qq&quot;</span>], plugins=[MyPlugin()]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行这个py文件，会给出如下打印</span></span><br><span class="line"><span class="comment"># *** test run reporting finishing</span></span><br></pre></td></tr></table></figure>

<h1 id="在测试用例中撰写和报告断言"><a href="#在测试用例中撰写和报告断言" class="headerlink" title="在测试用例中撰写和报告断言"></a>在测试用例中撰写和报告断言</h1><h2 id="使用assert语句断言"><a href="#使用assert语句断言" class="headerlink" title="使用assert语句断言"></a>使用assert语句断言</h2><p>pytest允许使用标准python断言语句，即assert来验证测试用例中的期望值。pytest支持常见的子表达式，包括调用、属性、比较、二进制、一元运算，如果尝试在一个assert尝试断言两个子表达式（即用逗号隔开的两个表达式），那么不会给出断言回复</p>
<p>断言失败时，控制台会打印失败的用例，以及失败断言的上下文内容，以下是一个小小的片段:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  assert f() == 4</span></span><br><span class="line">E   assert 3 == 4</span><br><span class="line">E   +   where 3 = f()</span><br><span class="line"></span><br><span class="line">test_assert1.py:6: AssertionError</span><br></pre></td></tr></table></figure>

<h2 id="断言预期的异常《待补充》"><a href="#断言预期的异常《待补充》" class="headerlink" title="断言预期的异常《待补充》"></a>断言预期的异常《待补充》</h2><h2 id="自定义操作符的报错细节"><a href="#自定义操作符的报错细节" class="headerlink" title="自定义操作符的报错细节"></a>自定义操作符的报错细节</h2><p>实现钩子函数 pytest_assertrepr_compare 能够重写的比较类型断言的报错细节。这个钩子函数的定义是这样的：</p>
<p><span><b>pytest_assertrepr_compare(<i>config, op, left, right</i>)</b></span></p>
<ul>
<li>config(Config)– pytest的config实例。从示例来看可以省略</li>
<li>op(str)– 如”&#x3D;&#x3D;”,”!&#x3D;”，”not in “</li>
<li>left(object)– 操作符左侧的对象</li>
<li>right(object)– 操作符右侧对象</li>
</ul>
<p>返回值是自定义的报错细节，其格式是一个字符串列表，每个元素对应一行报错。一般默认第一行作为摘要，因此后续行会自行缩进两格。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pytest_assertrepr_compare</span>(<span class="params">op, left, right</span>):</span><br><span class="line">    <span class="comment"># 在断言报错情况下，如果操作符为 == ，且两侧操作符为Foo类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(left, Foo) <span class="keyword">and</span> <span class="built_in">isinstance</span>(right, Foo) <span class="keyword">and</span> op == <span class="string">&quot;==&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&quot;Comparing Foo instances:&quot;</span>, <span class="comment">#作为摘要</span></span><br><span class="line">            <span class="string">f&quot;   vals: <span class="subst">&#123;left.val&#125;</span> != <span class="subst">&#123;right.val&#125;</span>&quot;</span>,  <span class="comment">#下一行报错内容</span></span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<h2 id="其他设置补充《》"><a href="#其他设置补充《》" class="headerlink" title="其他设置补充《》"></a>其他设置补充《》</h2><h1 id="使用fixtures"><a href="#使用fixtures" class="headerlink" title="使用fixtures"></a>使用fixtures</h1><h2 id="fixtures简化构造实例的语句"><a href="#fixtures简化构造实例的语句" class="headerlink" title="fixtures简化构造实例的语句"></a>fixtures简化构造实例的语句</h2><p>fixtures标注如和使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@python.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">entry_apple</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;apple&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@python.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orderOne</span>(<span class="params">entry_apple</span>):</span><br><span class="line">    <span class="keyword">return</span> [entry_apple]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_string</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="comment">#行为</span></span><br><span class="line">    order.append(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#断言</span></span><br><span class="line">    <span class="keyword">assert</span> order == [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;banana&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>可见，无需“创建过程”就可以使用fixture标注函数的返回值，极大省略了的构造语句。这也有助于测试文件减少维护脚本类代码的内容。</p>
<h2 id="指定范围内共享fixtures"><a href="#指定范围内共享fixtures" class="headerlink" title="指定范围内共享fixtures"></a>指定范围内共享fixtures</h2><p>上一节可见，在测试函数中的参数使用标注 python.fixture 的函数，就像获取了一个仅在测试环境内有效的局部变量。除此之外，还可以让受标注的函数的返回值在一个范围内共享，即函数主体只执行一次且每次受到调用都返回同一个实例。实现这个共享的方式是，标注 <span>python.fixture(scope&#x3D;”class”)</span> ，其中scope的值可以是 function（默认缺省值）、class、module、package、session。把范围指定成 session 即可让本次测试的所有测试用例使用它，它指定“本次测试”这个范围。scope可以动态设置，但这里不关注</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conftest.py</span></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;module&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smtp_connection</span>():</span><br><span class="line">    <span class="keyword">return</span> smtplib.SMTP(<span class="string">&quot;smtp.gmail.com&quot;</span>, <span class="number">587</span>, timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_module.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_ehlo</span>(<span class="params">smtp_connection</span>):</span><br><span class="line">    response, msg = smtp_connection.ehlo()</span><br><span class="line">    <span class="keyword">assert</span> response == <span class="number">250</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">b&quot;smtp.gmail.com&quot;</span> <span class="keyword">in</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_noop</span>(<span class="params">smtp_connection</span>):</span><br><span class="line">    response, msg = smtp_connection.noop()</span><br><span class="line">    <span class="keyword">assert</span> response == <span class="number">250</span></span><br></pre></td></tr></table></figure>


<h2 id="测试用例的清除工作（过时）"><a href="#测试用例的清除工作（过时）" class="headerlink" title="测试用例的清除工作（过时）"></a>测试用例的清除工作（过时）</h2><p><del>推荐的方法是<strong>Yield</strong> fixtures。这个方法中 yield 会用来替代 return，然后清理语句可以出现在yield后面。另一种方法是手动添加最终处理器finalizers，这个就不记录了</del></p>
<p><del>Yield实现清理效果的原理是这样的，pytest先整理一个“线性的fixtures调用流程”，分别对每个fixture计算返回值；当测试结束时pytest会逆序访问那个“线性的fixtures调用流程”（像出栈一样），执行其中在yield后面的代码。</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#仅演示yield，yield已将会在python4.0弃用！</span></span><br><span class="line"><span class="comment">#仅演示yield，yield已将会在python4.0弃用！</span></span><br><span class="line"><span class="comment">#仅演示yield，yield已将会在python4.0弃用！</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiving_user</span>(<span class="params">mail_admin</span>):</span><br><span class="line">    user = mail_admin.create_user()</span><br><span class="line">    <span class="keyword">yield</span> user</span><br><span class="line">    <span class="comment">#下面是清理工作</span></span><br><span class="line">    user.clear_mailbox()</span><br><span class="line">    mail_admin.delete_user(user)</span><br></pre></td></tr></table></figure>

<p><b><span>Yield会在python4.0弃用，但是在最新版的官方文档上这仍然是推荐用法，有点奇怪。现在要考虑改用的终结器方法，还是说有其他新的推荐方法</span></b></p>
<h2 id="在测试上下文使用request内省-不太懂，应该用不到"><a href="#在测试上下文使用request内省-不太懂，应该用不到" class="headerlink" title="在测试上下文使用request内省(不太懂，应该用不到)"></a>在测试上下文使用request内省(不太懂，应该用不到)</h2><p>fixtures标注的函数，如标注 @pytest.fixture(scope&#x3D;”module”) ，可以接受一个 FixtureRequest类型实例request去内省测试环境的上下文。这个request是一个特殊的fixture，能够提供测试函数的信息</p>
<p>一个<a href="https://docs.pytest.org/en/stable/reference/reference.html#pytest.FixtureRequest">request</a>的常用属性有下面几个，它们都可以在测试函数中<strong>直接使用</strong>：</p>
<ul>
<li>request.scope fixture的共享范围</li>
<li>request.moudle 测试函数所在的Python模块对象</li>
<li>request.path 测试函数所在的路径</li>
<li>request.node 底层的集合节点</li>
<li>request.param 设置params时，使用request.para会迭代使用其中元素</li>
<li>其他等等</li>
</ul>
<p>有点问题，回看<a href="https://docs.pytest.org/en/stable/how-to/fixtures.html#fixtures-can-introspect-the-requesting-test-context">文档</a></p>
<h2 id="使用markers传递数据给fixtures（未记录）"><a href="#使用markers传递数据给fixtures（未记录）" class="headerlink" title="使用markers传递数据给fixtures（未记录）"></a>使用markers传递数据给fixtures（未记录）</h2><h2 id="使用fixtures参数列表迭代测试"><a href="#使用fixtures参数列表迭代测试" class="headerlink" title="使用fixtures参数列表迭代测试"></a>使用fixtures参数列表迭代测试</h2><p>设置 params 多个参数时，测试函数会以迭代方式调用 request.param，每次调用都会完全执行一次测试函数，而测试函数本身并不会到这件事。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># content of conftest.py</span></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;module&quot;</span>, params=[<span class="string">&quot;smtp.gmail.com&quot;</span>, <span class="string">&quot;mail.python.org&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smtp_connection</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment">#自动进行两次迭代</span></span><br><span class="line">    <span class="comment">#第一次迭代中 request.param为&quot;smtp.&quot;</span></span><br><span class="line">    <span class="comment">#第二次迭代为 request.para为&quot;mail.python.org&quot;</span></span><br><span class="line">    smtp_connection = smtplib.SMTP(request.param, <span class="number">587</span>, timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">yield</span> smtp_connection</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finalizing <span class="subst">&#123;smtp_connection&#125;</span>&quot;</span>)</span><br><span class="line">    smtp_connection.close()</span><br></pre></td></tr></table></figure>


<h2 id="其他等等，需要多次回顾，以后再完善"><a href="#其他等等，需要多次回顾，以后再完善" class="headerlink" title="其他等等，需要多次回顾，以后再完善"></a>其他等等，需要多次回顾，以后再完善</h2><h1 id="使用属性来标记测试函数"><a href="#使用属性来标记测试函数" class="headerlink" title="使用属性来标记测试函数"></a>使用属性来标记测试函数</h1><p>注册标记，可以在 pytest.ini 文件里这样修改。自定义标记可以用于插件，也经常用来再命令行中使用-m参数，选择测试用例。下面的代码中，冒号后面的内容是可选的描述文本：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[pytest]</span></span><br><span class="line"><span class="attr">markers</span> =</span><br><span class="line">    slow: marks tests as slow (deselect with &#x27;-m &quot;not slow&quot;&#x27;)</span><br><span class="line">    serial</span><br></pre></td></tr></table></figure>

<p>内置的标记有：</p>
<ul>
<li>usefixtures</li>
<li>filterwarnings</li>
<li>skip</li>
<li>skipif</li>
<li>xfail</li>
<li>parametrize</li>
</ul>
<h1 id="标记生成用以测试的参数"><a href="#标记生成用以测试的参数" class="headerlink" title="标记生成用以测试的参数"></a>标记生成用以测试的参数</h1><p>使用标记 @pytest.mark.parametrize() 可以定义一个全局的标记，或者是一个属于测试函数的标记。对于测试函数而言，就像正常使用一个外部的变量</p>
<p>标记范围是一个测试函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;n,expected&quot;</span>, [(<span class="params"><span class="number">1</span>, <span class="number">2</span></span>), (<span class="params"><span class="number">3</span>, <span class="number">4</span></span>)]</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_simple_case</span>(<span class="params">self, n, expected</span>):</span><br><span class="line">        <span class="keyword">assert</span> n + <span class="number">1</span> == expected</span><br></pre></td></tr></table></figure>

<p>标记范围是全局：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytestmark = pytest.mark.parametrize(<span class="string">&quot;n,expected&quot;</span>, [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#之后再测试函数中就可以像外部的变量一样，直接使用它们</span></span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>测试框架pytest</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>实践笔记</title>
    <url>/2023/02/23/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/jmeter/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录实际使用过程的细节和容易错误的地方，备忘一下。主要是http接口的相关调用</p>
<span id="more"></span>
<h1 id="重要组件概述"><a href="#重要组件概述" class="headerlink" title="重要组件概述"></a>重要组件概述</h1><h2 id="HTTP头管理"><a href="#HTTP头管理" class="headerlink" title="HTTP头管理"></a>HTTP头管理</h2><p>jmeter中用以管理http头部的是<strong>HTTP Header Manager</strong>，此外还有专门用以设置用户自定义cookie的<strong>HTTP Cookie Manager</strong></p>
<p>在请求携带cookie方面，两个头部管理器是可以通用的。需要注意cookie管理器设置的是用户的cookie，为了http请求采样器携带cookie，需要在Domain处指定域名，也可以在Path处额外指定路径，这样在请求这个域名的这个路径时会自动携带这个cookie。如果在header管理器中设置，则会让给在它控制范围内的所有http采样器携带这个头部。头部信息应用的优先级规则是，内部的优先级大于外部的</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>计数器Counter应用于循环控制器或线程组，可以实现迭代变量的效果。计数器可指定初始值、增加值、最大值（超过这个就再从初始值开始计算）、简单数字格式。计数器每经历一次循环或线程，都会根据增加值自动增加一次。其中的数字格式，比如设置 0000 ，则会取四位数字，如值是7时导出为 0007 。 最后设置导出变量名，这样在外部使用时即可用形式为 ${xxx} 的形式使用这个变量，其中xxx是设置的导出变量名</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>在这次使用过程中，遇到的设置变量名的地方，有User Defined Variables配置器，和各类响应的提取器（常用的是JSON Extractor）。在这两个地方设置的变量，可以使用 ${x} 来使用变量x。也使用可以内嵌变量的变量名，不过这需要Var函数的辅助 ${_V(x${i})} ，当i为3时，使用变量 x3</p>
<p>注意，被导出的变量名是不可以使用变量的，即不可以设置 UserName${i}，其中i为计数器变量。如果需要设置根据迭代数量变化的变量名，如 userName001~userName099，往往可以转换为给每个采样器设置userName这个变量名。</p>
<p>某些特殊需要的，或者动态变化的更加灵活的变量，需要使用 bean shell，这是一个内嵌的java脚本，配合使用 vars.get(“varName”) 获取已在环境中存在的变量，vars.put(“extractedVarName”,x) 设置环境中的变量</p>
<p>目前发现参数的值无需使用任何转义，如路径变量的值被赋予 D:\ceshi\ceshi.png 即可</p>
<h2 id="HTTP采样器"><a href="#HTTP采样器" class="headerlink" title="HTTP采样器"></a>HTTP采样器</h2><p>此次使用工程中的HTTP采样器，不外乎GET方法和POST方法。此外对于具体应用，POST方法还有三种本质相同但形式不同的参数设置方式，包括类GET参数携带，典型body参数携带，内容格式为multipart/form-data</p>
<p><strong>类GET参数携带</strong>是指，在采样器的Parameters里设置参数，形式上和GET方法一样，不过实际发送请求的时候JMeter会把参数拼接到body里。如设置 Name为a，Value为1；Name为b，Value为2；这个等效于body里的 a&#x3D;1&amp;b&#x3D;2。</p>
<p><strong>典型body参数携带</strong>，是POST的典型参数携带方式，存放在body里的可以是参数也可以是json数据，这取决于后端怎么解析</p>
<p><strong>内容格式为 multipart/form-data</strong>，它的本质和post并无区别。使用这种形式的，要在http信息头里添加 boundry&#x3D;(一串随机值，可由浏览器生成) ，之后body里各段内容用boundry的值分割。在JMeter里使用需要注意，只需要勾选 “multipart/form-data” 选项，不要额外在信息头里添加 boundry，一个参数，一个文件就是单独分配一个被boundry包围的区域，如上传文件里这么设置：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">File Path:      D:\测试图片\test.png</span><br><span class="line">Parameter Name: file</span><br><span class="line">MINE Type:      image/png</span><br></pre></td></tr></table></figure>
<p>它构造的对应的请求内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">--LsKyeoosX-9sE6LSfwDLPKuqkK6O-3o</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"></span><br><span class="line">&lt;actual file content, not shown here&gt;</span><br><span class="line">--LsKyeoosX-9sE6LSfwDLPKuqkK6O-3o--</span><br></pre></td></tr></table></figure>

<h1 id="测试计划分割"><a href="#测试计划分割" class="headerlink" title="测试计划分割"></a>测试计划分割</h1><h2 id="一般参数配置"><a href="#一般参数配置" class="headerlink" title="一般参数配置"></a>一般参数配置</h2><p>一般参数配置位于测试计划的下一级(放在这个位置出于个人喜好)，使用User Defined Variables 存储通用的默认配置的参数。对于配置好的变量，只需要使用${var} 形式的语法即可引用，其中var是定义的变量名。但要注意，定义变量名时，变量名本身不可以用变量</p>
<p>通用参数配置包含：</p>
<ol>
<li>申请人所需参数、配偶所需参数、孩子所需参数。这几个作为save请求里的body的参数</li>
<li>通用配置参数，包括：需要cookie携带的参数，主要是身份认证；在请求默认设置HTTP Request Defaults中设置的域名、协议和端口；待上传图片在本机的路径</li>
<li>材料代码，用于upload接口在绑定用户id、材料类型、服务器内材料id时，提供材料类型的代码</li>
</ol>
<h2 id="线程组内设置监听器"><a href="#线程组内设置监听器" class="headerlink" title="线程组内设置监听器"></a>线程组内设置监听器</h2><p>设置了View Result Tree 和 View Result in Table。第一个View Result Tree详细记录每个http采样的请求和响应内容，非常方便检查和调试。View Result in Table调试是一般用不到，放在这里仅是为了另存一种形式的记录</p>
<p>这个测试计划实际无需进行性能和压力的测试。在正式执行性能或压力测试时，还需添加聚合报告 Aggregate Report；调试结束后再使用命令行界面，进行更加准确的非图形界面的测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment">#要求进入jmeter的bin目录，或jmeter已设置了jmeter.sh的系统变量</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</span></span><br></pre></td></tr></table></figure>

<h2 id="HTTP采样器默认设置"><a href="#HTTP采样器默认设置" class="headerlink" title="HTTP采样器默认设置"></a>HTTP采样器默认设置</h2><p>使用HTTP Request Defaults可设置受它控制的HTTP采样器的各项默认值，常见的设置是默认协议（http还是https）、默认域名、默认端口、默认编码。这样受它控制的采样器无需重新指定这些内容，如果采样器指定了则会重写覆盖默认值</p>
<h2 id="Cookie管理器"><a href="#Cookie管理器" class="headerlink" title="Cookie管理器"></a>Cookie管理器</h2><p>这里的cookie是定义给用户的，如果要让具体的采样器携带，必须要指定域名，指定路径会限制cookie的生效路径。这里主要使用的cookie是用于识别会话的，或身份认证的</p>
<h2 id="执行主体"><a href="#执行主体" class="headerlink" title="执行主体"></a>执行主体</h2><h3 id="执行控制的基本设置"><a href="#执行控制的基本设置" class="headerlink" title="执行控制的基本设置"></a>执行控制的基本设置</h3><p>执行主体使用了一个循环控制器，是因为此次计划没有并发需求，仅要求反复多次，那么循环控制器可以简化线程设置。如果又要求并发，那么也不会影响线程组的设置</p>
<p>执行主体内还有其他基本设置，是一个可以记录循环次数的计数器，和一个用于伪造参数的变量设置器。这个设置器必须和下方的BeanShell组合使用，才会起到用伪造参数替换默认值的效果。比如把身份证a替换为”ceshi0001”，其中的前缀”ceshi”是在这里设置的，”0001”是计数器的值，把两者组合并覆盖默认值是在BeanShell中实现的</p>
<p>执行主体内的采样，按照测试所需，分为四个阶段：保存、上传材料、提交、审核。按照经验，这个过程在很多申请资格的地方是通用的</p>
<h3 id="保存save"><a href="#保存save" class="headerlink" title="保存save"></a>保存save</h3><p>save这个简单控制器的下一级，仅有一个HTTP采样器，采样器则有专门的HTTP头管理器、BeanShell预处理器、JSON提取器。</p>
<p><strong>HTTP采样器</strong>除去使用“HTTP采样器默认设置”以外，额外指定了POST方法和具体请求路径，然后就是一个body的模板，里面各类值都使用形如 ${name} 这样的变量</p>
<p><strong>HTTP头管理器</strong>中，除了必要的有关认证或定位的一些信息，其余一些不是必须的，后端大多早已决定好了这个请求的处理方式。不过基本的Content-Type、Accept-Encoding等设置一下会更加稳妥</p>
<p><strong>BeanShell预处理器</strong>里代码的功能，则是在每次进行HTTP采样前，编造信息替代原有变量，这样无需改变在采样器和其他地方的变量名了。这里使用的核心函数是 获取变量vars.get() 和 导出变量vars.put() ，这两个函数无需导入包即可使用。如果禁用这个，则会使用在默认通用参数里的参数</p>
<p><strong>JSON提取器</strong>用于提取用户id，因为在审核用户（review接口）时需要使用用户id作为参数，所以需要提前提取</p>
<h3 id="上传材料upload"><a href="#上传材料upload" class="headerlink" title="上传材料upload"></a>上传材料upload</h3><p>upload下一级仅有一个循环控制器，循环控制器内设一个计数器，用于迭代材料代码。材料代码已经事先存储在通用变量中了，材料代码的变量名分别为 materialCode01~materialCode06，故需要循环六次。具体执行材料上传需要分两步走:第一步是上传到服务器，服务器返回材料id；第二部是发送请求把这个材料和用户绑定。所以每次循环里有两个采样器</p>
<p>第一步实现了材料上传到服务器，在响应中提取文件id。这里的HTTP采样器，使用 multipart/form-data 格式。在jmeter中则仅需要勾选 multipart/form-data 选项，然后在 Files Upload 中添加文件信息作为一个参数，下面是添加在其中的信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">File Path:      D:\测试图片\test.png</span><br><span class="line">Parameter Name: file</span><br><span class="line">MINE Type:      image/png</span><br></pre></td></tr></table></figure>
<p>JMeter会自动在Content-Type处指定 multipart&#x2F;form-data; boundary&#x3D;LsKyeoosX-9sE6LSfwDLPKuqkK6O-3o，因此无需也不能再额外添加Content-Type。它构造的对应的请求内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">--LsKyeoosX-9sE6LSfwDLPKuqkK6O-3o</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"></span><br><span class="line">&lt;actual file content, not shown here&gt;</span><br><span class="line">--LsKyeoosX-9sE6LSfwDLPKuqkK6O-3o--</span><br></pre></td></tr></table></figure>
<p>然后再用JSON提取器，提取id。JSON路径表达式可以是 data[&quot;id&quot;]，匹配序号为1，默认值为0，导出变量这里用了materialId，在下一步绑定材料时可以用 <sapn>${materialId} </sapn>来使用它</p>
<p>第二步是绑定材料，这里的请求负载用json格式构造：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;fileId&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;materialId&#125;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;materialCode&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;__V(materialCode0$&#123;i&#125;)&#125;&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中的fileId的值来自上一步的JSON提取器，materailCode的值由于使用到了内嵌变量，故要使用函数 __V()，注意，这里有两个下划线。这里进行两次解析，第一次解析计数器i，假设这里i为1，那么得到 <span>${__V(materialCode01)}</span>，再次解析就能获得这个材料的代码</p>
<h3 id="提交submit"><a href="#提交submit" class="headerlink" title="提交submit"></a>提交submit</h3><p>提交这里比较简单，无需携带参数，用于判别的申请人的信息存放在信息头</p>
<h3 id="审核review"><a href="#审核review" class="headerlink" title="审核review"></a>审核review</h3><p>审核这里使用POST方法携带两个类GET格式的参数，参数id取自保存步骤中，在响应里提取到的用户id；参数qualificationStatus则用于判别是否审核通过</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>测试工具</category>
        <category>jmeter</category>
      </categories>
  </entry>
  <entry>
    <title>pytest准备</title>
    <url>/2023/02/16/%E5%AD%A6%E4%B9%A0/python/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6pytest/pytest%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>pytest的安装和基本了解</p>
<span id="more"></span>

<h1 id="安装pytest"><a href="#安装pytest" class="headerlink" title="安装pytest"></a>安装pytest</h1><p>安装或更新pytest并检查版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install -U pytest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest --version</span></span><br></pre></td></tr></table></figure>

<h1 id="激活测试用例"><a href="#激活测试用例" class="headerlink" title="激活测试用例"></a>激活测试用例</h1><h2 id="指明测试对象"><a href="#指明测试对象" class="headerlink" title="指明测试对象"></a>指明测试对象</h2><p>pytest命令适用于文件名形式为 test_*.py 或 *_test.py 的文件，执行这些文件下的测试用例。测试用例以函数方式组织，通常都位于一个测试类下，其函数名形式为 test_*.py</p>
<p>下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 位于 test_sample.py 文件内</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_one</span>(<span class="params">self</span>):</span><br><span class="line">        x=<span class="string">&quot;this&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;h&quot;</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> func(<span class="number">3</span>)==<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>下面是执行测试用例的具体命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest                                        <span class="comment">#执行当前目录及子目录所有测试文件的测试用例</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest  testing/                              <span class="comment">#执行testing目录及子目录所有测试文件的测试用例</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest -k TestClass                           <span class="comment">#执行这个测试类下所有的测试用例，-k指定关键字，这里直接用一个类名作为关键字</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest test_sample.py                         <span class="comment">#仅执行test_sample.py这个文件下的所有测试用例</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest test_sample.py::TestClass::test_func   <span class="comment">#仅执行这个文件下的这个测试类里的测试用例</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pytest --pyargs pkg.testing                   <span class="comment">#执行这个包里的测试用例</span></span></span><br></pre></td></tr></table></figure>
<p>参数-q启用安静模式，使输出示例保持简短。此外还可以给测试用例标注，对标注slow的测试用例，可以用 “pytest -m slow”</p>
<h2 id="获得版本、选项、环境变量的帮助"><a href="#获得版本、选项、环境变量的帮助" class="headerlink" title="获得版本、选项、环境变量的帮助"></a>获得版本、选项、环境变量的帮助</h2><p>有如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pytest --version    </span><br><span class="line">pytest --fixures    #展示</span><br><span class="line">pytest -h | --help</span><br></pre></td></tr></table></figure>



<h1 id="创建测试用例"><a href="#创建测试用例" class="headerlink" title="创建测试用例"></a>创建测试用例</h1><h2 id="raise-helper"><a href="#raise-helper" class="headerlink" title="raise helper"></a>raise helper</h2><p>使用 raise helper 可以断言某些代码是否引发一个异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_mytest</span>():</span><br><span class="line">    <span class="comment">#断言f是否引发了一个异常</span></span><br><span class="line">    <span class="keyword">with</span> pytest.raises(SystemExit):</span><br><span class="line">        f()</span><br></pre></td></tr></table></figure>

<p>还不是太明白，试一试去</p>
<h2 id="请求pytest内置装置-builtin-fixture"><a href="#请求pytest内置装置-builtin-fixture" class="headerlink" title="请求pytest内置装置(builtin fixture)"></a>请求pytest内置装置(builtin fixture)</h2><p>pytest提供了内置变量来提供对各种资源的访问，用户也可以用 @pytest.fixture 标记自定义这样的装置，根据装置定义的位置不同（用例内、类内、全局）生效的范围也不同</p>
<p>pytest提供的内置装置可以参考这个<a href="https://docs.pytest.org/en/stable/reference/fixtures.html#fixtures">文档</a>。此外，运行命令 “pytest –fixures” 可以查看内置的和自定义的装置</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>测试框架pytest</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python模块和包</title>
    <url>/2023/02/15/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    <content><![CDATA[<p>模块的创建和导入；包的基本理解</p>
<span id="more"></span>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 .py ，在模块内部，通过全局变量 <strong>name</strong> 可以获取模块名字符串</p>
<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>模块包含可执行语句以及函数定义，仅会在 import语句第一次遇到时执行，除非某个模块作为脚本运行。例如在当前目录下创建 fibo.py 文件，编辑好内容后，可以进入python解释器用以下命令导入该模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>

<p>import 的几个使用方法:</p>
<ul>
<li>导入一整个模块(相当于执行一次模块文件)，如 import fibo</li>
<li>导入模块中的几个，或满足条件的函数，如 from fibo import fib1， fibo2</li>
<li>导入模块或函数，并用as名称绑定，如 from fibo import fib1 as fibonacci</li>
</ul>
<h2 id="以脚本方式执行模块"><a href="#以脚本方式执行模块" class="headerlink" title="以脚本方式执行模块"></a>以脚本方式执行模块</h2><p>命令行里输入 python fibo.py <arguments>  可以运行python模块，这项操作会执行模块里的代码，还会把 <strong>name</strong> 赋值为 “<strong>main</strong>“ </p>
<p>为了区别出专门用来执行脚本的部分，应该在模块末尾添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    fib(<span class="built_in">int</span>(sys.argv[<span class="number">1</span>])) <span class="comment"># 如果调用掉本，就以这种参数调用方式执行函数   </span></span><br></pre></td></tr></table></figure>

<p>以下是在bash中调用的脚本的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python fibo.py <span class="number">50</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>

<h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>按照以下优先级搜索模块:</p>
<ol>
<li>解释器首先搜索具有该名称的内置模块，它们的名字列在 sys.builtin_module_names 中</li>
<li>在变量 sys.path 给出的目录列表中搜索这个模块文件(模块名.py)； sys.path 从这些位置初始化:<ul>
<li>当前目录  (它的搜索位置在标准库之前)</li>
<li>PYTHONPATH</li>
<li>依赖于安装的默认值(包括一个 site-packages 目录，由 site 模块处理)</li>
</ul>
</li>
</ol>
<p>初始化后python程序可以更改 sys.path ,如 sys.path.append(‘&#x2F;ufs&#x2F;guido&#x2F;lib&#x2F;python’)</p>
<h2 id="“已编译的”py文件"><a href="#“已编译的”py文件" class="headerlink" title="“已编译的”py文件"></a>“已编译的”py文件</h2><p>为了快速加载模块，Python 把模块的编译版缓存在 <strong>pycache</strong> 目录中，文件名为 module.version.pyc，version 对编译文件格式进行编码，一般是 Python 的版本号。这种方法可以让不同python版本的已编译模块共存</p>
<p>例如，CPython 的 3.3 发行版中，spam.py 的编译版本缓存为 <strong>pycache</strong>&#x2F;spam.cpython-33.pyc</p>
<h2 id="dir函数查找模块定义的名称"><a href="#dir函数查找模块定义的名称" class="headerlink" title="dir函数查找模块定义的名称"></a>dir函数查找模块定义的名称</h2><p>内置函数 dir 用于查找模块定义的名称(模块名、函数名、变量名):</p>
<ul>
<li>dir()         没有参数时，列出当前(代码执行到此处)定义的名称</li>
<li>dir(fibo)     查找fibo模块内定义的名称</li>
<li>dir(builtins) 内置函数和变量的名称定义在标准模块 builtins</li>
</ul>
<p>dir空参数，列出当前定义的名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fibo&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>dir指定模块名，列出这个模块定义的名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys, builtins</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(fibo)</span><br><span class="line">[<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fib2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(sys)  </span><br><span class="line">[<span class="string">&#x27;__breakpointhook__&#x27;</span>, <span class="string">&#x27;__displayhook__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__excepthook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__interactivehook__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__stderr__&#x27;</span>, <span class="string">&#x27;__stdin__&#x27;</span>, <span class="string">&#x27;__stdout__&#x27;</span>, <span class="string">&#x27;__unraisablehook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_clear_type_cache&#x27;</span>, <span class="string">&#x27;_current_frames&#x27;</span>, <span class="string">&#x27;_debugmallocstats&#x27;</span>, <span class="string">&#x27;_framework&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_getframe&#x27;</span>, <span class="string">&#x27;_git&#x27;</span>, <span class="string">&#x27;_home&#x27;</span>, <span class="string">&#x27;_xoptions&#x27;</span>, <span class="string">&#x27;abiflags&#x27;</span>, <span class="string">&#x27;addaudithook&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;api_version&#x27;</span>, <span class="string">&#x27;argv&#x27;</span>, <span class="string">&#x27;audit&#x27;</span>, <span class="string">&#x27;base_exec_prefix&#x27;</span>, <span class="string">&#x27;base_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;breakpointhook&#x27;</span>, <span class="string">&#x27;builtin_module_names&#x27;</span>, <span class="string">&#x27;byteorder&#x27;</span>, <span class="string">&#x27;call_tracing&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callstats&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;displayhook&#x27;</span>, <span class="string">&#x27;dont_write_bytecode&#x27;</span>, <span class="string">&#x27;exc_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;excepthook&#x27;</span>, <span class="string">&#x27;exec_prefix&#x27;</span>, <span class="string">&#x27;executable&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>, <span class="string">&#x27;float_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;float_repr_style&#x27;</span>, <span class="string">&#x27;get_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;get_coroutine_origin_tracking_depth&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getallocatedblocks&#x27;</span>, <span class="string">&#x27;getdefaultencoding&#x27;</span>, <span class="string">&#x27;getdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getfilesystemencodeerrors&#x27;</span>, <span class="string">&#x27;getfilesystemencoding&#x27;</span>, <span class="string">&#x27;getprofile&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getrecursionlimit&#x27;</span>, <span class="string">&#x27;getrefcount&#x27;</span>, <span class="string">&#x27;getsizeof&#x27;</span>, <span class="string">&#x27;getswitchinterval&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gettrace&#x27;</span>, <span class="string">&#x27;hash_info&#x27;</span>, <span class="string">&#x27;hexversion&#x27;</span>, <span class="string">&#x27;implementation&#x27;</span>, <span class="string">&#x27;int_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;intern&#x27;</span>, <span class="string">&#x27;is_finalizing&#x27;</span>, <span class="string">&#x27;last_traceback&#x27;</span>, <span class="string">&#x27;last_type&#x27;</span>, <span class="string">&#x27;last_value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;maxsize&#x27;</span>, <span class="string">&#x27;maxunicode&#x27;</span>, <span class="string">&#x27;meta_path&#x27;</span>, <span class="string">&#x27;modules&#x27;</span>, <span class="string">&#x27;path&#x27;</span>, <span class="string">&#x27;path_hooks&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;path_importer_cache&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;prefix&#x27;</span>, <span class="string">&#x27;ps1&#x27;</span>, <span class="string">&#x27;ps2&#x27;</span>, <span class="string">&#x27;pycache_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;set_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;set_coroutine_origin_tracking_depth&#x27;</span>, <span class="string">&#x27;setdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;setprofile&#x27;</span>, <span class="string">&#x27;setrecursionlimit&#x27;</span>, <span class="string">&#x27;setswitchinterval&#x27;</span>, <span class="string">&#x27;settrace&#x27;</span>, <span class="string">&#x27;stderr&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;stdin&#x27;</span>, <span class="string">&#x27;stdout&#x27;</span>, <span class="string">&#x27;thread_info&#x27;</span>, <span class="string">&#x27;unraisablehook&#x27;</span>, <span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;version_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;warnoptions&#x27;</span>]</span><br><span class="line"> &gt;&gt;&gt; <span class="built_in">dir</span>(builtins)  </span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>, <span class="string">&#x27;AssertionError&#x27;</span>, <span class="string">&#x27;AttributeError&#x27;</span>, <span class="string">&#x27;BaseException&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;BlockingIOError&#x27;</span>, <span class="string">&#x27;BrokenPipeError&#x27;</span>, <span class="string">&#x27;BufferError&#x27;</span>, <span class="string">&#x27;BytesWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ChildProcessError&#x27;</span>, <span class="string">&#x27;ConnectionAbortedError&#x27;</span>, <span class="string">&#x27;ConnectionError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ConnectionRefusedError&#x27;</span>, <span class="string">&#x27;ConnectionResetError&#x27;</span>, <span class="string">&#x27;DeprecationWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;EOFError&#x27;</span>, <span class="string">&#x27;Ellipsis&#x27;</span>, <span class="string">&#x27;EnvironmentError&#x27;</span>, <span class="string">&#x27;Exception&#x27;</span>, <span class="string">&#x27;False&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;FileExistsError&#x27;</span>, <span class="string">&#x27;FileNotFoundError&#x27;</span>, <span class="string">&#x27;FloatingPointError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;FutureWarning&#x27;</span>, <span class="string">&#x27;GeneratorExit&#x27;</span>, <span class="string">&#x27;IOError&#x27;</span>, <span class="string">&#x27;ImportError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ImportWarning&#x27;</span>, <span class="string">&#x27;IndentationError&#x27;</span>, <span class="string">&#x27;IndexError&#x27;</span>, <span class="string">&#x27;InterruptedError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;IsADirectoryError&#x27;</span>, <span class="string">&#x27;KeyError&#x27;</span>, <span class="string">&#x27;KeyboardInterrupt&#x27;</span>, <span class="string">&#x27;LookupError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;MemoryError&#x27;</span>, <span class="string">&#x27;NameError&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;NotADirectoryError&#x27;</span>, <span class="string">&#x27;NotImplemented&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;NotImplementedError&#x27;</span>, <span class="string">&#x27;OSError&#x27;</span>, <span class="string">&#x27;OverflowError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>, <span class="string">&#x27;PermissionError&#x27;</span>, <span class="string">&#x27;ProcessLookupError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ReferenceError&#x27;</span>, <span class="string">&#x27;ResourceWarning&#x27;</span>, <span class="string">&#x27;RuntimeError&#x27;</span>, <span class="string">&#x27;RuntimeWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;StopIteration&#x27;</span>, <span class="string">&#x27;SyntaxError&#x27;</span>, <span class="string">&#x27;SyntaxWarning&#x27;</span>, <span class="string">&#x27;SystemError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SystemExit&#x27;</span>, <span class="string">&#x27;TabError&#x27;</span>, <span class="string">&#x27;TimeoutError&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;TypeError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;UnboundLocalError&#x27;</span>, <span class="string">&#x27;UnicodeDecodeError&#x27;</span>, <span class="string">&#x27;UnicodeEncodeError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;UnicodeError&#x27;</span>, <span class="string">&#x27;UnicodeTranslateError&#x27;</span>, <span class="string">&#x27;UnicodeWarning&#x27;</span>, <span class="string">&#x27;UserWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ValueError&#x27;</span>, <span class="string">&#x27;Warning&#x27;</span>, <span class="string">&#x27;ZeroDivisionError&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;__build_class__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;abs&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;any&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;bool&#x27;</span>, <span class="string">&#x27;bytearray&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>, <span class="string">&#x27;callable&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;classmethod&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;complex&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;delattr&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>, <span class="string">&#x27;divmod&#x27;</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;filter&#x27;</span>, <span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;frozenset&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;hasattr&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hash&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;isinstance&#x27;</span>, <span class="string">&#x27;issubclass&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;locals&#x27;</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;oct&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;ord&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;property&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;range&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;reversed&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;setattr&#x27;</span>, <span class="string">&#x27;slice&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sorted&#x27;</span>, <span class="string">&#x27;staticmethod&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;vars&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;zip&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="包的构建"><a href="#包的构建" class="headerlink" title="包的构建"></a>包的构建</h1><p>包是一种用“点式模块名”构造 Python 模块命名空间的方法。<br>下面这个分级文件树展示了 sound 这个包的架构：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sound/                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats/                  Subpackage for file format conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  Subpackage for sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  Subpackage for filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>只有包含 _<em>init</em>.py 文件的目录会被当成包。  </p>
<p>可以从包中导入单个模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo       <span class="comment"># 导入单个模块，引用函数时需要子模块全名</span></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo  <span class="comment"># 导入单个模块，引用函数时需要子模块名(无需前缀)</span></span><br><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter     <span class="comment"># 导入单个函数，它同样也会加载这个子模块，但引用函数无需子模块名</span></span><br></pre></td></tr></table></figure>

<p>使用通配符导入所有模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>使用显示索引，在包内 <strong>init</strong>.py 定义 <strong>all</strong>&#x3D; [“echo”,”surround”.”reverse”] 能够让通配符导入这三个子模块。如果没有定义 <strong>all</strong> 变量，则不把所有子模块加载到当前命名空间。实际上不推荐使用该方法，花费时间且可能不够准确</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>kali工具之Nmap</title>
    <url>/2023/02/09/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/kali%E5%B7%A5%E5%85%B7/kali%E5%B7%A5%E5%85%B7%E4%B9%8BNmap/</url>
    <content><![CDATA[<p>参考kali官网上<a href="https://www.kali.org/tools/nmap/">!Nmap文档</a></p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这个包含有所有体系结构共享的nmap结构文件，在kali中安装命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install nmap-common</span></span><br></pre></td></tr></table></figure>

<p>此外对于这个体系结构内的包可以单独安装，不过不如直接安装一下</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -v -A -sV 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>这句命令中，参数-v启动详细模式（verbose mode），该模式下允许OS探测、版本探测、脚本扫描、路由追踪。参数-A启用路由追踪功能，相当于是traceroute(windows下为tracert)，它利用ICMP协议定位计算器和目标计算器之间的所有路由。参数-sV则指定了目标被探测ip</p>
<h2 id="nping命令"><a href="#nping命令" class="headerlink" title="nping命令"></a>nping命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nping --tcp -p 22 --flags syn --ttl 2 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>使用tcp模式探测目标ip的端口22，其中使用的信号量为SYN，生存周期为2次</p>
<h2 id="ndiff命令"><a href="#ndiff命令" class="headerlink" title="ndiff命令"></a>ndiff命令</h2><p><strong>使用例子</strong><br>对比两个扫描结果报告的不同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndiff yesterdayReport.xml todayReport.xml</span><br></pre></td></tr></table></figure>

<p>ndiff是用来对比Nmap扫描的工具，它是使用两个Nmap结果文件（xml格式），打印不同结果</p>
<h2 id="ncat命令"><a href="#ncat命令" class="headerlink" title="ncat命令"></a>ncat命令</h2><p><strong>使用列子</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ncat -v --exec &quot;/bin/bash&quot; --allow 192.168.1.123 -l 4444 --keep-open</span><br></pre></td></tr></table></figure>
<p>参数-v启用详细模式（verbose mode），在连接时允许”&#x2F;bin&#x2F;bash”，只允许192.168.1.123一个ip，监听tcp端口4444，并且在断开连接时保持打开</p>
<p>ncat是NMAP项目对Netcat的重新实现，提供了原始实现中的大部分功能，以及一些新功能，如IPv6和SSL支持。端口扫描支持已删除。ncat -h可以获得帮助提示</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>kali工具</category>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>kali工具之sqlmap</title>
    <url>/2023/02/09/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/kali%E5%B7%A5%E5%85%B7/kali%E5%B7%A5%E5%85%B7%E4%B9%8Bsqlmap/</url>
    <content><![CDATA[<p>参考kali官网上<a href="https://www.kali.org/tools/sqlmap/">!sqlmap文档</a></p>
<span id="more"></span>














]]></content>
      <categories>
        <category>学习</category>
        <category>kali工具</category>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2023/02/06/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/CSS%E4%B8%93%E9%A2%98/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p>在ui自动化时，元素查询往往要用到CSS定位，故专门从CSS构建基础拎出来，方便学习</p>
<span id="more"></span>

<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><h2 id="组合成选择器列表"><a href="#组合成选择器列表" class="headerlink" title="组合成选择器列表"></a>组合成选择器列表</h2><p>可以用逗号隔开选择器们，这让一条规则包含多个选择器，构成选择器列表；如果这条规则某个选择器出现语法错误，则这条规则里所有选择器都不会应用规则</p>
<h2 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h2><p>类型选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>通配符选择器是由一个星号指代的，选中了文档中所有的内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*选择了作为（其他元素的）第一子元素的&lt;article&gt;*/</span></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first</span>-child</span><br><span class="line"><span class="comment">/*选择了article元素的第一子元素*/</span></span><br><span class="line"><span class="selector-tag">article</span> *<span class="selector-pseudo">:first</span>-child</span><br></pre></td></tr></table></figure>

<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器以点号（.）开头，加上类名，点号前可以添加特定元素，那么会选择这个元素类型的这个类；可以对一个选择器进行“点类”，指定其中满足类条件的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;article class=&quot;class1 class2&quot;&gt; */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.class1</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.class1</span><span class="selector-class">.class2</span></span><br></pre></td></tr></table></figure>

<h2 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h2><p>ID选择器以井号（#）开头，再加上ID名；一篇文档中，一个ID只会用到一次：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;p id=&quot;one&quot;&gt; */</span></span><br><span class="line"><span class="selector-id">#one</span></span><br></pre></td></tr></table></figure>

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><h3 id="属性存在选择器、属性值匹配选择"><a href="#属性存在选择器、属性值匹配选择" class="headerlink" title="属性存在选择器、属性值匹配选择"></a>属性存在选择器、属性值匹配选择</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;a title=&quot;mylink&quot; href=&quot;https://exmaple.com&quot;&gt; */</span></span><br><span class="line"><span class="comment">/* 选择含有这个属性的元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择属性值为指定值得元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.com&quot;</span>]</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;li class=&quot;apple basic circle&quot;&gt; */</span></span><br><span class="line"><span class="comment">/* 选择指定值能够匹配至少一个属性的元素；如果仅仅用 li[class=&quot;apple&quot;] 则不会选择到 */</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class~=<span class="string">&quot;apple&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="属性子字符串匹配选择"><a href="#属性子字符串匹配选择" class="headerlink" title="属性子字符串匹配选择"></a>属性子字符串匹配选择</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;div lang=&quot;zh-CN&quot;&gt; */</span></span><br><span class="line"><span class="comment">/* 匹配属性值开始部分为指定值，后面紧随连字符的元素，也可以直接等于指定值本身 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[lang|=<span class="string">&quot;zh&quot;</span>]</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[lang|=<span class="string">&quot;zh-CN&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配属性值开始部分为指定值的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[lang^=<span class="string">&quot;z&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配属性值结束部分为指定值的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[lang$=<span class="string">&quot;N&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配属性值存在以部分为指定值的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[lang*=<span class="string">&quot;h&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="设定大小写不敏感"><a href="#设定大小写不敏感" class="headerlink" title="设定大小写不敏感"></a>设定大小写不敏感</h3><p>在属性值后添加一个标记 i ，如 li[class^&#x3D;”a”i] ，可以匹配以’A’或’a’开头的类名，如 “Abc”</p>
<h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><h3 id="伪类和用户行为伪类"><a href="#伪类和用户行为伪类" class="headerlink" title="伪类和用户行为伪类"></a>伪类和用户行为伪类</h3><p>伪类就是开头为冒号( : )的关键字。它用于处于特定状态的元素，比如某个元素是这一类型的第一个元素，某个鼠标正悬停的元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择 &lt;article&gt; 元素下第一个 &lt;p&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child</span><br></pre></td></tr></table></figure>
<p>此外，还可以有 :last-child, :only-child, :invalid （未通过校验的 input 和 form 元素）</p>
<p>一些伪类应用于用户以某种方式和文档交互，这些被称为用户伪类，有时也被叫做动态伪类</p>
<p>常见的用户行为伪类有:</p>
<ul>
<li>:hover – 用户将指针挪到元素上才会激活，一般就是链接元素</li>
<li>:focous – 只会在用户使用键盘，选定元素的时候激活</li>
</ul>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素选择器以双冒号开头( :: )；伪元素并没有额外添加新的元素，而是在选择器中以一定规则选取部分内容，这样的选取让被选内容看上去就像元素一样</p>
<p><em>注意，一些早期的伪元素曾使用单冒号的语法，现代浏览器为保持兼容扔支持它们</em></p>
<p>如 ::first-line 伪元素选择器会选中第一行内容，即使第一行内容发生变化，甚至是拉伸窗口导致的行长度变化，也会被伪元素选择器捕捉</p>
<p>伪元素和伪类可以组合使用，并不冲突，如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪元素-before和-after设置特殊内容"><a href="#伪元素-before和-after设置特殊内容" class="headerlink" title="伪元素::before和::after设置特殊内容"></a>伪元素::before和::after设置特殊内容</h3><p>::before和::after这组特别地伪元素，和 content 属性一起使用，将内容插到文档中；它们的推荐用法是插入一个视觉性的提示，示例如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;p class=&quot;box&quot;&gt;Content in the box in my HTML page.&lt;/p&gt; */</span></span><br><span class="line"><span class="comment">/* 这些伪元素的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。 */</span></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; ➥&quot;</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>在表单中经常使用这种方法做出红色的星号提示，以及检验不通过后文本框后的红色小字；当然，如果要这么做，仅仅设置content是不够的</p>
<p>下个示例，我们已经用 ::before伪元素加入了个空字符串。我们把它设为了display: block，以让它可以用 width 和 height 进行样式化，这样会在文本内容前面出现个方块</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;p class=&quot;box&quot;&gt;Content in the box in my HTML page.&lt;/p&gt; */</span></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: rebeccapurple;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="其他伪类或伪元素参考"><a href="#其他伪类或伪元素参考" class="headerlink" title="其他伪类或伪元素参考"></a>其他伪类或伪元素参考</h3><p>伪类:</p>
<ul>
<li>:active–用户激活时匹配，用鼠标交互时代表用户按下和松开之间的时间</li>
<li>:cheked–匹配选择状态的单选或者复选框</li>
<li>:default–匹配一组元素中默认的UI元素</li>
<li>:enabled–匹配处于开启状态的用户界面元素，如没有diable的input元素</li>
<li>:first-child–（也有last版本）选择在一组兄弟元素中的第一个元素</li>
<li>:first-of-type–（也有last版本）选择在父元素中第一个出该这种类型的元素，如 p::first-of-type 表示父元素下第一个p元素</li>
<li>:focus–表示获得焦点的元素，如表单输入，用户点击它是会被触发</li>
<li>:hover–用户悬浮到一个元素之上的时候匹配</li>
<li>:invalid–（也有valid版本）匹配诸如input的未通过校验的元素</li>
<li>:link–匹配未曾访问的链接</li>
<li>:visited–匹配已访问链接</li>
<li>:not()–反伪类，匹配不符合一组选择器的元素，如 :not(p) 则选择所有不是p的元素，里面的一组选择器可以是 元素和类，但不能是伪元素</li>
<li>:nth-child(an+b)–按一定顺序匹配，如 2n+1 匹配一组兄弟元素的第1、3、5、7…个元素</li>
<li>:read-only–匹配用户不可更改的元素</li>
<li>:required–匹配必填form元素</li>
</ul>
<p>伪元素:</p>
<ul>
<li>::after – 匹配出现在原有元素的实际内容之后的一个可样式化元素（实际为在样式表中新添的content）</li>
<li>::before – 匹配出现在原有元素的实际内容之前的一个可样式化元素（实际为在样式表中新添的content）</li>
<li>其余似乎不怎么常用</li>
</ul>
<h2 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>用单个空格(“ “)组合前后多个选择器，如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配类名为 .box 的元素的子、孙和更下代的元素p */</span></span><br><span class="line"><span class="comment">/* &lt;div class=&quot;box&quot;&gt; &lt;article&gt; &lt;p&gt;xxxxxx&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两个都选择到了内容为xxxxxx的p元素 */</span> </span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子代关系选择器"><a href="#子代关系选择器" class="headerlink" title="子代关系选择器"></a>子代关系选择器</h3><p>用大于号(&gt;)组合前后选择器，相比后代选择器，它只限定了直接子元素:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配类名为 .box 的元素的子、孙和更下代的元素p */</span></span><br><span class="line"><span class="comment">/* &lt;div class=&quot;box&quot;&gt; &lt;article&gt; &lt;p&gt;xxxxxx&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; */</span></span><br><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<h3 id="邻接兄弟选择器"><a href="#邻接兄弟选择器" class="headerlink" title="邻接兄弟选择器"></a>邻接兄弟选择器</h3><p>用加号(+)组合两个选择器，如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*&lt;article&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;A heading&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;段落1&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;段落2&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;/article&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 这个只会选择内容为“段落1”的p元素 */</span></span><br><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> </span><br></pre></td></tr></table></figure>
<h3 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h3><p>用(~)组合兄弟元素，它们可以不直接相邻</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1 ~ p </span><br></pre></td></tr></table></figure>


<h1 id="CSS值"><a href="#CSS值" class="headerlink" title="CSS值"></a>CSS值</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>CSS的数值类型有以下几种：</p>
<table>
<thead>
<tr>
<th>数值类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;integer&gt;</td>
<td>一个整数；某些属性允许负数</td>
</tr>
<tr>
<td>&lt;number&gt;</td>
<td>一个小数，如 -1.2 ;它也可能仅有整数部分</td>
</tr>
<tr>
<td>&lt;dimension&gt;</td>
<td>这算是一个附加单位的&lt;number&gt;，如 45px</td>
</tr>
<tr>
<td>&lt;percentage&gt;</td>
<td>百分数，它总是有一个参照量</td>
</tr>
</tbody></table>
<p>绝对长度单位：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>名称</th>
<th>等价换算</th>
</tr>
</thead>
<tbody><tr>
<td>px</td>
<td>像素</td>
<td></td>
</tr>
<tr>
<td>~~</td>
<td>cm</td>
<td>厘米</td>
</tr>
<tr>
<td>~~</td>
<td>in</td>
<td>英寸</td>
</tr>
<tr>
<td>~~</td>
<td>pt</td>
<td>点</td>
</tr>
</tbody></table>
<p>相对长度单位：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>相对于</th>
</tr>
</thead>
<tbody><tr>
<td>em</td>
<td>在font-size中相对于父元素，其他属性中相对于自身字体的大小（如width中使用是相对于字体大小）</td>
</tr>
<tr>
<td>~~</td>
<td>lh</td>
</tr>
<tr>
<td>~~</td>
<td>rem</td>
</tr>
<tr>
<td>vw</td>
<td>视窗宽度的 1%</td>
</tr>
<tr>
<td>vh</td>
<td>视窗高度的 1%</td>
</tr>
<tr>
<td>一般常使用em，网页顶部横幅之类的，应该用vw（且可能是100vw）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="颜色值"><a href="#颜色值" class="headerlink" title="颜色值"></a>颜色值</h2><p>现代计算机的标准颜色系统是24位，允许通过红、绿、蓝通道的组合显示，每个通道有256个不同的值；此外还有alpha通道能控制透明度</p>
<p>颜色数据类型可以使用颜色关键字，也可以使用16进制rgb值和函数（或者rgba值和函数）</p>
<h2 id="图片值"><a href="#图片值" class="headerlink" title="图片值"></a>图片值</h2><p>图片数据类型可以是一个 url() 函数，也可以是一个渐变函数</p>
<h2 id="位置值"><a href="#位置值" class="headerlink" title="位置值"></a>位置值</h2><p>位置数据源类型表示一组2D坐标，用以定位一个元素，可以使用关键字（如top、left、bottom、right、center）和像素指定，如 background-position: right 10px; 指定了背景图片的位置</p>
<h2 id="使用函数组合CSS值"><a href="#使用函数组合CSS值" class="headerlink" title="使用函数组合CSS值"></a>使用函数组合CSS值</h2><p>calc()函数能够对CSS值进行简单计算，如 width: calc(20% + 100px);</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>CSS专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python内置数据结构</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>记录python基本的数据结构</p>
<span id="more"></span>

<h1 id="列表list-底层为数组逻辑的智能实现"><a href="#列表list-底层为数组逻辑的智能实现" class="headerlink" title="列表list 底层为数组逻辑的智能实现"></a>列表list <div style="display:none">底层为数组逻辑的智能实现</div></h1><h2 id="列表基本方法"><a href="#列表基本方法" class="headerlink" title="列表基本方法"></a>列表基本方法</h2><p>下面时list类型的方法，其中形如(<em>x,[i]</em>)的参数，表示 i 为可选参数:</p>
<ul>
<li>list.append(<em>x</em>)      尾部添加一个元素</li>
<li>list.extend(<em>iterable</em>) 使用可迭代对象的元素扩展列表，相当于 a[len(a):]&#x3D;iterable</li>
<li>list.insert(<em>i,x</em>)    指定位置插入元素</li>
<li>list.remove(<em>x</em>)      删除列表中第一个值为x的元素；未找到则触发 ValueError异常</li>
<li>list.pop([<em>i</em>])     删除并返回指定位置元素，未指定位置时操作列表最后一个元素             </li>
<li>list.clear()          清空列表</li>
<li>list.index(<em>x, [start, [end]]</em>)   返回指定索引范围内第一个值为x的零基索引（返回的索引是基于整个list序列，而非start参数的），未找到则触发 ValueError 异常</li>
<li>list.count(<em>x</em>)       返回列表中x的出现次数</li>
<li>list.sort(<em>*, key&#x3D;None, reverse&#x3D;False</em>)    就地排序列表中的元素，；列表元素没有定义排序方法的，无法使用sort</li>
<li>list.reverse()        翻转列表元素</li>
<li>list.copy()           返回列表浅拷贝，浅拷贝仅复制引用</li>
</ul>
<p>insert、remove、sort 、reverse等方法只修改列表（非副本），不返回列表对象，返回默认None；pop方法仅仅是返回删除的元素，也不会返回列表对象。<br><strong>这是所有Python可变数据结构设计原则，即不返回本身的引用。</strong></p>
<h2 id="列表实现堆栈"><a href="#列表实现堆栈" class="headerlink" title="列表实现堆栈"></a>列表实现堆栈</h2><p>列表使用 append 和 pop 方法很容易实现堆栈。列表的底层数据是数组，按照数组的逻辑实现堆栈即可，仅需注意列表的尾部是可扩展的</p>
<h2 id="不应该使用列表实现队列"><a href="#不应该使用列表实现队列" class="headerlink" title="不应该使用列表实现队列"></a>不应该使用列表实现队列</h2><p>列表实现队列的效率很低，最好使用 collections.deque (deque意思是“双向队列”)，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Terry&quot;</span>)           </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Graham&quot;</span>)          </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 </span><br><span class="line"><span class="string">&#x27;Eric&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 </span><br><span class="line"><span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue                           </span><br><span class="line">deque([<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Terry&#x27;</span>, <span class="string">&#x27;Graham&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式创建列表的方式更简洁。它需要有一个初始表达式，初始表达式每经过一次迭代，列表就会新增一个元素。这个初始表达式可以是一个元组、一个列表、一个字典、一个待被实例化的初始化对象的语句</p>
<p>使用可迭代对象，用满足条件的生成的结果创建新的临时列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意元组 (x, y) 必须加上括号</span></span><br><span class="line"><span class="comment">#如 [x, y for x in [1,2,3] for y in [3,1,4] if x != y] 会报语法错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>

<p>用列表推导式生成的临时列表来创建列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<h2 id="内置函数-zip-替代一些复杂列表推导式"><a href="#内置函数-zip-替代一些复杂列表推导式" class="headerlink" title="内置函数 zip 替代一些复杂列表推导式"></a>内置函数 zip 替代一些复杂列表推导式</h2><p>内置函数 <strong>zip(<em>*iterables, strict&#x3D;False</em>)</strong> 可以有效替代转置功能的列表推导式</p>
<p>zip的第一个参数列表接收多个迭代对象，第二个参数strict用来限制可迭代对象长度是否相同，不相同会报错 ValueError</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># zip方法把多个列表组合成一个元组列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(x, y))         </span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 注意，这里的  zip(x, y) 表示的是一个(xi, yi)的元组列表，在前面加上星号则对它进行解包，生成两个列表，分别是 xi 列表，yi列表</span></span><br><span class="line">&gt;&gt; <span class="comment"># zip本身的功能是，把作为参数的可迭代对象，组合成一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2, y2 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(x, y))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="built_in">list</span>(x2) <span class="keyword">and</span> y == <span class="built_in">list</span>(y2)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>zip方法的功能，经常用来实现矩阵转置，如有以下列表方式存储的矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [a1, a2, a3],</span><br><span class="line">  [b1, b2, b3],</span><br><span class="line">]</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">[</span><br><span class="line">  (a1,b1), </span><br><span class="line">  (a2,b2), </span><br><span class="line">  (a3,b3)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h2 id="del-语句-按索引和切片方式删除队列元素"><a href="#del-语句-按索引和切片方式删除队列元素" class="headerlink" title="del 语句 按索引和切片方式删除队列元素"></a>del 语句 <div style="display:none">按索引和切片方式删除队列元素<div></h2><p>del 语句按索引、切片从列表删除元素，或者直接删除变量；类似的pop方法仅能删除一个元素同时返回被删元素。使用del唯一推荐的使用情形是，删除末尾切片，或者删除列表变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">0</span>]    <span class="comment"># 按索引删除元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]  <span class="comment"># 使用切片删除元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[:]    <span class="comment"># 清空列表元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a   <span class="comment"># 删除整个变量，此后再引用 a 就会报错</span></span><br></pre></td></tr></table></figure>

<h1 id="元组-多个元素组合成的不可变“常量集合”"><a href="#元组-多个元素组合成的不可变“常量集合”" class="headerlink" title="元组 多个元素组合成的不可变“常量集合”"></a>元组 <div style="display:none">多个元素组合成的不可变“常量集合”</div></h1><p>元组由多个用逗号隔开的值组成。输入时，圆括号不是必要的，但建议有，且作为更大表达式的一部分时是必须的。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>  <span class="comment"># 元组由多个用逗号隔开的值组成</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)      <span class="comment"># 元组可以嵌套</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>元组可以使用索引，但它是immutable(不可变的)，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = <span class="number">88888</span>                <span class="comment"># 元组是不可变的</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>不过列表可以作为元组的元素，我们不能在元组中修改列表对象，但是可以修改列表中的元素(因为存放在元组中的是列表的引用，修改列表中的元素并不会改变元组中的“值”)</p>
<p>元组解包:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = t     <span class="comment"># 元组解包，序列解包时，左侧数量应该与右侧数量相等</span></span><br></pre></td></tr></table></figure>

<h1 id="集合set-具有唯一性的可哈希对象组成的无序集合"><a href="#集合set-具有唯一性的可哈希对象组成的无序集合" class="headerlink" title="集合set 具有唯一性的可哈希对象组成的无序集合"></a>集合set <div style="display:none">具有唯一性的可哈希对象组成的无序集合</div></h1><p>集合有可变集合(set)和不可变集合(frozenset)，集合内的元素若是集合类型，则必是frozenset，其余时候只需关注set即可。 集合是由不重复元素组成的无序容器，其元素必须是可哈希的。基本用法包括成员检测、重复元素消除，还有合集、交集、差集、对称差分等数学运算。</p>
<p>创建集合使用花括号或 set() 函数。注意，创建空集合只能使用 set() ，使用 {} 创建的是空字典。使用set()函数创建列表，要求参数要是一个可迭代对象，如字符串类型则把单个字符作为元素。使用花括号，则括号内可以是一个集合推导式，也可以是逗号分隔的可哈希对象</p>
<p>成员检测和重复消除:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                   <span class="comment"># 重复添加的元素会被忽略</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket              <span class="comment"># 成员检测</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>数学中的集合操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a - b                              <span class="comment"># 差集</span></span><br><span class="line">a | b                              <span class="comment"># 合集</span></span><br><span class="line">a &amp; b                              <span class="comment"># 交集</span></span><br><span class="line">a ^ b                              <span class="comment"># 对称差分，等价于 (a-b)&amp;(b-a)</span></span><br></pre></td></tr></table></figure>

<p>集合支持列表推导式创建:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>set方法有以下相关运算:</p>
<ul>
<li>x in s , x not in s</li>
<li>s &lt;&#x3D; other    检测集合s中每个元素是都在other之中</li>
<li>s.copy()      返回原集合的浅拷贝</li>
<li>s.updata(<em>*others</em>)  这里的星号用于解包，这里的others是元素是集合类型的列表</li>
<li>s.add(<em>elem</em>)     添加新元素</li>
<li>s.remove(<em>elem</em>)  移除元素；如果集合不存在elem元素，在则引发 KeyError</li>
<li>s.discard(<em>elem</em>) 如果集合存在elem元素则将其移除</li>
<li>s.clear()     从集合删除所有元素</li>
</ul>
<h1 id="映射类型-—-dict-字典"><a href="#映射类型-—-dict-字典" class="headerlink" title="映射类型 — dict(字典)"></a>映射类型 — dict(字典)</h1><p>字典的键几乎可以是任意值，非hashable的值，即包含列表、字典或其他可变类型的值不可用作键。<br><em>数字1和数字1.0可以用来引用同一条字典条目，但由于计算机对于浮点数的存储知识近似值，因此将其作为字典键是不明智的</em></p>
<h2 id="字典类型创建"><a href="#字典类型创建" class="headerlink" title="字典类型创建"></a>字典类型创建</h2><p>字典可以使用多种方式创建:</p>
<ul>
<li><p>花括号内以逗号分隔 key:val 对，如 {‘jack’: 4098, ‘sjoerd’: 4127}</p>
</li>
<li><p>使用字典推导式，如 {x: x**2 for x in range(10)}</p>
</li>
<li><p>使用类型构造器dict</p>
<p>class <strong>dict</strong>([<em>**kwargs</em>])<br>class <strong>dict</strong>(<em>mapping</em>[<em>, **kwargs</em>])<br>class <strong>dict</strong>(<em>iterable</em>[<em>, **kwargs</em>])</p>
</li>
</ul>
<p>以下演示几种创建字典的方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;    <span class="comment"># 使用花括号创建字典映射列表，并赋予a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   <span class="comment"># dict通过使用(keyi, vali)二元元组列表作为参数，这里zip后的效果和使用元组列表的参数相同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)          <span class="comment"># dict 参数是花括号表示的字典映射列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(foo=<span class="number">100</span>, bar=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字典类型常见操作"><a href="#字典类型常见操作" class="headerlink" title="字典类型常见操作"></a>字典类型常见操作</h2><p>字典支持的常见操作:</p>
<ul>
<li>list(d)       返回字典d中所有键的列表</li>
<li>d[key]        返回以 key 为键的项，不存在则引发 KeyError</li>
<li>d[key]&#x3D;val    新建或修改键值为 key 的项的值</li>
<li>key in d, key not in d</li>
<li>iter(d)       返回以字典的键为元素的迭代器，等价于 iter(d.keys())</li>
<li>d.items()     返回“键值对”动态视图；可以用作迭代器</li>
<li>d.key()       </li>
<li>d.values()</li>
<li>d.get(<em>key[, default]</em>)   返回键key对应的值，否则返回default；default默认None，不会引发KeyError</li>
<li>d.pop(<em>key[, default]</em>)   </li>
<li>d.popitem()   python3.7版本后以LIFO(后进先出)顺序弹出”键值对”，空则引发 KeyError</li>
</ul>
<h1 id="循环技巧-—-字典、集合"><a href="#循环技巧-—-字典、集合" class="headerlink" title="循环技巧 — 字典、集合"></a>循环技巧 — 字典、集合</h1><h2 id="字典中循环"><a href="#字典中循环" class="headerlink" title="字典中循环"></a>字典中循环</h2><p>在字典中循环时，用 items() 方法可以同时取出键、值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>
<h2 id="序列中循环"><a href="#序列中循环" class="headerlink" title="序列中循环"></a>序列中循环</h2><p>在序列中循环时，用 enumerate 函数可以同时取出位置索引、值，直接使用列表则仅有值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure>

<p>在多个序列中“同序”循环时，应该使用 zip 函数，他可以把多个列表打包成一个元组列表，然后被迭代取出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a)) </span><br><span class="line">...</span><br><span class="line">What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>
<h2 id="指定顺序循环"><a href="#指定顺序循环" class="headerlink" title="指定顺序循环"></a>指定顺序循环</h2><p>逆向循环序列可以调用 reversed 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>按指定顺序可以用 sorted 函数，返回一个排序好的副本而不改变原有序列:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):   <span class="comment"># 其中特别使用 set 来去除重复元素</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>
<h2 id="条件控制应用于循环技巧"><a href="#条件控制应用于循环技巧" class="headerlink" title="条件控制应用于循环技巧"></a>条件控制应用于循环技巧</h2><p>while 和 if 的条件句可以配合以下运算符使用:</p>
<ul>
<li>in 、 not in      执行成员检测，确定一个对象是否存在于某个容器内</li>
<li>is 、 is not      用来比较两个对象是否是同一个对象</li>
<li>and 、 or         </li>
<li>:&#x3D;                海象运算符，在表达式内部赋值使用；这和C不同</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数定义详解记录</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录python函数定义的比较完备的内容</p>
<span id="more"></span>


<h1 id="函数定义详解"><a href="#函数定义详解" class="headerlink" title="函数定义详解"></a>函数定义详解</h1><h2 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ask_ok</span>(<span class="params">prompt,retries=<span class="number">4</span>,reminder=<span class="string">&#x27;default_c&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = <span class="built_in">input</span>(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;ye&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>):    <span class="comment">#关键字 in 用于确认序列中是否包含某个值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;nop&#x27;</span>, <span class="string">&#x27;nope&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid user response&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(reminder)</span><br></pre></td></tr></table></figure>
<p>其中 retries 和 reminder 设置了默认值参数，调用 ask_ok 时可以按序省略参数，只要不“跳着省略”</p>
<p>函数的默认值参数是在，形如 def f(arg&#x3D;i) 中的，默认值只计算一次，轮到<strong>定义</strong>这个函数时就决定好的，但是一般不要把一个变量赋予给默认参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg=i</span>):    <span class="comment">#在这一步，arg的默认参数永远决定为是 5</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对于类、字典、列表等作为被赋予的默认参数时，计算并传递的是引用。如果想要达到有默认值的效果，应该在函数内部初始化这个列表。</p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>在调用含有默认值参数的函数时，可以指出参数名，包括非默认值参数。<br><u>一旦使用关键字参数形式调用函数，所有调用的默认值参数都必须指出参数名</u>，也不能对同一个参数名多次赋值；如果非默认值参数不是前排位置，也必须要指出参数名。</p>
<h2 id="元组参数和字典参数"><a href="#元组参数和字典参数" class="headerlink" title="元组参数和字典参数"></a>元组参数和字典参数</h2><p>对于含有元组参数，字典参数的函数，调用参数中的元组元素和字典元素可以平铺出来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cheeseshop</span>(<span class="params">kind, *arguments, **keywords</span>):   <span class="comment"># 第二个参数为元组，第三个参数为字典</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#元组参数和字典参数可以平铺出来调用</span></span><br><span class="line">cheeseshop(<span class="string">&quot;Limburger&quot;</span>, </span><br><span class="line">            <span class="string">&quot;It&#x27;s very runny, sir.&quot;</span>,            <span class="comment"># 元组arguments第1个元素</span></span><br><span class="line">           <span class="string">&quot;It&#x27;s really very, VERY runny, sir.&quot;</span>,<span class="comment"># 元组arguments第2个元素</span></span><br><span class="line">           shopkeeper=<span class="string">&quot;Michael Palin&quot;</span>,      <span class="comment"># 字典keywords第1个元素</span></span><br><span class="line">           client=<span class="string">&quot;John Cleese&quot;</span>,            <span class="comment"># 字典keywords第2个元素</span></span><br><span class="line">           sketch=<span class="string">&quot;Cheese Shop Sketch&quot;</span>)     <span class="comment"># 字典keywords第3个元素</span></span><br></pre></td></tr></table></figure>


<h2 id="特殊参数及参数规范"><a href="#特殊参数及参数规范" class="headerlink" title="特殊参数及参数规范"></a>特殊参数及参数规范</h2><p>比较规范的函数定义方式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):</span><br><span class="line">      -----------    ----------     ----------</span><br><span class="line">        |               |                |</span><br><span class="line">        |         位置或关键字参数         |</span><br><span class="line">        |                                 |</span><br><span class="line">  仅仅是位置参数                     仅仅是关键字参数</span><br></pre></td></tr></table></figure>
<p>特殊参数 / 和 * 是可选的，这两个符号明确隔开了，哪些是仅位置参数，那些是仅关键字参数</p>
<p>如以下代码，kwds 把 name 当作键，关键字 ‘name’ 又与第一个形参绑定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, **kwds</span>):</span><br><span class="line">···    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values <span class="keyword">for</span> argument <span class="string">&#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因为这种调用方法等同于 foo(name&#x3D;1, name&#x3D;2) ,这里第一个是位置参数制定了参数名的形式，第二个是 kwds 里的键名</p>
<p>加上特殊参数后，函数定义会把 name 当作位置参数，’name’ 也可以作为关键字参数的键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, /, **kwds</span>):</span><br><span class="line">···    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="任意实参列表"><a href="#任意实参列表" class="headerlink" title="任意实参列表"></a>任意实参列表</h2><p>函数定义时，可以使用“固定数量形参+列表形参(形如*args，**args)”。<br>调用时要求独立给出参数，即一个一个给出实参列表中的每一个元素，然后 *args 和 **args 会按照规则收集这些实参</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_multiple_items</span>(<span class="params">file, separator, *args</span>):</span><br><span class="line">    file.write(separator.join(args))</span><br></pre></td></tr></table></figure>
<p>尾部的 *args 会收集调用时的所有剩余参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*args, sep=<span class="string">&quot;/&quot;</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> sep.join(args)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth/mars/venus&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>, sep=<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth.mars.venus&#x27;</span></span><br></pre></td></tr></table></figure>
<p>*args 会自动收集实参；在实参列表后的位置参数或默认参数，调用时需要指定参数名</p>
<h2 id="解包实参列表"><a href="#解包实参列表" class="headerlink" title="解包实参列表"></a>解包实参列表</h2><p>对于定义时，指定了形如 *args  **args的参数，调用时可以对元组类型或字典类型解包，把他们变成独立的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(*args))</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>这种调用方法把元组类型args&#x3D;[3,6] 解包成两个参数 3和6 ，效果等同于 range(3, 6)</p>
<p>同样地，也可以对字典类型解包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">d = &#123;<span class="string">&quot;voltage&quot;</span>: <span class="string">&quot;four million&quot;</span>, <span class="string">&quot;state&quot;</span>: <span class="string">&quot;bleedin&#x27; demised&quot;</span>, <span class="string">&quot;action&quot;</span>: <span class="string">&quot;VOOM&quot;</span>&#125;</span><br><span class="line">parrot(**d)</span><br></pre></td></tr></table></figure>
<p>这种调用方法等同于 parrot(voltage&#x3D;”four million”, state&#x3D;”bleedin’ demised”, action&#x3D;”VOOM”)</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>此处不记述。自认为，在python中，使用lambda的场合较少。</p>
<h2 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h2><p>function.<strong>doc</strong> 属性返回函数的文档字符串</p>
<p>下面是多行文档字符串的一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Do nothing, but document it.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    No, really, it doesn&#x27;t do anything.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(my_function.__doc__)</span><br><span class="line">Do nothing, but document it.</span><br><span class="line"></span><br><span class="line">    No, really, it doesn<span class="string">&#x27;t do anything.</span></span><br></pre></td></tr></table></figure>
<p>第一行应为对象用途的简短摘要,以大写字母开头，以句点结尾;文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。</p>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><p>函数注解是可选的用户自定义函数类型的元数据完整信息。<br>标注以字典的形式存放在函数的 <strong>annotations</strong> 属性中：</p>
<ul>
<li>形参标注的定义方式是在形参名后加冒号，后面跟一个表达式，该表达式会被求值为标注的值</li>
<li>返回值标注的定义方式是加组合符号 -&gt;，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">ham: <span class="built_in">str</span>, eggs: <span class="built_in">str</span> = <span class="string">&#x27;eggs&#x27;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Annotations:&quot;</span>, f.__annotations__)</span><br><span class="line">···     <span class="keyword">return</span> ham + <span class="string">&#x27; and &#x27;</span> + eggs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">Annotations: &#123;<span class="string">&#x27;ham&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;return&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;eggs&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br><span class="line"><span class="string">&#x27;spam and eggs&#x27;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python句法错误和异常</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E5%8F%A5%E6%B3%95%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>记录python常用的标准库内容</p>
<span id="more"></span>



<h1 id="句法错误"><a href="#句法错误" class="headerlink" title="句法错误"></a>句法错误</h1><p>句法错误又称解析错误，会提出 SyntaxError: invalid syntax</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>解析器会复现出现句法错误的代码行，并用小“箭头”指向行里检测到的第一个错误</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常是执行时检测到的错误，异常的类型会作为错误信息的一部分打印出来；标准的异常类型是内置的标识符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>特别地，用户中断程序(如 Control-C)会触发 KeyboardInterrupt 异常</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>使用 try…except 来捕获和处理异常，其工作原理如下:</p>
<ol>
<li>执行try子句</li>
<li>如果没有触发异常，则跳过 except 子句，try 语句执行完毕</li>
<li>如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分</li>
<li>关键字 except 会匹配类型一致的异常并交付给对应处理程序；如果所在”try子句–except子句”无法匹配这个异常，则跳到外部处理</li>
<li>如果这个异常在最外部还没有得到处理，则它是一个 <em>未处理异常</em> 且执行将终止</li>
</ol>
<h3 id="except子句"><a href="#except子句" class="headerlink" title="except子句"></a>except子句</h3><p>except子句的使用特点:</p>
<ul>
<li>except子句可以使用圆括号的元组，指定多个异常，如 except (RuntimeError, TypeError, NameError)</li>
<li>except子句指定的异常类型，可以兼容它的派生类；所有异常都继承自 BaseException</li>
<li>except子句使用 as 绑定触发的异常实例</li>
</ul>
<p>except子句使用 as 绑定触发的异常实例，并将参数存储在 instance.args 中，该实例定义了 <strong>str</strong>() ，无需添加后缀 .args 也可直接打印参数； 也可以在引发异常之前就实例化一个异常实例并添加属性。<br>以下是 as 绑定异常实例的演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> Exception(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> inst:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">type</span>(inst))    <span class="comment"># the exception instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(inst.args)     <span class="comment"># arguments stored in .args</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(inst)          <span class="comment"># __str__ allows args to be printed directly,</span></span><br><span class="line"><span class="meta">... </span>                         <span class="comment"># but may be overridden in exception subclasses</span></span><br><span class="line"><span class="meta">... </span>    x, y = inst.args     <span class="comment"># unpack args</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;y =&#x27;</span>, y)</span><br><span class="line">...</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;Exception&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">x = spam</span><br><span class="line">y = eggs</span><br></pre></td></tr></table></figure>

<h3 id="else子句–对try语句的补充"><a href="#else子句–对try语句的补充" class="headerlink" title="else子句–对try语句的补充"></a>else子句–对try语句的补充</h3><p>try…except 语句具有可选的 else 子句，它必须放在所有except子句之后，没有引发异常时会执行else子句；使用else子句可以避免捕获到无需try保护的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(arg, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;无法打开文件:&#x27;</span>, arg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 无论是否触发异常，都会执行以下代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已经执行过open函数&#x27;</span>);</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h3 id="finally子句–定义清理操作"><a href="#finally子句–定义清理操作" class="headerlink" title="finally子句–定义清理操作"></a>finally子句–定义清理操作</h3><p>如果存在finally子句，则finally子句是try语句结束前执行的最后一项任务，不论是否触发异常。<br>因此，一般会先执行finally再处理异常；实际上是暂时搁置这个异常(不确定是否已经实例化过)，执行完finally子句后，再重新触发该异常。  </p>
<p>此外，还有使用with关键字这样的预定义好的清理操作。常见的有 打开文件<span> with open(“myfile.txt”) as f </span> ，请求网络资源<span> with urllib.request.urlopen(“<a href="http://ceshi.com&quot;/">http://ceshi.com&quot;</a>) as response </span> 。支持预定义清理操作的对象会在文档中指出这一点。</p>
<h2 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h2><h3 id="“自然”触发异常"><a href="#“自然”触发异常" class="headerlink" title="“自然”触发异常"></a>“自然”触发异常</h3><p>这类异常的触发点位于内置函数内部(也许这样的描述不准确)，已经被妥善定义好的，我们无需考虑它如何产生</p>
<h3 id="raise语句强制触发异常"><a href="#raise语句强制触发异常" class="headerlink" title="raise语句强制触发异常"></a>raise语句强制触发异常</h3><p>raise 语句支持在try子句中强制触发异常； raise 唯一的参数就是要触发的异常实例，这个实例一般“匿名” 构造，如:</p>
<ul>
<li>raise NameError(‘HiThere’)    构造了参数为 “HiThere” 的 NameError 实例</li>
<li>raise ValueError()            构造了空参数的 ValueError 实例</li>
</ul>
<h3 id="含有finally子句的复杂触发异常"><a href="#含有finally子句的复杂触发异常" class="headerlink" title="含有finally子句的复杂触发异常"></a>含有finally子句的复杂触发异常</h3><p>由于finally子句必定执行的特性，与 return， else子句，except子句 ，(break, continue) 等结合使用会出现比较复杂的情形:</p>
<ul>
<li>在except和else子句中触发的次级异常，会在finally子句执行后重新触发</li>
<li>如果finally子句包含break、continue、return，异常将不会被重新引发</li>
<li>执行try语句时遇到break、continue、return，则finally子句会在这些语句之前执行</li>
<li>特别地，如果finally中包含return，则不会执行try的return</li>
</ul>
<p>由此可知，finally一定会被执行；实际应用中，finally对于释放外部资源十分有用。</p>
<h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>raise 语句支持可选的 from 子句，该子句用于启用链式异常:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ConnectionError</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    func()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Failed to open database&#x27;</span>) <span class="keyword">from</span> exc</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> func</span><br><span class="line">ConnectionError</span><br><span class="line"></span><br><span class="line"><span class="comment">#The above exception was the direct cause of the following exception:</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">RuntimeError: Failed to <span class="built_in">open</span> database</span><br></pre></td></tr></table></figure>

<p>把 “from exc” 改用 “from None”，可以在输出异常时禁用“链式输出”，仅打印下方 RuntimeError相关的信息</p>
<h1 id="内置异常"><a href="#内置异常" class="headerlink" title="内置异常"></a>内置异常</h1><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类</p>
<p>exception <strong>BaseException</strong>  是所有异常的基类。它不应该被用户自定义类直接继承 (而是使用其子类Exception)。</p>
<ul>
<li>传给构造器的元组参数args，某些异常接受特定数量的参数并含有特定意义，通常的异常只有一个含有错误信息的字符串</li>
<li>方法with_traceback(tb), 此方法会将 tb 设为新的异常回溯信息并返回异常对象。（不太理解，忽略）</li>
</ul>
<p>exception <strong>Exception</strong>  所有内置的非系统退出类异常都派生自此类。所有用户自定义异常也应当派生自此类。似乎也可以用一个内置异常，链式引发RuntimeError(some_message) 一定程度上实现“自定义异常”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">raise</span> ConnectionError</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    func()</span><br><span class="line"><span class="keyword">except</span> ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Failed to open database&#x27;</span>) <span class="keyword">from</span> exc</span><br></pre></td></tr></table></figure>

<p>exception <strong>ArithmeticError</strong>  此基类用于派生针对各种算术类错误而引发的内置异常: OverflowError, ZeroDivisionError</p>
<p>exception <strong>BufferError</strong>  当与缓冲区相关的操作无法执行时将被引发。</p>
<p>exception <strong>LookupError</strong>  此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: IndexError, KeyError。 这可以通过 codecs.lookup() 来直接引发。</p>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>内置异常的层次结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- EncodingWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python标准库概览</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E6%A0%87%E5%87%86%E5%BA%93%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>记录python常用的标准库内容</p>
<span id="more"></span>


<h1 id="标准库简介-第一部分"><a href="#标准库简介-第一部分" class="headerlink" title="标准库简介-第一部分"></a>标准库简介-第一部分</h1><h2 id="操作系统接口–-os模块、shutil模块"><a href="#操作系统接口–-os模块、shutil模块" class="headerlink" title="操作系统接口– os模块、shutil模块"></a>操作系统接口– os模块、shutil模块</h2><h3 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h3><p>os 模块提供了许多与操作系统交互的函数<br>为避免内建函数 open 被 os.open 隐式替换，导入时一定要使用 improt os 而不是 from os import * </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># 获得当前目录</span></span><br><span class="line"><span class="string">&#x27;C:\\Python310&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">&#x27;/server/accesslogs&#x27;</span>)   <span class="comment"># 改变当前目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;mkdir today&#x27;</span>)   <span class="comment"># 运行命令行指令</span></span><br></pre></td></tr></table></figure>
<h3 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h3><p>shutil 模块，详写为 shell utility， 对于日常文件和目录管理提供了更高级别的接口</p>
<h3 id="内置辅助工具–-dir、help"><a href="#内置辅助工具–-dir、help" class="headerlink" title="内置辅助工具– dir、help"></a>内置辅助工具– dir、help</h3><p>内置的 dir() 和 help() 函数可以用作交互式辅助工具，用于处理像 os 这样的大型模块，如 dir(os) ，help(os)</p>
<h2 id="文件通配符–-glob模块"><a href="#文件通配符–-glob模块" class="headerlink" title="文件通配符– glob模块"></a>文件通配符– glob模块</h2><p>glob 模块提供了在目录中使用通配符搜索文件列表的函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;primes.py&#x27;</span>, <span class="string">&#x27;random.py&#x27;</span>, <span class="string">&#x27;quote.py&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="获取命令行参数–-sys模块"><a href="#获取命令行参数–-sys模块" class="headerlink" title="获取命令行参数– sys模块"></a>获取命令行参数– sys模块</h2><p>使用 sys.argv 可以获得调用本模块时，命令行参数列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br></pre></td></tr></table></figure>

<h2 id="直接终止脚本–-sys模块"><a href="#直接终止脚本–-sys模块" class="headerlink" title="直接终止脚本– sys模块"></a>直接终止脚本– sys模块</h2><p>使用 sys.exit() 直接终止脚本</p>
<h2 id="标准流–-sys模块"><a href="#标准流–-sys模块" class="headerlink" title="标准流– sys模块"></a>标准流– sys模块</h2><p>sys 模块还具有 stdin， stdout， stderr 的属性:</p>
<ul>
<li>sys.stdin     用于所有交互式输入，如 input() 的调用</li>
<li>sys.stdout    用于print函数和表达式语句的输出，以及用于 input 的提示符；交互模式下sys.stdout是行缓冲的，非交互情况下是块缓冲的</li>
<li>sys.stderr    解释器自身的提示符和它的错误消息都发往 stderr，即使stdout重定向后也能看到它们；任何情况下(python3.9版本以后)，sys.stderr是行缓冲的</li>
</ul>
<p>sys.__stdin__，sys.__stdout__， sys.__stderr__ 这些对象存有stdin、stderr 和 stdout 的初始值；如果要使用它们恢复已经损坏或无需再使用的实际文件对象，应该在原来流被替换前就显示保存(即使原来流被替换也不会改变这些初始值，但是便于程序的清晰，应该这么做)</p>
<p>这些流都是常规的文本文件，与open函数返回的对象一致</p>
<h2 id="字符串模式匹配–-re模块"><a href="#字符串模式匹配–-re模块" class="headerlink" title="字符串模式匹配– re模块"></a>字符串模式匹配– re模块</h2><p>re 模块提供正则表达式工具:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="string">&#x27;which foot or hand fell fastest&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;foot&#x27;</span>, <span class="string">&#x27;fell&#x27;</span>, <span class="string">&#x27;fastest&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="数学–-math模块、random模块、statistics模块"><a href="#数学–-math模块、random模块、statistics模块" class="headerlink" title="数学– math模块、random模块、statistics模块"></a>数学– math模块、random模块、statistics模块</h2><h3 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a>math模块</h3><p>math 模块提供了对浮点数学的底层C库函数的访问</p>
<h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><p>random 模块提供随机选择工具，一般有一下就几种随机方式:</p>
<ul>
<li>选择序列内随机元素，如 random.choice([‘apple’,’pear’,’banana’])</li>
<li>返回[0.0, 1.0) 范围内下一个随机浮点数，如 random.random() </li>
<li>返回范围内随机整数，如 random.randrange(6, 20, 2)</li>
</ul>
<h3 id="statistics模块"><a href="#statistics模块" class="headerlink" title="statistics模块"></a>statistics模块</h3><p>statistics 模块计算数值数据的基本统计属性，有均值mean、中位数median、方差variance等函数</p>
<h2 id="互联网访问–-urllib-request模块、smtplib模块"><a href="#互联网访问–-urllib-request模块、smtplib模块" class="headerlink" title="互联网访问– urllib.request模块、smtplib模块"></a>互联网访问– urllib.request模块、smtplib模块</h2><p>互联网访问有许多模块，这里的两个最简单的模块， urllib.request 用于从URL检索数据， smtplib 用于发送邮件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> urlopen(<span class="string">&#x27;http://worldtimeapi.org/api/timezone/etc/UTC.txt&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> line <span class="keyword">in</span> response:</span><br><span class="line"><span class="meta">... </span>        line = line.decode()             <span class="comment"># Convert bytes to a str</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;datetime&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(line.rstrip())         <span class="comment"># Remove trailing newline</span></span><br><span class="line">...</span><br><span class="line">datetime: <span class="number">2022</span>-01-01T01:<span class="number">36</span>:<span class="number">47.689215</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.sendmail(<span class="string">&#x27;soothsayer@example.org&#x27;</span>, <span class="string">&#x27;jcaesar@example.org&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&quot;&quot;&quot;To: jcaesar@example.org</span></span><br><span class="line"><span class="string"><span class="meta">... </span>From: soothsayer@example.org</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Beware the Ides of March.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.quit()</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间–-datetime模块"><a href="#日期和时间–-datetime模块" class="headerlink" title="日期和时间– datetime模块"></a>日期和时间– datetime模块</h2><p>datetime模块实现的重点是日期的格式化输出和操作，该模块还支持可感知时区的对象，有效类型有:</p>
<ul>
<li>class datetime.date       简单型日期，属性:year, month, day</li>
<li>class datetime.datetime   日期和时间的结合，属性：year, month, day, hour, minute, second, microsecond, and tzinfo.</li>
<li>class datetime.timedelta  表示两个date对象的时间间隔</li>
<li>class datetime.tzinfo     描述时区信息的抽象基类，用来给datetime时间调整概念</li>
<li>class datetime.timezone   实现了tzinfo的子类，表示相对于世界标准时间UTC的偏移量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 构建date对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = date.today()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.date(<span class="number">2003</span>, <span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.strftime(<span class="string">&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;08-17-22. 17 Aug 2022 is a Wednesday on the 17 day of August.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 支持日历算数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>century21=date(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gotime=now-century21</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gotime, gotime.days</span><br><span class="line">(datetime.timedelta(days=<span class="number">8264</span>), <span class="number">8264</span>)</span><br></pre></td></tr></table></figure>

<h2 id="性能测量–-timeit-Timer模块，-cProfile模块"><a href="#性能测量–-timeit-Timer模块，-cProfile模块" class="headerlink" title="性能测量– timeit.Timer模块， cProfile模块"></a>性能测量– timeit.Timer模块， cProfile模块</h2><h3 id="timeit-Timer模块"><a href="#timeit-Timer模块" class="headerlink" title="timeit.Timer模块"></a>timeit.Timer模块</h3><p>timeit 模块颗粒度小，可以快速演示运行效率:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;t=a; a=b; b=t&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.0754628999857232</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;a,b = b,a&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.0371058000018820</span></span><br></pre></td></tr></table></figure>

<h3 id="cProfile模块"><a href="#cProfile模块" class="headerlink" title="cProfile模块"></a>cProfile模块</h3><p>cProfile 模块颗粒度大，可以识别较大代码块的关键部分:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line">pr = cProfile.Profile()</span><br><span class="line">pr.enable()</span><br><span class="line"><span class="comment"># ... do something ...</span></span><br><span class="line">pr.disable()</span><br><span class="line">pr.print_stats()</span><br></pre></td></tr></table></figure>

<p>使用上下文管理器(即使用 with 关键字):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">with</span> cProfile.Profile() <span class="keyword">as</span> pr:</span><br><span class="line">    <span class="comment"># ... do something ...</span></span><br><span class="line">pr.print_stats()</span><br></pre></td></tr></table></figure>

<h2 id="质量控制–-doctest模块、-unittest模块"><a href="#质量控制–-doctest模块、-unittest模块" class="headerlink" title="质量控制– doctest模块、 unittest模块"></a>质量控制– doctest模块、 unittest模块</h2><h3 id="doctest模块"><a href="#doctest模块" class="headerlink" title="doctest模块"></a>doctest模块</h3><p>doctest 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">values</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算平均值.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(average([20, 30, 70]))</span></span><br><span class="line"><span class="string">    40.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(values) / <span class="built_in">len</span>(values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testmod()   <span class="comment"># 自动验证本所在脚本内嵌的测试</span></span><br></pre></td></tr></table></figure>

<p>在命令行可以使用  $python example.py -v  ，doctest会打印所尝试的详细日志，并打印出总结</p>
<h3 id="unittest模块"><a href="#unittest模块" class="headerlink" title="unittest模块"></a>unittest模块</h3><p>unittest 模块不像 doctest 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试集</p>
<p>此处不详细记录</p>
<h1 id="标准库简介-第二部分"><a href="#标准库简介-第二部分" class="headerlink" title="标准库简介-第二部分"></a>标准库简介-第二部分</h1><h2 id="字符串模板–-string-Template"><a href="#字符串模板–-string-Template" class="headerlink" title="字符串模板– string.Template"></a>字符串模板– string.Template</h2><p>string 模块包含一个通用的 Template 类，允许用户指定自己的字符串模板，这对于大文本来内容来说十分有用</p>
<p>这类格式化操作是通过占位符实现的，占位符有 $ 加上合法的标识符构成,其中 $ 是分隔符(分隔原文和占位符)；占位符后方需要留有空格和原文分开；如果使用花括号包围标识符部分则可以和其他部分无空连接。$$ 将被转义成单个字符 $ 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 变量替换占位符是使用 substitute 和 safe_substitute 方法实现</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=Template(<span class="string">&#x27;$&#123;village&#125;人民捐了$$10给$cause&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># substitute 方法；如果数据不完整则抛出 KeyError</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.substitute(village=<span class="string">&#x27;夏威夷&#x27;</span>,cause=<span class="string">&#x27;卡布奇诺&#x27;</span>)  </span><br><span class="line"><span class="string">&#x27;夏威夷人民捐了$10给卡布奇诺&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># safe_substitute 方法，允许未被替换的数据按占位符原文保留</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.safe_substitute(cause=<span class="string">&#x27;卡布奇诺&#x27;</span>) </span><br><span class="line"><span class="string">&#x27;$&#123;village&#125;人民捐了$10给卡布奇诺&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Template 的子类可以自定义分隔符，即修改 $ 的样式，以配合 input 等函数的使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">BatchRename</span>(<span class="title class_ inherited__">Template</span>):</span><br><span class="line">···     <span class="comment"># 分隔符还可以是符号&#x27;c&#x27;；使用字符&#x27;1&#x27;则不合法</span></span><br><span class="line"><span class="meta">... </span>    delimiter = <span class="string">&#x27;%&#x27;</span> </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 改用 % 来表示占位符；注意这里打印 $ 不再需要转义</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=BatchRename(<span class="string">&#x27;%&#123;village&#125;人民在捐了$10给%&#123;cause&#125;&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.substitute(village=<span class="string">&#x27;夏威夷&#x27;</span>,cause=<span class="string">&#x27;卡布奇诺&#x27;</span>)  </span><br><span class="line"><span class="string">&#x27;夏威夷人民捐了$10给卡布奇诺&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="多线程–-threading模块"><a href="#多线程–-threading模块" class="headerlink" title="多线程– threading模块"></a>多线程– threading模块</h2><p>多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。</p>
<p>暂时不记录</p>
<h2 id="弱引用以跟踪对象–-weakref模块"><a href="#弱引用以跟踪对象–-weakref模块" class="headerlink" title="弱引用以跟踪对象– weakref模块"></a>弱引用以跟踪对象– weakref模块</h2><p>weakref 模块提供的工具可以不必创建引用就能跟踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。</p>
<p>Python会自动进行内存管理，当某个对象的最后一个引用被移除后不久就会释放其所占用的内存；但是，存在需要持续跟踪对象的情况，跟踪它们将会创建一个令其永久化的引用。</p>
<p>这里仅了解一下，待需要时再学习</p>
<h2 id="用于操作列表的工具–-array模块、collections模块、heapq模块"><a href="#用于操作列表的工具–-array模块、collections模块、heapq模块" class="headerlink" title="用于操作列表的工具– array模块、collections模块、heapq模块"></a>用于操作列表的工具– array模块、collections模块、heapq模块</h2><h3 id="array模块"><a href="#array模块" class="headerlink" title="array模块"></a>array模块</h3><p>array 模块提供了一种高效的数值数组 array 对象，类似于列表，但要求存储类型一致，且存贮密集度更高:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 类型码 H 表示以两个字节为存储单元的无符号二进制数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 对于普通列表来说，存储的 int 对象通常要占用16字节</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = array(<span class="string">&#x27;H&#x27;</span>, [<span class="number">4000</span>, <span class="number">10</span>, <span class="number">700</span>, <span class="number">22222</span>]) <span class="comment"># 注意，这里元素的类型不是 int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(a)</span><br><span class="line"><span class="number">26932</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">array(<span class="string">&#x27;H&#x27;</span>, [<span class="number">10</span>, <span class="number">700</span>])</span><br></pre></td></tr></table></figure>
<h3 id="collections-模块"><a href="#collections-模块" class="headerlink" title="collections 模块"></a>collections 模块</h3><p>collections 模块提供了一种双向队列 deque 对象；可以使用列表来初始化 deque 对象。<br>有以下常见方法:</p>
<ul>
<li>append(<em>x</em>), appendletf(<em>x</em>)</li>
<li>pop(), popleft()</li>
<li>extend(<em>iterable</em>), extendleft(<em>iterable</em>)    使用迭代器扩展元素</li>
<li>index(<em>elem[, start[, stop]]</em>)</li>
<li>rotate(<em>n&#x3D;1</em>) 向右循环移动n步；享有循环1步等价于 d.appendleft(d.pop())</li>
<li>其他一般通用的 reverse(), clear(), copy(), count(<em>x</em>)</li>
</ul>
<p>实现队列:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque([<span class="string">&quot;task1&quot;</span>, <span class="string">&quot;task2&quot;</span>, <span class="string">&quot;task3&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.append(<span class="string">&quot;task4&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Handling&quot;</span>, d.popleft())</span><br><span class="line">Handling task1</span><br></pre></td></tr></table></figure>
<p>实现广度优先搜索树(要求结点作为元素):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unsearched = deque([starting_node])     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">breadth_first_search</span>(<span class="params">unsearched</span>):</span><br><span class="line">    node = unsearched.popleft()</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> gen_moves(node):</span><br><span class="line">        <span class="keyword">if</span> is_goal(m):</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        unsearched.append(m)</span><br></pre></td></tr></table></figure>
<h3 id="bisec模块"><a href="#bisec模块" class="headerlink" title="bisec模块"></a>bisec模块</h3><p>bisec 模块使用了基本的二分(bisection)算法，定义了以下函数:</p>
<ul>
<li>bisect.bisect 家族，使用value搜索适合位置，然后返回适合插入元素的位置，value的类型很可能与列表元素不一致<ul>
<li>bisect.bisect(<em>a, value, key&#x3D;None</em>)     倾向于返回等值元素右侧位置，key指向一个比较函数用于提取比较键</li>
<li>bisect.bisect_left(…)    倾向于返回等值元素左侧位置</li>
<li>bisect.bisect_right(…)   倾向于返回等值元素右侧位置</li>
</ul>
</li>
<li>bisect.insort 家族，使用 item 搜索适合位置，然后后插入适合位置，相当于执行 bisec 和 insert；要注意到，这里实际使用的是elem的某个属性值(默认 e[0]，使用key后可以是e[1]或其他属性)<ul>
<li>bisect.insort(<em>a, item, key&#x3D;None</em>)     倾向于插在等值元素右侧</li>
<li>bisect.insort_left(…)   倾向于插在等值元素左侧</li>
<li>bisect.insort_left(…)   倾向于插在等值元素右侧</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">&#x27;red&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">8</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.sort(key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">8</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用 bisect.bisect 函数搜索位置；这里的搜索值要与key函数提取的值可比较</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect(data, <span class="number">7</span>, key=<span class="keyword">lambda</span> t:t[<span class="number">1</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用 bisect.insort 函数搜索后插入位置；里key函数的提值逻辑要求插入值 item 与顺序表元素都能满足，并且提值后可比较</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort_left(data, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), key=<span class="keyword">lambda</span> t:t[<span class="number">1</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="heap模块"><a href="#heap模块" class="headerlink" title="heap模块"></a>heap模块</h3><p>heap 模块提供了堆队列算法的实现，维护的是最小堆<br>堆是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点的值，最小的结点总是在根结点 heap[0]，同时 heap.sort() 维护了堆的不变性</p>
<p>heapq 模块定义了以下函数:</p>
<ul>
<li>heapq.heapify(<em>list</em>)             将list原地转换成堆(线性时间内)；空列表然后进行 heappush 操作也可初始化堆</li>
<li>heapq.heappush(<em>heap, item</em>)      放入item元素并保持堆的不变性</li>
<li>heapq.heappop(<em>heap</em>)             访问并弹出最小元素</li>
<li>heapq.headpushpop(<em>heap.item</em>)    效果等价于先heappush后heappop，但效率更好 </li>
<li>heapq.heapreplace(<em>heap, item</em>)   效果等价于先heappop后heappush，但效率更好</li>
</ul>
<p>堆元素可以为元组，此时元素中第一个属性应该为数值类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">&#x27;编写代码&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">&#x27;发布产品&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">&#x27;编写规范&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">&#x27;创建测试&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;编写规范&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;创建测试&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;编写代码&#x27;</span>), (<span class="number">7</span>, <span class="string">&#x27;发布产品&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="十进制浮点数"><a href="#十进制浮点数" class="headerlink" title="十进制浮点数"></a>十进制浮点数</h2><p>decimal 模块提供了一种 Decimal 数据类型用于十进制浮点运算。相比内置的float，特别适用于:</p>
<ul>
<li>控制精度</li>
<li>控制四舍五入</li>
<li>跟踪有效小数位</li>
<li>手工计算和计算机计算匹配</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python流程控制语法</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>记录python流程控制的语法</p>
<span id="more"></span>


<h1 id="流程控制工具"><a href="#流程控制工具" class="headerlink" title="流程控制工具"></a>流程控制工具</h1><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">Please enter an integer: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;负数&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> :</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;非负&#x27;</span>)</span><br><span class="line">如果要把一个值与多个常量进行比较，或者检查特定类型或属性，match 语句更实用。</span><br></pre></td></tr></table></figure>

<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = &#123;<span class="string">&#x27;Hans&#x27;</span>: <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;Éléonore&#x27;</span>: <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;景太郎&#x27;</span>: <span class="string">&#x27;active&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#若存在修改集合的操作，迭代时应该使用集合的副本进行遍历</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():   </span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;inactive&#x27;</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br></pre></td></tr></table></figure>

<h2 id="range-函数-–-range可以生成list序列，但迭代时返回可迭代对象"><a href="#range-函数-–-range可以生成list序列，但迭代时返回可迭代对象" class="headerlink" title="range() 函数 – range可以生成list序列，但迭代时返回可迭代对象"></a>range() 函数 – range可以生成list序列，但迭代时返回可迭代对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>range可以不从0开始，可以指定步长，以下几种都是range()函数的正确用法:</p>
<ul>
<li>range(10)             # 等价于range(0,10)</li>
<li>range(4,len(list))    # 可以与len结合，但一般enumerate() 函数更便捷</li>
<li>range(1,10,3)  </li>
<li>range(-10,-100,-30)</li>
<li>sum(range(4))         # 0+1+2+3</li>
</ul>
<p>range() 返回对象的操作和列表很像，但其实这两种对象不是一回事。<strong>迭代时</strong>，该对象基于所需序列返回可迭代对象 iterable，函数或程序结构可通过该对象获取连续项，直到所有元素全部迭代完毕。<br>for 语句就是这样的架构，sum() 是一种把可迭代对象作为参数的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 0 + 1 + 2 + 3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="循环中break、continue、else子句"><a href="#循环中break、continue、else子句" class="headerlink" title="循环中break、continue、else子句"></a>循环中break、continue、else子句</h2><p>break、continue借鉴自C，break用于终止本层循环，continue用于跳过本层循环当前迭代。<br>在python中，else除了可以用于if-else，可也用于for-else，在未运行break时执行else子句。<br>（for-else也许没有实用价值）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(n, <span class="string">&#x27;=&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(n, <span class="string">&#x27;is a prime number&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> = <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> = <span class="number">2</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><p>pass 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建了最小的类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyEmptyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#用作函数或条件子句的占位符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initlog</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">pass</span>   </span><br></pre></td></tr></table></figure>

<h2 id="match语句"><a href="#match语句" class="headerlink" title="match语句"></a>match语句</h2><p>match语句的匹配，有字面值模式、变量模式、以及变量解包模式。</p>
<p>变量名 _ 被作为通配符比被匹配成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">case _:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;匹配失败&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>字面值模式中，一个匹配项可以使用 | 或者 or 来组合多个字面值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">case <span class="number">401</span> | <span class="number">403</span> | <span class="number">404</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;不允许访问&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量解包模式，可以嵌套匹配，如匹配列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    x: <span class="built_in">int</span></span><br><span class="line">    y: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">where_is</span>(<span class="params">point</span>):</span><br><span class="line">    match point:</span><br><span class="line">        case Point(x=<span class="number">0</span>, y=<span class="number">0</span>):               <span class="comment">#Point解析，匹配x，y都为0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)               </span><br><span class="line">        case Point(x=<span class="number">0</span>, y=y):               <span class="comment">#Point解析，匹配x==0，捕获并y</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Y=<span class="subst">&#123;y&#125;</span> 这个点在Y轴上&quot;</span>)</span><br><span class="line">        case Point(x=x, y=<span class="number">0</span>):               <span class="comment">#Point解析，捕获x，匹配y==0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;X=<span class="subst">&#123;x&#125;</span> 这个点在X轴上&quot;</span>)</span><br><span class="line">        case Point():                       <span class="comment">#Point解析，匹配Point类型</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;这个点位于平面其他位置&quot;</span>)</span><br><span class="line">        case [Point(<span class="number">0</span>,y1),Point(<span class="number">0</span>,y2)]      <span class="comment">#Point列表解析，y1，y2被赋值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;两点位于Y轴的<span class="subst">&#123;y1&#125;</span>,<span class="subst">&#123;y2&#125;</span>位置&quot;</span>)   </span><br><span class="line">        case _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;不是点类型&quot;</span>)</span><br><span class="line"></span><br><span class="line">location(Point(<span class="number">0</span>,<span class="number">3</span>))    <span class="comment">#输出 &quot;Y=3 这个点在Y轴上&quot;</span></span><br><span class="line">location([Point(<span class="number">0</span>,<span class="number">6</span>),Point(<span class="number">0</span>,<span class="number">7</span>)])    <span class="comment">#输出 &quot;两点位于Y轴的6，7位置&quot;</span></span><br></pre></td></tr></table></figure>

<p>添加守护项if，如果守护项为假，则match继续匹配下一个语句块。值的捕获发生在守护项被求值之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">match point:</span><br><span class="line">    case Point(x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Y=X at <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    case Point(x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;不在斜线上&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其他match特性：<br>    - 元组和列表模式的匹配，但不能匹配迭代器或字符串<br>    - 序列模式支持扩展解包操作<br>    - 映射模式<br>    - 使用as关键字<br>    - 模式使用命名常量enum类型</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):  <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;返回斐波那契数列（文档字符串）&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    result = []</span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        result.append(a)    <span class="comment"># see below</span></span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100 = fib2(<span class="number">100</span>)    <span class="comment"># call it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100                <span class="comment"># write the result</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure>

<p>定义符号作为函数名指向函数对象，解释器把函数名指向的对象作为用户自定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib</span><br><span class="line">&lt;function fib at 10042ed0&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">100</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>

<h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><p>while 和 if 的条件句可以配合以下运算符使用:</p>
<ul>
<li>in 、 not in      执行成员检测，确定一个对象是否存在于某个容器内</li>
<li>is 、 is not      用来比较两个对象是否是同一个对象</li>
<li>and 、 or         </li>
<li>:&#x3D;                海象运算符，在表达式内部赋值使用；这和C不同</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python虚拟环境和包管理</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>记录python虚拟环境的使用过程，和包管理的方法</p>
<span id="more"></span>

<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><p>用于创建和管理虚拟环境的模块称为 venv； venv 通常会安装你可用的最新版本的 Python，可以通过运行 python3 或您想要的任何版本来选择特定的Python版本。</p>
<p><strong>创建</strong>虚拟环境:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m venv tutorial-env </span><br></pre></td></tr></table></figure>
<p>创建 tutorial-env 目录，并在其中创建包含 Python 解释器副本和各种支持文件的目录。</p>
<p>创建好虚拟环境后，虚拟环境目录会产生一个激活脚本，执行它即可<strong>激活</strong>这个环境。激活操作会改变终端的提示符，之后的所有操作都是在虚拟环境中操作，包括包的安装卸载等<br>windows下，运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tutorial-env\Scripts\activate.bat</span><br></pre></td></tr></table></figure>
<p>Unix或MacOS下，运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> tutorial-env/bin/activate</span><br></pre></td></tr></table></figure>

<p>使用 sys.path 可查看相关信息</p>
<h1 id="使用pip管理包"><a href="#使用pip管理包" class="headerlink" title="使用pip管理包"></a>使用pip管理包</h1><p>从python3.4开始，pip内置在python中，是首选的包管理工具</p>
<h2 id="包的安装与管理"><a href="#包的安装与管理" class="headerlink" title="包的安装与管理"></a>包的安装与管理</h2><p>默认情况下 pip 将从 Python Package Index <a href="https://pypi.org/">https://pypi.org</a> 安装软件包。pip 有许多子命令:”install”,”uninstall”,”upgrade”,”freeze”等。安装过程中常常是使用 -m 参数，文档中解释为<sapn style="background-color:grey"> -m mod : run library modules as a script(terminates option list) </span>，其中括号内注释表示这是一个终极选项，之后的选项将不起作用。</p>
<p>指安装指定名称的包，可额外指定版本，如果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install novas  #默认安装最新版本</span><br><span class="line">(tutorial-env) $ python -m pip install requests==2.6.0  #额外指定安装版本</span><br><span class="line">(tutorial-env) $ python -m pip install requests&gt;=2.6.0  #额外指定最低安装版本</span><br></pre></td></tr></table></figure>

<p>更新到最新版本，其中参数可以为 –upgrade 或 -U:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install --upgrade requests</span><br></pre></td></tr></table></figure>

<p>卸载一个或多个包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip uninstall requests</span><br></pre></td></tr></table></figure>

<p>显示有关特定包的信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ pip show requests</span><br></pre></td></tr></table></figure>

<p>如在显示当前环境中（可能是虚拟环境），已安装的所有软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ pip list</span><br></pre></td></tr></table></figure>

<p>以上的命令都可把 python -m pip &lt;commond&gt; [options] 替换为 pip &lt;commond&gt; [options]</p>
<h2 id="生成包版本的控制文件"><a href="#生成包版本的控制文件" class="headerlink" title="生成包版本的控制文件"></a>生成包版本的控制文件</h2><p>python包的版本控制使用pip freeze生成一个名为 requirements.txt 的描述文件（文件名可修改），这个描述文件应该作为应用的一部分被提供</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>使用 pip install -r requirements.txt 自动安装描述文件中的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(tutorial-env) $ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python输入输出基本</title>
    <url>/2023/02/05/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%9F%BA%E6%9C%AC/</url>
    <content><![CDATA[<p>记录python基本的输入输出</p>
<span id="more"></span>


<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="把值变为字符串"><a href="#把值变为字符串" class="headerlink" title="把值变为字符串"></a>把值变为字符串</h2><p>repr() 和 str() 函数把<strong>值转变为字符串</strong>。repr() 生成的字符串会让转义字符以可见形式转变为字符串，更便于调试；而str() 函数则是按转义后的意思变为字符串。这里建议舍弃它们的格式化字符串的作用，专注于下面两个格式化方法</p>
<p>repr 的使用示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hellos = <span class="built_in">repr</span>(<span class="string">&#x27;hello, world\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(hellos)</span><br><span class="line"><span class="string">&#x27;hello, world\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化字符串字面值-推荐"><a href="#格式化字符串字面值-推荐" class="headerlink" title="格式化字符串字面值(推荐)"></a>格式化字符串字面值(推荐)</h2><p>格式化字符串字面值(简称 f-字符串)在字符串前加前缀 f 或 F，通过花括号写入包含格式的变量。<br>常见的几个表达式格式控制:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 在冒号后面指定“宽度”、点、小数位数、变量类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;pi的值大约是 <span class="subst">&#123;math.pi:<span class="number">.3</span>f&#125;</span>.&#x27;</span>)</span><br><span class="line">pi的值大约是 <span class="number">3.142</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 一些修饰符可以在格式化前转换值</span></span><br><span class="line"><span class="meta">... </span><span class="comment"># &#x27;!a&#x27; 应用 ascii() ，&#x27;!s&#x27; 应用 str()，&#x27;!r&#x27; 应用 repr()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = <span class="string">&#x27;rabbit&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;兔子的英文是 <span class="subst">&#123;animals&#125;</span>.&#x27;</span>)</span><br><span class="line">兔子的英文是 rabbit.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;兔子的英文是 <span class="subst">&#123;animals!r&#125;</span>.&#x27;</span>)</span><br><span class="line">兔子的英文是 <span class="string">&#x27;rabbit&#x27;</span>.</span><br></pre></td></tr></table></figure>

<h2 id="字符串format方法"><a href="#字符串format方法" class="headerlink" title="字符串format方法"></a>字符串format方法</h2><p>常见 str.format 方法的参数使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用空内容花括号占位，按序传递参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫 &#123;&#125; ，小名 &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;IceCocoa&#x27;</span>, <span class="string">&#x27;Cocoa&#x27;</span>))</span><br><span class="line"><span class="comment"># 在花括号内添加数字，指定参数顺序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125; and &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)) </span><br><span class="line"><span class="comment"># 在花括号内添加关键字，使用关键字引用参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;This &#123;food&#125; is &#123;adjective&#125;.&#x27;</span>.<span class="built_in">format</span>(food=<span class="string">&#x27;banana&#x27;</span>, adjective=<span class="string">&#x27;delicious&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>位置参数和关键字参数可以任意组合，它们也可以在字符串中多次出现。</p>
<p>包含字典类型参数的 str.format 方法使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Sjoerd&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;Jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;Dcab&#x27;</span>: <span class="number">8637678</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 传递字典可以使用 &#123;位置参数[关键字]:格式&#125; 来引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; Dcab: &#123;0[Dcab]:d&#125;&#x27;</span>.<span class="built_in">format</span>(table))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 可以使用 **dic 解包一个字典类型，引用时仅需要 &#123;关键字:格式&#125;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;&#x27;</span>.<span class="built_in">format</span>(**table))</span><br></pre></td></tr></table></figure>



<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="打开文件函数open"><a href="#打开文件函数open" class="headerlink" title="打开文件函数open"></a>打开文件函数open</h2><p>open 函数返回一个 file object:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>打开文件的模式一般有:</p>
<ul>
<li>r,  rb        只读，这是默认模式</li>
<li>w,  wb        只写，以覆盖原文件方式</li>
<li>a,  ab        追加写</li>
<li>r+, rb+       读写</li>
<li>a+, ab+       读和追加写</li>
</ul>
<p>后面加b的版本以二进制模式打开文件，以 bytes 对象的形式读写，此时不能指定 encoding</p>
<p>在文本模式下读取文件时，默认把平台特定的行结束符（Unix 上为 \n, Windows 上为 \r\n）转换为 \n。在文本模式下写入数据时，默认把 \n 转换回平台特定结束符。</p>
<p>行结束符的转换不会影响文本文件，但是会破坏 JPEG 或 EXE 等二进制文件数据，读写非文本文件一定要使用二进制模式。</p>
<h2 id="使用with关键字健壮地打开和关闭文件"><a href="#使用with关键字健壮地打开和关闭文件" class="headerlink" title="使用with关键字健壮地打开和关闭文件"></a>使用with关键字健壮地打开和关闭文件</h2><p>打开文件时使用 with 关键字，句子结束后，文件会正确关闭或触发异常；如果没有使用with关键字，必须使用 f.close() 来关闭文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 检验文件是否自动关闭</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h2><p>假定已经使用 f &#x3D; open(‘workfile’, ‘w’, encoding&#x3D;”utf-8”) 创建好了文件对象，则有以下方法:</p>
<ul>
<li>f.read([<em>size</em>])，如果省略size或size为负，则读取全部文件，否则返回size个字符或字节，这根据打开方式是否为二进制确定是字符或字节。到达文件末尾返回’’</li>
<li>f.readline()，此外可以使用迭代方法实现读取每一行 for line in f</li>
<li>f.write(<em>string</em>)， 文本模式以字符串类型为参数。如果是二进制模式，则参数要是字节对象。它返回成功写入字符（字节）数量</li>
<li>f.tell()， 返回二进制模式下以字节数计数的当前位置；这个返回值对于文本模式没有意义</li>
<li>f.seek(offset, whence)</li>
</ul>
<h2 id="改变文件对象位置-f-seek-offset-whence"><a href="#改变文件对象位置-f-seek-offset-whence" class="headerlink" title="改变文件对象位置 f.seek(offset, whence)"></a>改变文件对象位置 f.seek(<em>offset, whence</em>)</h2><p>参数 whence 表示从哪里开始，默认是0表示文件开头，1表示文件当前位置，2表示文件末尾；如果是文本模式只能使用0，或直接定位定位到文件末尾seek(0,2)。参数 offset 以参考点为基准偏移的<strong>字节数</strong>，由此可知 seek 一般用于二进制模式打开的文件，除非记录过文本模式下的t.tell()。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, <span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b&#x27;0123456789abcdef&#x27;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(-<span class="number">3</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)       </span><br><span class="line"><span class="string">b&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用json保存结构化数据"><a href="#使用json保存结构化数据" class="headerlink" title="使用json保存结构化数据"></a>使用json保存结构化数据</h2><p>把python数据层次结构转换为字符串表示形式，这个过程称为序列化(serializing)；从字符串形式重建为数据，称为解序化(deserializing)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">x = [<span class="number">1</span>, <span class="string">&#x27;simple&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"><span class="comment">#json.dumps函数，序列化一个python数据层次结构为json格式的字符串</span></span><br><span class="line">j = json.dumps(x)       </span><br><span class="line"><span class="string">&#x27;[1, &quot;simple&quot;, &quot;list&quot;]&#x27;</span></span><br><span class="line"><span class="comment">#json.loads函数，解序列化一个json格式字符串为python数据层次结构</span></span><br><span class="line">y = json.loads(j)          </span><br></pre></td></tr></table></figure>

<p>dumps() 还有用于转储文件的变体，dump()方法，用于json文档的序列化和解序列化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump(x, f)     </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.load(f)        </span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Headless Chrome了解学习</title>
    <url>/2023/02/02/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Selenium/Headless%20Chrome%E4%BA%86%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>了解浏览器无头模式，提高UI测试性能和泛用性</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>学习</category>
        <category>测试工具</category>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习五：git工具</title>
    <url>/2023/01/29/%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0%E4%BA%94%EF%BC%9Agit%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>参考 <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p>
<span id="more"></span>

<h1 id="检索提交"><a href="#检索提交" class="headerlink" title="检索提交"></a>检索提交</h1><p>找到某些特定的提交是很多git操作的前提，git检索提交的方法分为单个提交检索和一定范围内提交检索。</p>
<h2 id="检索单个提交"><a href="#检索单个提交" class="headerlink" title="检索单个提交"></a>检索单个提交</h2><p>第一种方法是，指定提交对象的<strong>哈希值</strong>检索。用来检索的可以是哈希值的前几个字符，这几个字符要求数量不小于4，且没有歧义。如 git show 1c002 可以显示这个对应提交的信息</p>
<p>第二种方法是，指定提交对象的<strong>分支名</strong>。当前这种方法成功的前提是被检索提交正好处于一个分支的顶端，即是这个分支的最新提交（分支名本身引用的即是本分支的最新提交）</p>
<p>第三种方法是，根据<strong>HEAD历史指向</strong>指定分支。当在本地仓库工作时，git会在后台保存一个引用日志reflog，引用日志会记录最近几个月本地仓库HEAD指向的提交，使用 git reflog 命令会输出多行形如 <scan style="background:#eee">2c9027f (tag: v1.0) HEAD@{11}: checkout: moving from master to version1.0 </scan> 的结果，使用 HEAD@{11} 即可引用这个分支。在这里 HEAD@{n} 表示的意思是HEAD在五次前所指向的提交，HEAD@{0}则表示当前HEAD指向的提交</p>
<p>第四种方法是，根据<strong>引用的祖先</strong>来指定分支，这个引用可以是哈希值、分支名、HEAD。如HEAD^ 表示当前分支的第一父提交，HEAD^n 表示当前分支的第n父提交。HEAD~ 表示当前分支的第一父提交，HEAD<del>n 表示第一父提交的n级第一父提交，如HEAD</del>2表示第一父提交的第一父提交</p>
<h2 id="检索提交区间"><a href="#检索提交区间" class="headerlink" title="检索提交区间"></a>检索提交区间</h2><p>假设有如下提交历史：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A &lt;---- B &lt;---- E &lt;---- F &lt;----&quot;master&quot;</span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">        +------ C &lt;---- D &lt;----&quot;experiment&quot;</span><br></pre></td></tr></table></figure>

<p>最常用的指明提交区间语法是<strong>双点</strong>，让git指出在一个分支而不在另一方个分支中的提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> master..experiment</span></span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>这条命令指出在experiment中还未合入master的提交</p>
<p>还可以查看远端内容和本地仓库的进度情况。下面的命令指出在HEAD所指的本地分支中还未合入远程master的提交，如果执行git push且当前分支正在追踪origin&#x2F;master，这个命令输出的提交就是会传输到服务器的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> origin/master..HEAD</span></span><br></pre></td></tr></table></figure>


<p><strong>多点</strong>语法可以很容易实现包含某些引用，且不包含另外一些引用的提交，下面的命令查询包含在refA和refB的提交，但不包含refC的提交，其中 –not refC可用 ^refC等效替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refA  refB --not refC</span></span><br></pre></td></tr></table></figure>

<p><strong>三点</strong>语法则直接表示两个引用中，不同时包含的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> master...experiment</span></span><br><span class="line">F</span><br><span class="line">E</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h1 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h1><h2 id="贮藏工作"><a href="#贮藏工作" class="headerlink" title="贮藏工作"></a>贮藏工作</h2><p>贮藏的应用场景时，在当前分支做了某些修改，然后需要切换到另一个分支，但是又不想提交刚才的修改，此时需要贮藏工作目录的修改内容。贮藏可以保存当前工作目录的修改和暂存，然后把工作目录复原成HEAD指向的提交，需要注意未追踪文件不会被贮藏，也不会在复原HEAD指向的提交时移除。git stash 命令保存了当前工作目录的状态，然后放到贮藏栈：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash</span></span><br><span class="line">Saved working directory and index state WIP on master: 252a6ae Merge branch &#x27;version1.0&#x27;</span><br><span class="line"></span><br><span class="line">Saved working directory and index state WIP on master: 252a6ae Merge branch &#x27;version1.0&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过贮藏的工作目录是干净的。此时可以切换分支并继续在其他分支上工作，查看贮藏栈内容使用命令 git stash list：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 252a6ae Merge branch &#x27;version1.0&#x27;</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 049d078 added the index file</span><br></pre></td></tr></table></figure>

<p><strong>应用贮藏</strong>使用命令git stash apply，这个命令会应用最近一次的贮藏，或者使用 git stash apply stash@{0} 应用某个贮藏。这样应用贮藏会把原先在暂存区的内容打回到已修改状态，若想连暂存区的状态也复原，需要加上 –index选项</p>
<p><strong>抛弃贮藏</strong>使用命令git stash drop stash@{n}</p>
<p><strong>贮藏未追踪的文件</strong>。默认情况下git stash只会贮藏和修改已追踪文件，如果想要贮藏未追踪文件需要添加选项 –include-untracked 或 -u 选项。此时贮藏中包含未追踪文件，但仍不会明确包含忽略文件，加上 –all 或 -a 选项会贮藏包括未追踪和忽略的文件。</p>
<h2 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h2><p>清理工作目录的命令git clean是危险的，比较安全的是，使用 git stash –all来替代它，这至少会留有一个“备份”。对于 git clean不再多述。</p>
<h1 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h1><h2 id="介绍和准备工作"><a href="#介绍和准备工作" class="headerlink" title="介绍和准备工作"></a>介绍和准备工作</h2><p>git是密码级安全的，但并非万无一失。git提供几种通过GPG来签署和验证工作的方式。GPG预装于Windows版本的git内，可以直接在git bash中使用</p>
<p>如果没有密钥，可以使用以下命令生成一个个人密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure>

<p>查看当前已有的个人密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br></pre></td></tr></table></figure>

<p>一旦有了可以用用来签署的私钥，就可通过git设置，来配置默认使用密钥签署标签和提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.signingkey &lt;私钥<span class="built_in">id</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>目前在这里的实践存在问题，存在输出内容和文档不符合，也无法继续走下去。避免后续git使用受到影响，也不敢大胆尝试配置密钥</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="Grep搜索"><a href="#Grep搜索" class="headerlink" title="Grep搜索"></a>Grep搜索</h2><p>git内置grep命令。这里不记述grep</p>
<h2 id="日志搜索"><a href="#日志搜索" class="headerlink" title="日志搜索"></a>日志搜索</h2><p>日志搜索注重于“什么时候引入”</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>识志琼有感</title>
    <url>/2023/01/25/%E9%98%85%E8%AF%BB/%E8%AF%86%E5%BF%97%E7%90%BC%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>在原神层岩巨渊系列任务，与角色志琼交互，有感于她的行为和品质，又偶然读得《子路宿于石门》，两者皆有感触。</p>
<span id="more"></span>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>明确辨识志琼这个角色的起因，源于探索岩层岩巨渊。那时刚进下面，地图一片黑，啥都摸不到，然后志琼和我聊天，表示她绘制了一份地图，然后我的地图里便敞亮了一番。志琼绘制地图并不是由我带着。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>非对称加密RSA、DSA、ECDSA</title>
    <url>/2023/01/15/%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA%E3%80%81DSA%E3%80%81ECDSA/</url>
    <content><![CDATA[<p>简单学习一下几个常用的非对称加密原理</p>
<span id="more"></span>


<h1 id="RSA算法简介"><a href="#RSA算法简介" class="headerlink" title="RSA算法简介"></a>RSA算法简介</h1><p>RSA算法基于大数分解问题。根据数论，寻求两个大素数比较简单，而将他们的乘积公开却极其困难，因此可以将乘积公开作为加密密钥。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户权限管理</title>
    <url>/2023/01/10/%E5%AD%A6%E4%B9%A0/Linux%E7%9B%B8%E5%85%B3/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>平时使用搭搭游戏服务器也经常碰到权限管理的问题，所以尽早整理比较好</p>
<span id="more"></span>










]]></content>
      <categories>
        <category>学习</category>
        <category>Linux相关</category>
      </categories>
  </entry>
  <entry>
    <title>git学习四：服务器上的git</title>
    <url>/2023/01/10/%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0%E5%9B%9B%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84git/</url>
    <content><![CDATA[<p>这篇文章主要参考文档，记录配置git服务器的过程，以及其他和服务器git交互的知识</p>
<p>参考 <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p>
<span id="more"></span>

<h1 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h1><p>架设一台Git服务器，首先需要选择通讯协议。本文的搭建服务器时混合使用智能HTTP协议和SSH协议。</p>
<p>Git可以使用四种不同的协议来传输资料：本地协议、智能和哑HTTP协议、SSH协议、Git协议。其中本地协议常见于团队成员对一个共享的文件系统都拥有访问权限，但适用范围不够广泛，故不讲述。其中Git协议的适用范围比较狭窄，且需要配置专门的守护进程，故也不讲述。</p>
<p><strong>智能HTTP协议</strong>应该是最流行的Git通讯方式，它在匿名克隆时最方便。智能HTTP协议运行在标准的HTTP&#x2F;S端口上，并且可以使用各种HTTP验证机制，如用户名密码授权机制，这意味着比SSH协议方便许多。智能HTTP协议既支持设置匿名服务，也支持传输时加密和授权，且只用一个URL就可以做到。但是这需要另外设置一个web服务器，这也许是不方便的。</p>
<p><strong>SSH协议</strong>普遍作为Git服务器的传输协议，假设相对简单，它的守护进程十分常见，常见的云服务器都初始带有SSH连接的守护程序。唯一的缺点是不支持匿名访问，因此只有在作为开发人员时才使用SSH协议</p>
<h1 id="在服务器上搭建Git"><a href="#在服务器上搭建Git" class="headerlink" title="在服务器上搭建Git"></a>在服务器上搭建Git</h1><h2 id="准备好裸仓库"><a href="#准备好裸仓库" class="headerlink" title="准备好裸仓库"></a>准备好裸仓库</h2><p>假设Git服务器前，需要把现有仓库导出为裸仓库，即一个不包含当前工作目录的仓库，也可以说是直接把 .git 文件夹复制出来。使用带–bare选项的克隆命令，导出一个仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare my_repo my_repo.git</span></span><br></pre></td></tr></table></figure>

<h2 id="把裸仓库放到服务器上"><a href="#把裸仓库放到服务器上" class="headerlink" title="把裸仓库放到服务器上"></a>把裸仓库放到服务器上</h2><p>既然已经有了裸仓库的副本，那么就剩下放到服务器上了。假设一个git服务器已经假设好，并可以通过SSH连接，想把所有的仓库放到 &#x2F;srv&#x2F;git 目录下，那么可以使用以下命令把裸仓库复制到服务器上。其中git.example.com为服务器名，scp表示secure copy：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp -r my_repo.git user@git.example.com:/srv/git</span></span><br></pre></td></tr></table></figure>

<p>之后，其他可以通过SSH读取此服务器上 &#x2F;srv&#x2F;git 的用户可以执行以下命令来克隆仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> user@git.example.com:/srv/git/my_repo.git</span></span><br></pre></td></tr></table></figure>

<p>如果一个用户通过SSH连接到服务器，并且对 &#x2F;srv&#x2F;git&#x2F; 目录拥有写权限，那么该用户自动拥有推送权限。</p>
<h1 id="SSH协议访问仓库的两种方式"><a href="#SSH协议访问仓库的两种方式" class="headerlink" title="SSH协议访问仓库的两种方式"></a>SSH协议访问仓库的两种方式</h1><p>由上节可见，根据现有的Git仓库创建一个裸仓库，然后把它放到协作者有SSH访问权限的服务器，就能够按照服务器上的用户权限去“管理”用户。</p>
<p>但是，如果要新增一个用户，就在服务器上运行adduser一次，这是有些麻烦的。另外一种SSH连接方法是，在服务器上建立一个git用户，让每个需要写权限的人发送一个SSH公钥加入git账户的 ~&#x2F;.ssh&#x2F;authorized_keys 文件，这样所有人通过git账户访问主机，而访问主机的身份也不会影响提交对象的提交者信息</p>
<h2 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h2><p>用户的SSH密钥存在其 <del>&#x2F;.ssh 目录下，在windows平台下也适用（</del> 表示用户目录），该目录下id_ras.pub是公钥，id_rsa是对应的私钥。使用 ssh-keygen 程序默认创建一对rsa算法的密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>输入这个命令后，会给出提示确认密钥存储的位置，默认是 ~&#x2F;.ssh&#x2F;id_rsa ，然后会要求输入两次密钥口令。这里-t指定ssh算法类型，-b指定密码的位长度，-C提供一个新注释（这个注释会自动添加到公钥末尾，没有改参数则会自动生成一个注释），这三个参数都不是必须的，但是推荐有。</p>
<p>当前github推荐的加密算法是 Ed25519，使用如下命令生成一组密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>无论是rsa算法还是Ed25519，此时在 ~&#x2F;.ssh 文件夹里都会有一对密钥。</p>
<h2 id="配置服务端SSH访问"><a href="#配置服务端SSH访问" class="headerlink" title="配置服务端SSH访问"></a>配置服务端SSH访问</h2><p>这里使用的方法是，创建一个操作系统用户git，为其建立一个.ssh目录，把协作者的密钥加入到认证文件authorized_keys中。</p>
<p>首先创建一个操作系统用户git，为其建立一个.ssh目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo adduser git</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> .ssh &amp;&amp; <span class="built_in">chmod</span> 700 .ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> .ssh/authorized_keys &amp;&amp; <span class="built_in">chmod</span> 600 .ssh/authorized_keys  <span class="comment">#在这里，touch作用是，如果不存在该文件则创建自动创建</span></span></span><br></pre></td></tr></table></figure>

<p>把协作者的密钥加入到系统用户git的 ~&#x2F;.ssh&#x2F;authorized_keys 文件末尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>现在借助带–bare选项的git init创建一个空仓库，该命令在初始化仓库时不会创建工作目录。注意，每添加一个仓库，都需要创建一个裸仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /srv/git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init --bare</span></span><br></pre></td></tr></table></figure>

<p>此时添加过公钥的项目协作者们可以把此仓库设置为远程，并推送分支。下面演示一个协作者把本地分支推送到服务器上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add orgin git@gitserver:/srv/git/project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>

<p>所有获得授权的协作者，都能以系统用户git的身份登录，从而获得一个普通的shell。如果要对此限制，则需要修改git用户对应的 &#x2F;etc&#x2F;passwd 文件中的shell值。可以借助git-shell的受限shell工具来指定登录git账户获得的shell，此时把git-shell的完整路径名添加到 &#x2F;etc&#x2F;shells 文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shells   <span class="comment">#查看git-shell完整路径是否已写入</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> git-shell   <span class="comment">#确保git-shell已安装在系统上</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo -e /etc/shells  <span class="comment">#保存当前环境变量，以便sudo后仍可以使用</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo chsh git -s $(<span class="built_in">which</span> git-shell)</span></span><br></pre></td></tr></table></figure>

<p>此时，用户git只能利用SSH连接进行仓库的拉取和推送，无法登录机器获得一个普通的shell。如果试图登录，尝试会被拒绝。但现在用户仍然可以通过SSH端口转发来访问任何可达的git服务器（除了本来预计访问的git服务器，其他可达的git服务器也可被访问），这时可在想要限制的公钥之前添加 no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty 这些选项即可</p>
<h1 id="使用GitLab搭建服务器"><a href="#使用GitLab搭建服务器" class="headerlink" title="使用GitLab搭建服务器"></a>使用GitLab搭建服务器</h1><p>若要使用智能HTTP协议，可以借助git自带一个CGI脚本，但是使用需要配置一个web服务器，这是不方便的。这里建议的是使用现代化的GitLab服务器，使用GitLab可以更方便的使用SSH和HTTPS访问仓库</p>
<p>GitLab是一个数据库支持的Web应用，安装过程中涉及更多的东西。可以参考<a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master">GitLab社区版</a>的readme文件，由于目前没有需要所以不在这里记录</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/01/10/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/%E9%A5%A5%E8%8D%92%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>偶读《山中与裴秀才迪书》</title>
    <url>/2023/01/09/%E9%98%85%E8%AF%BB/%E5%81%B6%E8%AF%BB%E3%80%8A%E5%B1%B1%E4%B8%AD%E4%B8%8E%E8%A3%B4%E7%A7%80%E6%89%8D%E8%BF%AA%E4%B9%A6%E3%80%8B/</url>
    <content><![CDATA[<p>这日无聊，偶然看到百度热搜“春山可望”，就点进去，发现第二条结果便是这篇文章</p>
<span id="more"></span>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><strong>山中与裴秀才迪书</strong></p>
<p>【作者】王维 【朝代】唐</p>
<p>近腊月下，景气和畅，故山殊可过。足下方温经，猥不敢相烦，辄便往山中，憩感配寺，与山僧饭讫而去。</p>
<p>北涉玄灞，清月映郭。夜登华子冈，辋水沦涟，与月上下。寒山远火，明灭林外。深巷寒犬，吠声如豹。村墟夜舂，复与疏钟相间。此时独坐，僮仆静默，多思曩昔，携手赋诗，步仄径，临清流也。</p>
<p>当待春中，草木蔓发，春山可望，轻鲦出水，白鸥矫翼，露湿青皋，麦陇朝雊，斯之不远，倘能从我游乎？非子天机清妙者，岂能以此不急之务相邀。然是中有深趣矣！无忽。因驮黄檗人往，不一，山中人王维白。</p>
<h1 id="有感"><a href="#有感" class="headerlink" title="有感"></a>有感</h1><p>这几日无聊，到处找人聊天解闷，也发现自己心性浮躁起来，好久没有静下心写些啥东西，和自己内心交流一下。想起以前写日记的时候，字写下来确实有十分充实的感觉，这和打游戏之类的刺激完全不同，也和听音乐过一会就消失的满足感不同。我既不喜欢在网络上发表动态，也不喜欢拍照留念，只有真正愿意回顾的我才愿意拍照。我也不喜欢和别人交心互动，因为我知道别人想法必然与我不同，平时出去玩耍吃饭唱歌玩游戏都很开心，但也确实无法交心。这样下来，反倒自己给自己写日记，说些话，倒是十分满足。</p>
<p>上面这段话，是我看到《山中与裴秀才迪书》原文后，感觉心里清澈不少，然后回顾以往心境的一些理解。不得不说这些古文的神奇，苏轼评王维“诗中有画，画中有诗”，除了看到文章中的风景，我也感觉到了他们平静的内心，这或许是一种闲适感受自然的从容吧。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>git学习三：分支管理</title>
    <url>/2023/01/03/%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0%E4%B8%89%EF%BC%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>这篇文章主要以客户端角度，记录分支管理的方式。远程分支的部分过段时间整理</p>
<p>参考 <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p>
<span id="more"></span>

<h1 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h1><h2 id="理解提交"><a href="#理解提交" class="headerlink" title="理解提交"></a>理解提交</h2><p>回顾《git配置和记录更新》一章的内容，git保存的不是文件的差异，而是一系列快照。</p>
<p>进行提交操作时，git保存一个提交对象。初次提交时产生的提交对象，大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           98ca1                           21ec1</span><br><span class="line">------------------------------     ------------------------</span><br><span class="line">|      commit  &lt;size&gt;        |     |   tree &lt;size&gt;        |</span><br><span class="line">|        tree  21ec1  -------|---&gt; |   blob 5b1d3 README  |</span><br><span class="line">|      parent                |     |   blob 911e7 LICENSE |</span><br><span class="line">|      author  cocoa         |     |   blob cab10 test    |</span><br><span class="line">|   committer  cocoa         |     |               |      |</span><br><span class="line">| The initial commit of repo |     ----------------|-------</span><br><span class="line">------------------------------                     |    </span><br><span class="line">                                                   |     </span><br><span class="line">                                                   v     </span><br><span class="line">                                           cab10</span><br><span class="line">                                   ------------------------</span><br><span class="line">                                   |   blob &lt;size&gt;        |</span><br><span class="line">                                   |                      |</span><br><span class="line">                                   | int main()&#123;...&#125;      |</span><br><span class="line">                                   ------------------------</span><br></pre></td></tr></table></figure>

<h2 id="理解分支"><a href="#理解分支" class="headerlink" title="理解分支"></a>理解分支</h2><p>之后每次提交，都会产生一个提交对象，它包含指向上次提交对象的指针。一个版本的多个新提交不会互相影响，这也是可以创建分支的原因。而分支的本质，是一个指向提交对象的指针，如果在这个分支下，这个指针会随着新提交的产生而移动到新提交上。两个指向同一个版本的分支，只有所处分支的指针会随提交而移动，其他分支的指针不会移动。</p>
<p>git分支实体是包含所指提交对象校验和（长度为40的SHA-1值字符串）的文件，创建一个新分支就相当于向文件写入41个字节（40个字符和1个换行符）</p>
<h2 id="理解HEAD"><a href="#理解HEAD" class="headerlink" title="理解HEAD"></a>理解HEAD</h2><p>其中master分支并不是一个特殊的分支，只是因为git init命令默认创建它。HEAD是对当前所处分支的引用，它表示当前工作目录所在版本，移动HEAD就会改变工作目录的版本。每次提交都是在HEAD指向的版本后，创建新的提交对象，然后HEAD会移动到这个新版本上。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建、删除分支–git-branch-d-xxx"><a href="#创建、删除分支–git-branch-d-xxx" class="headerlink" title="创建、删除分支–git branch [-d] xxx"></a>创建、删除分支–git branch [-d] xxx</h2><p>基于“分支是指向一个提交对象的指针”的理解，可知创建分支并不需要复制文件本体，它只是创建了一个可以移动的新指针。比如创建一个新分支v2-branch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch v2-branch</span></span><br></pre></td></tr></table></figure>
<p>此时创建了一个名为 v2-branch 的分支，以及其表示的指针，这个指针会默认指向当前版本</p>
<p>删除分支时，需要添加参数-d，删除分支的本质是删除一个指针文件，不会影响到任何提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d v2-branch</span></span><br></pre></td></tr></table></figure>
<p>对于未合并分支，git还提供了保险机制，需要添加-D选项才允许删除</p>
<h2 id="（自动创建并）切换分支–git-chekout-b-xxx"><a href="#（自动创建并）切换分支–git-chekout-b-xxx" class="headerlink" title="（自动创建并）切换分支–git chekout [-b] xxx"></a>（自动创建并）切换分支–git chekout [-b] xxx</h2><p>要切换到一个已存在的分支，要使用git checkout命令。切换分支会改变HEAD的指向，HEAD表示的是当前工作目录所处分支，改变了HEAD的指向会改变了工作目录的版本。如果git不能干净利落地完成任务，则会禁止切换分支（<strong>什么时候会这样？已知未追踪、已修改、已暂存文件的存在都不会影响切换分支</strong>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br></pre></td></tr></table></figure>

<p>此外，如果加上-b参数，会自动创建这个分支，然后切换过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b issu31</span></span><br></pre></td></tr></table></figure>

<h2 id="合并分支–git-merge-xxx"><a href="#合并分支–git-merge-xxx" class="headerlink" title="合并分支–git merge xxx"></a>合并分支–git merge xxx</h2><p>合并分分之前，需要切回“主”分支，合并后的新版本会接在“主”分支之后，“主”分支指针也会向后移动，而被合入的分支版本不会改变</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout version1.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge version1.0_fix</span></span><br></pre></td></tr></table></figure>
<p>这时分支version1.0链上有了新的提交对象，且它分支指针移动到新提交对象上；而分支version1.0_fix不会有任何变化</p>
<p>特殊地，被合分支是“主”分支的直接后继，那么“主”分支指针会直接移动到后继分支上（这和上面的情况并不矛盾），这称为快进（Fast-forward）</p>
<h2 id="合并时遇到冲突"><a href="#合并时遇到冲突" class="headerlink" title="合并时遇到冲突"></a>合并时遇到冲突</h2><p>有时候在待合并的两个分支中，对同一个文件的同一部分进行了不同的修改，这时合并（git merge xxx）就会产生合并冲突。此时git会暂停下来，可合并内容已合并完成，而冲突文件都会标识出来，等待用户去解决。</p>
<p>此时，工作目录内，那个冲突文件的内容会变成：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">（每行前加了一个制表符，避免下面内容被编辑器解析成冲突）</span><br><span class="line"></span><br><span class="line">asd</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">my changes on master</span><br><span class="line">=======</span><br><span class="line">my changes on version1.0</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; version1.0</span><br></pre></td></tr></table></figure>
<p>这时候需要用户手动调整这个冲突文件的内容，然后暂存、提交。如果不修改冲突文件就暂存，则该文件会保存冲突原文内容（即上面展示的内容）暂存，且之后不再被认定为冲突。</p>
<h2 id="查看分支–git-branch操作集"><a href="#查看分支–git-branch操作集" class="headerlink" title="查看分支–git branch操作集"></a>查看分支–git branch操作集</h2><p>git branch除了可以创建分支、删除分支， 在不加其他参数的情况下，会显示当前所有存在的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  master</span><br><span class="line">* version1.0</span><br><span class="line">  version1.0_fix</span><br></pre></td></tr></table></figure>
<p>这里的*，表示当前检出的分支，也就是HEAD指向的分支。</p>
<p>加上参数-v，可以查看每个分支的最后一次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">* master         252a6ae Merge branch &#x27;version1.0&#x27;</span><br><span class="line">  version1.0     e5f913e ceshi</span><br><span class="line">  version1.0_fix efd3828 fix some problems</span><br></pre></td></tr></table></figure>

<p>加上参数–merged和–no-merged，可以过滤已经合并或尚未合并到当前分支的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">* master</span><br><span class="line">  version1.0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  version1.0_fix</span><br></pre></td></tr></table></figure>

<h1 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h1><p>git整合来自不同分支的修改有：merge（合并）和rebase（变基）两种方法。合并会把“主分支”和“被合分支”基于共同祖先的修改归结为一个新的提交，创建在两个分支的后面，“主分支”指针向后移动。</p>
<p>变基则相当于把非基底分支，转移到基底分支链上，其实质是在基底分支上重演每次提交的修改，然后以非基底分支的名义产生新的提交。这是基底分支可以使用快进（Fast-forward，也是用merge命令实现的）快速移动到最新提交处。此时非基底分支的提交记录像是被抹去了一样。</p>
<p>变基的基本原则是，仅变基位于本地的，未推送或分享的分支，因为只有这些分支当前用户才有权去“抹去”。</p>
<p>变基的方法一是，检出非基底分支后，git rebase &lt;基底分支&gt; ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout version1.0_fix   <span class="comment">#检出非基底分支</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase version1.0         <span class="comment">#变基到基底分支，让非基底分支“续”到基底分支后面</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout version1.0</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment      <span class="comment">#基底分支快进</span></span></span><br></pre></td></tr></table></figure>

<p>变基的另一种代码是，git rebase &lt;基底分支&gt; &lt;非基底分支&gt;，此时非基底分支会被“续”到基底分支后面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase version1.0 version1.0_fix</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout version1.0</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment      <span class="comment">#基底分支快进</span></span></span><br></pre></td></tr></table></figure>

<p>带–onto参数的变基，git rebase –onto &lt;基底分支&gt; &lt;不变基分支&gt; &lt;待变基分支&gt;，这里不变基分支和待变基分支的最近祖先提交，不会应用到基底：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master version1.0 version1.0_fix</span></span><br></pre></td></tr></table></figure>
<p>这里假设的情景是，基于master，创建一个version1.0版本的分支进行开发，然后发现version1.0版本有个来源于之前版本的bug，为了和新版本更好契合就新建version1.0_fix来修复，突然发现线上版本master需要立即修复这个bug，但又不想引进version1.0的内容，这时候应该使用上述命令。</p>
<h1 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h1><p>远程分支的过段时间整理，现在没有很好的实践机会</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>go实践单元测试</title>
    <url>/2022/12/18/%E5%AD%A6%E4%B9%A0/golang/%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97/go%E5%AE%9E%E8%B7%B5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>初步学习参考极客兔兔的《Go Test 单元测试简明教程》，第二次学习参考官方文档</p>
<span id="more"></span>
<h1 id="单元测试的用处"><a href="#单元测试的用处" class="headerlink" title="单元测试的用处"></a>单元测试的用处</h1><p>对于大且复杂的项目，如果仅是优化一个函数的性能，或是添加几个新特性，部署后再测试成本太高。对于这种场景，对一些逻辑较为复杂的函数，使用几个小小的测试用例就可覆盖，降低重新构建项目的概率。</p>
<p>写好单元测试，首先需要写好测试用例。比如，如何测试单个函数；如何做好基准测试；遇到数据库访问等调用时如何mock。</p>
<p>其次，测试的代码要尽量满足“高内聚、低耦合”。如果有“这种代码没法测试”的问题，这种时候思考，能不能改得更好。为了代码可测试，而重构是值得的。</p>
<h1 id="测试文件的组织"><a href="#测试文件的组织" class="headerlink" title="测试文件的组织"></a>测试文件的组织</h1><h2 id="测试文件命名"><a href="#测试文件命名" class="headerlink" title="测试文件命名"></a>测试文件命名</h2><p>go语言推荐测试文件和源代码文件放在一起（位于同一个目录下），测试文件以 _test.go 结尾。比如，我们想测试 calc.go 中的Add和Mul函数，那么应该新建 calc_test.go 作为测试文件。</p>
<h2 id="测试文件内容简介"><a href="#测试文件内容简介" class="headerlink" title="测试文件内容简介"></a>测试文件内容简介</h2><p>假设已经实现了 calc.go ，那么 calc_test.go 的测试用例可以这么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 测试文件所在包，应该和代码所在包相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ans := Add(<span class="number">1</span>, <span class="number">2</span>); ans != <span class="number">3</span> &#123;</span><br><span class="line">        <span class="comment">// t.Error 、t.Errorf 遇错不停；t.Fatal 、t.Fatal、t.Fatalf 遇错退出</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;1 + 2 expected be 3, but %d got&quot;</span>, ans)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ans := Add(<span class="number">-10</span>, <span class="number">-20</span>); ans != <span class="number">-30</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;-10 + -20 expected be -30, but %d got&quot;</span>, ans)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个文件中，测试用例一般命名为 Test加待测试函数名；即这样命名的函数就是一个测试用例</li>
<li>测试用例的参数有且只有一个，在这里是 *testing.T</li>
<li>基准测试benchmark的参数是 *testing.B ，TestMain的参数是 *testing.M 类型</li>
</ul>
<h2 id="执行测试用例"><a href="#执行测试用例" class="headerlink" title="执行测试用例"></a>执行测试用例</h2><p>执行 go test ，该package下的所有测试用例都会被执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">go <span class="built_in">test</span></span></span><br><span class="line">ok      example 0.009s</span><br></pre></td></tr></table></figure>
<p>或 go test -v ，-v参数会显示每个用例的测试结果；-cover参数可以查看覆盖率</p>
<p>如果只想运行其中一个用例，可以用-run参数指定，该参数支持通配符*，和部分正则表达式。如 go test -run TestAdd -v 指令，只会运行TestAdd这一个测试用例</p>
<h1 id="子测试Subtests"><a href="#子测试Subtests" class="headerlink" title="子测试Subtests"></a>子测试Subtests</h1><h2 id="创建子测试用例"><a href="#创建子测试用例" class="headerlink" title="创建子测试用例"></a>创建子测试用例</h2><p>子测试是Go语言内置支持的，可以在某个测试用例中，使用 Run 方法创建子测试用例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在TestMul这个测试用例中， 创建 pos，neg 两个子测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMul</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建子测试用例</span></span><br><span class="line">	t.Run(<span class="string">&quot;pos&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> Mul(<span class="number">2</span>, <span class="number">3</span>) != <span class="number">6</span> &#123;</span><br><span class="line">            <span class="comment">// t.Fatal 、t.Fatalf 遇错即停；t.Error 、t.Errorf 遇错不停</span></span><br><span class="line">			t.Fatal(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="comment">// 创建子测试用例</span></span><br><span class="line">	t.Run(<span class="string">&quot;neg&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> Mul(<span class="number">2</span>, <span class="number">-3</span>) != <span class="number">-6</span> &#123;</span><br><span class="line">			t.Fatal(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行子测试用例"><a href="#执行子测试用例" class="headerlink" title="执行子测试用例"></a>执行子测试用例</h2><p>如果想只执行某个测试用例的子测试，要用 -run 参数指定，指定方式为  go test -run TestMul&#x2F;pos -v ；而之前提到的只执行这个测试用例，是用 go test -run TestMul</p>
<h2 id="多个子测试的创建"><a href="#多个子测试的创建" class="headerlink" title="多个子测试的创建"></a>多个子测试的创建</h2><p>对于多个子测试的场景，推荐如下的table-driven tests：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMul</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    cases:=[]<span class="keyword">struct</span>&#123;</span><br><span class="line">        Name <span class="type">string</span></span><br><span class="line">        A,B,Expected <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;pos&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;neg&quot;</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">-6</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;zero&quot;</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(c.Name,<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ans:=Mul(c.A,c.B);ans!=c.Expected&#123;</span><br><span class="line">                t.Fatalf(<span class="string">&quot;%d * %d expetced %d,but got %d&quot;</span>,c.A,c.B,c.Expected,ans)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有用例数据组织在切片cases中，新增用例就是给cases新增一条数据。如果数据量比较大，则应该从文件中读取，保存到切片</p>
<h1 id="帮助函数helpers"><a href="#帮助函数helpers" class="headerlink" title="帮助函数helpers"></a>帮助函数helpers</h1><h2 id="什么是帮助函数"><a href="#什么是帮助函数" class="headerlink" title="什么是帮助函数"></a>什么是帮助函数</h2><p>帮助函数是一些公用的，用于增加测试代码可读性和维护性的函数。常用的帮助函数是 testing.T.Helper ，当遇到报错时，输出会额外携带定位信息</p>
<h2 id="抽象子用例的创建"><a href="#抽象子用例的创建" class="headerlink" title="抽象子用例的创建"></a>抽象子用例的创建</h2><p>更进一步抽象子用例的创建过程，分割</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> calcCase <span class="keyword">struct</span>&#123; A, B, Expected <span class="type">int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createMulTestCase 抽象出创建子测试用例的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMulTestCase</span><span class="params">(t *testing.T, c *calcCase)</span></span> &#123;</span><br><span class="line">	t.Helper()  <span class="comment">// 调用这个帮助函数，在报错时可以清晰显示错误位置</span></span><br><span class="line">	<span class="keyword">if</span> ans := Mul(c.A, c.B); ans != c.Expected &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;%d * %d expected %d, but %d got&quot;</span>,</span><br><span class="line">			c.A, c.B, c.Expected, ans)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMul</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">//用例数据</span></span><br><span class="line">    cases:=[]calcCase&#123;</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">-3</span>, <span class="number">-6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">//错误用例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代创建子测试用例</span></span><br><span class="line">    <span class="keyword">for</span> _,c:= <span class="keyword">range</span> cases&#123;</span><br><span class="line">        createMulTestCase(t, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>在同一个测试文件中，每一个测试用运行的前后逻辑一般是相同的，这些相同的部分应该分别写在setup（用于执行前的一些初始化操作）和teardown（经常做一些回收资源的操作，如关闭网络连接，释放资源）。</p>
<p>标准库的testing提供了这样的机制，如果测试函数中包含TestMsin，那么生成的测试会调用 TestMain(m) ，而不是直接运行测试。调用 m.Run()触发所有测试用例的执行，并使用os.Exit()处理返回的状态码，存在用例失败的返回码为非零</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Before all tests&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;After all tests&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m test1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m test2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">	setup() <span class="comment">// setup需要手动调用</span></span><br><span class="line">	code := m.Run() <span class="comment">// 执行所有测试用例，code为零表示用例全部通过</span></span><br><span class="line">	teardown() <span class="comment">// teardown需要手动调用</span></span><br><span class="line">	os.Exit(code) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实践–网络测试"><a href="#实践–网络测试" class="headerlink" title="实践–网络测试"></a>实践–网络测试</h1><p>假设需要测试某个API接口的handler能够正常工作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可以创建一个真实的网络环境进行测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx_test.go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(t *testing.T, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	t.Helper()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;failed&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建服务器部分</span></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">	ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:0&quot;</span>)</span><br><span class="line">	handleError(t, err)</span><br><span class="line">	<span class="keyword">defer</span> ln.Close()</span><br><span class="line">    <span class="comment">// 注册句柄</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    <span class="comment">// 启动http服务</span></span><br><span class="line">	<span class="keyword">go</span> http.Serve(ln, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户</span></span><br><span class="line">    <span class="comment">// 发起一个get请求，这个请求会访问到helloHandler</span></span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;http://&quot;</span> + ln.Addr().String() + <span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">	handleError(t, err)</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的测试部分</span></span><br><span class="line">    <span class="comment">// 获取响应的body</span></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	handleError(t, err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(body) != <span class="string">&quot;hello world&quot;</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;expected hello world, but got&quot;</span>, <span class="type">string</span>(body))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，针对http开发的场景，使用标准库net&#x2F;http&#x2F;httptest进行测试更为高效。但标准库对各类环节都进行了封装，缺少上面例子的“模拟真实环境”的展示价值，故使用上面的例子进行演示</p>
<h1 id="Benchmark基准测试"><a href="#Benchmark基准测试" class="headerlink" title="Benchmark基准测试"></a>Benchmark基准测试</h1><p>基准测试用例的规则如下：</p>
<ul>
<li>函数名必须以 Benchmark开头，加待测试函数名，如 BenchmarkMul 是对 Mul 的基准测试</li>
<li>参数必须为 b *testing.B ，一般测试的参数是 t *testing.t</li>
<li>执行基准测试命令时，需要添加 -bench 参数</li>
<li>其他参数，如 -benchmen 可以查看内存使用情况</li>
</ul>
<p>基准测试报告每一列值对应的含义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BenchmarkResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    N         <span class="type">int</span>           <span class="comment">// 迭代次数</span></span><br><span class="line">    T         time.Duration <span class="comment">// 基准测试花费的时间</span></span><br><span class="line">    Bytes     <span class="type">int64</span>         <span class="comment">// 一次迭代处理的字节数</span></span><br><span class="line">    MemAllocs <span class="type">uint64</span>        <span class="comment">// 总的分配内存的次数</span></span><br><span class="line">    MemBytes  <span class="type">uint64</span>        <span class="comment">// 总的分配内存的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在运行基准测试时需要一些配置，这些配置不需要计入基准测试时间，则在运行测试前使用 b.ResetTimer() 先重置定时器。测试并发性能使用RunParallel函数，而非在内部使用go关键字标记。演示如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一段打印&quot;hello&quot;的代码进行测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHello</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置定时器</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="comment">// 开始基准测试</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RunParallel 测试并发性能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置html模板渲染的相关操作，具体干啥不知道</span></span><br><span class="line">	templ := template.Must(template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))</span><br><span class="line">    <span class="comment">// 开始基准测试</span></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">        <span class="comment">// 这里的for相当于C中的while（刚开始忘记了，没看明白）</span></span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			<span class="comment">// 所有 goroutine 一起，循环一共执行 b.N 次</span></span><br><span class="line">			buf.Reset() </span><br><span class="line">			templ.Execute(&amp;buf, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启用测试的指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -benchmem -bench .</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>学习</category>
        <category>测试模块</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII、Unicode、UTF-8区别简记录</title>
    <url>/2022/11/23/%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/ASCII%E3%80%81Unicode%E3%80%81UTF-8%E5%8C%BA%E5%88%AB%E7%AE%80%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>简单记录字符编码的区别，省的以后查一次忘一次</p>
<span id="more"></span>

<p>了解Unicode需要从ASCII码开始</p>
<h1 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h1><p>ASCII码(American Standard Code for Information Interchange)是美国标准信息交换码，起初值为美国英语设计，只能显示128个编码，对其他语言无能为力</p>
<p>ASCII码对照表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制   十六进制    字符或缩写    意义</span><br><span class="line">0	0	NUL	空字符</span><br><span class="line">1	1	SOH	标题起始 </span><br><span class="line">2	2	STX	文本起始 </span><br><span class="line">3	3	ETX	文本结束 </span><br><span class="line">4	4	EOT	传输结束 </span><br><span class="line">5	5	ENQ	询问 </span><br><span class="line">6	6	ACK	认可 </span><br><span class="line">7	7	BEL	铃 </span><br><span class="line">8	8	BS	退格 </span><br><span class="line">9	9	HT	水平制表栏 </span><br><span class="line">10	0A	LF	换行 </span><br><span class="line">11	0B	VT	垂直制表栏 </span><br><span class="line">12	0C	FF	换页 </span><br><span class="line">13	0D	CR	回车 </span><br><span class="line">14	0E	SO	移出 </span><br><span class="line">15	0F	SI	移入 </span><br><span class="line">16	10	DLE	数据链接丢失 </span><br><span class="line">17	11	DC1	设备控制 1 </span><br><span class="line">18	12	DC2	设备控制 2 </span><br><span class="line">19	13	DC3	设备控制 3 </span><br><span class="line">20	14	DC4	设备控制 4 </span><br><span class="line">21	15	NAK	否定接受 </span><br><span class="line">22	16	SYN	同步闲置符 </span><br><span class="line">23	17	ETB	传输块结束 </span><br><span class="line">24	18	CAN	取消 </span><br><span class="line">25	19	EM	媒体结束 </span><br><span class="line">26	1A	SUB	替换 </span><br><span class="line">27	1B	ESC	换码符</span><br><span class="line">28	1C	FS	文件分隔符</span><br><span class="line">29	1D	GS	组分隔符</span><br><span class="line">30	1E	RS	记录分隔符</span><br><span class="line">31	1F	US	单位分隔符</span><br><span class="line">---------------------</span><br><span class="line">32	20	SP	空格</span><br><span class="line">33	21	!	</span><br><span class="line">34	22	&quot;	</span><br><span class="line">35	23	#	</span><br><span class="line">36	24	$	</span><br><span class="line">37	25	%	</span><br><span class="line">38	26	&amp;	</span><br><span class="line">39	27	&#x27;	</span><br><span class="line">40	28	(	</span><br><span class="line">41	29	)	</span><br><span class="line">42	2A	*	</span><br><span class="line">43	2B	+	</span><br><span class="line">44	2C	,	</span><br><span class="line">45	2D	--	</span><br><span class="line">46	2E	.	</span><br><span class="line">47	2F	/	</span><br><span class="line">48	30	0</span><br><span class="line">49	31	1	</span><br><span class="line">50	32	2	</span><br><span class="line">51	33	3	</span><br><span class="line">52	34	4</span><br><span class="line">53	35	5	</span><br><span class="line">54	36	6</span><br><span class="line">55	37	7	</span><br><span class="line">56	38	8	</span><br><span class="line">57	39	9	</span><br><span class="line">58	3A	:	冒号</span><br><span class="line">59	3B	;	分号</span><br><span class="line">60	3C	&lt;	小于</span><br><span class="line">61	3D	=	等于</span><br><span class="line">62	3E	&gt;	大于</span><br><span class="line">63	3F	?	问号</span><br><span class="line">-----------------------</span><br><span class="line">64	40	@	商业 at 符号</span><br><span class="line">65	41	A	 </span><br><span class="line">66	42	B	 </span><br><span class="line">67	43	C	 </span><br><span class="line">68	44	D	 </span><br><span class="line">69	45	E	 </span><br><span class="line">70	46	F	 </span><br><span class="line">71	47	G	 </span><br><span class="line">72	48	H	 </span><br><span class="line">73	49	I	 </span><br><span class="line">74	4A	J	 </span><br><span class="line">75	4B	K	 </span><br><span class="line">76	4C	L	 </span><br><span class="line">77	4D	M	 </span><br><span class="line">78	4E	N	 </span><br><span class="line">79	4F	O	 </span><br><span class="line">80	50	P	 </span><br><span class="line">81	51	Q	 </span><br><span class="line">82	52	R	 </span><br><span class="line">83	53	S	 </span><br><span class="line">84	54	T	 </span><br><span class="line">85	55	U	 </span><br><span class="line">86	56	V	 </span><br><span class="line">87	57	W	 </span><br><span class="line">88	58	X	 </span><br><span class="line">89	59	Y	 </span><br><span class="line">90	5A	Z	 </span><br><span class="line">91	5B	[	左中括号</span><br><span class="line">92	5C	\	反斜杠</span><br><span class="line">93	5D	]	右中括号</span><br><span class="line">94	5E	^	音调符号</span><br><span class="line">95	5F	_	下划线</span><br><span class="line">96	60	`	重音符</span><br><span class="line">97	61	a	</span><br><span class="line">98	62	b	</span><br><span class="line">99	63	c	</span><br><span class="line">100	64	d	</span><br><span class="line">101	65	e	</span><br><span class="line">102	66	f	</span><br><span class="line">103	67	g	</span><br><span class="line">104	68	h	</span><br><span class="line">105	69	i	</span><br><span class="line">106	6A	j	</span><br><span class="line">107	6B	k	</span><br><span class="line">108	6C	l	</span><br><span class="line">109	6D	m	</span><br><span class="line">110	6E	n	</span><br><span class="line">111	6F	o	</span><br><span class="line">112	70	p	</span><br><span class="line">113	71	q	</span><br><span class="line">114	72	r	</span><br><span class="line">115	73	s	</span><br><span class="line">116	74	t	</span><br><span class="line">117	75	u	</span><br><span class="line">118	76	v	</span><br><span class="line">119	77	w	</span><br><span class="line">120	78	x	</span><br><span class="line">121	79	y	</span><br><span class="line">122	7A	z	</span><br><span class="line">123	7B	&#123;	左大括号</span><br><span class="line">124	7C	|	垂直线</span><br><span class="line">125	7D	&#125;	右大括号</span><br><span class="line">126	7E	~	代字号</span><br><span class="line">127	7F	DEL	擦掉</span><br></pre></td></tr></table></figure>

<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode是一个编码集，定义了每个字符的编码，但不设计在计算机中的具体存储，而utf-8、utf-16等则是在计算机中的具体实现</p>
<p>Unicode当前定义的字符范围是 0hex-10FFFFhex 。其中 0hex-FFFFhex 称为基本多文种平面 BMP (Basic Multilingual Plane)，在这个平面中的字符表现形式是 U+ 后面跟十六进制数。例如 X 字符的 unicode 是 U+0058。而超出 BMP 范围的，也就是 10000hex–10FFFFhex，需要用到5到6位来表示，如 U+E0001 和 U+10FFFD。</p>
<h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p>Unicode在基本多文种平面BMP范围内使用4位十六进制数，那么按理来说应该用四个字节来表示一个Unicode码点，但是在机器中实际使用中可以更加简化。其中UTF-8最通用的个实现，以字节(byte)为单位对Unicode进行可变长的编码，有以下的编码规则：</p>
<p>|字节量|前缀以及格式|码点范围（有些码点不会被取到）|<br>|···|···|···|<br>|1字节|0xxxxxxx|0-127|<br>|2字节|110xxxxx 10xxxxxx|128-2047|<br>|3字节|1110xxxx 10xxxxxx 10xxxxxx|2048-65535|<br>|4字节|11110xxx 10xxxxxx 10xxxxxx 10xxxxxx|65536-2097151|</p>
<h1 id="简单关系"><a href="#简单关系" class="headerlink" title="简单关系"></a>简单关系</h1><p>ASCII码既是字符集，也是它编码规则在机器中的实现，作为字符集它是Unicode的真子集，前128个字符与Unicode完全一致；作为编码规则在机器中的实现，ASCII码被用作UTF-8单字节长度的码点的实现</p>
<p>UTF-8是Unicode的一个最通用的实现方式，它可变长，1-4个字节不等，其中单字节长度的所有码点继承了ASCII码</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>go实践模糊测试</title>
    <url>/2022/11/23/%E5%AD%A6%E4%B9%A0/golang/%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97/go%E5%AE%9E%E8%B7%B5%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>参考官方文档，学习使用模糊测试</p>
<span id="more"></span>

<h1 id="需要提前了解的知识"><a href="#需要提前了解的知识" class="headerlink" title="需要提前了解的知识"></a>需要提前了解的知识</h1><p>go语言的string的存储是一个只读的 <strong>字节（bytes）</strong> 类型的切片。尽管string的单个元素是字节，但可以按UTF-8的编码规则存储n个字节在n个元素里，并解释为一个UTF-8的字符（这个n最小为1，最大为4，可参考本博客《ASCII、Unicode、UTF-8区别简记录》一文）。本文测试关键问题在于如何对string里的字符操作，很有必要了解上面一点</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>golang</category>
        <category>测试模块</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>二读《变身》有感</title>
    <url>/2022/11/09/%E9%98%85%E8%AF%BB/%E4%BA%8C%E8%AF%BB%E3%80%8A%E5%8F%98%E8%BA%AB%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>几年前、或许仅是一年前看过，当时有所感触但不敢细想；昨日偶然再遇，结局感慨良多</p>
<span id="more"></span>

<p>上次读时隐隐感觉到女主的结局会走向崩坏，但是作者用一种隐晦的方法展示了女主的末路。女主饮下剩下所有的东西，闭上眼神色安然，然后画面展示的是生育女儿，温馨互动，稍稍回忆过去悲惨经历的画面。这种感觉仿佛已经走出困境，忍受过去的种种不幸，如今终于迎来了光明。第一次读到这里，其实最坏的可能已经知道了。</p>
<p>随后画面一转，留下一副女主好久没有戴上的、也是刚刚才戴上的学生时代的眼镜。刚刚她久违地照着镜子，摆了一下以前的发型，戴上眼镜，然后饮下所有东西，露出安然的笑脸。然后我们就看到了她几年后生育女儿，与她欢笑，回忆着过去的痛苦却有所感慨但依旧满足。</p>
<p>其实到这里心底已经感觉到了，但是在心里告诉了我自己，“这是她未来的美好生活”，我匆匆掠过最后一页她的眼镜和几滴血迹，就当结束罢了。</p>
<p>再读时的最后一段，逐渐回忆起之前的感受，心里的无奈和压抑也逐渐加深。这是现实且可能的存在和经历，种种与她相处的人物都是无所谓未来的人物，只有她在体悟到生命后激起内心对未来的渴望，最后不得。欸。。。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>Web表单</title>
    <url>/2022/11/07/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/HTML%E4%B8%93%E9%A2%98/Web%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<p>和用户数据打交道</p>
<span id="more"></span>

<h1 id="Web表单元素"><a href="#Web表单元素" class="headerlink" title="Web表单元素"></a>Web表单元素</h1><h2 id="form元素"><a href="#form元素" class="headerlink" title="form元素"></a>form元素</h2><p>所有表单以一个form元素开始，这个元素元素正式定义了一个表单，是一个人容器元素。它的所有表单都是可选的，但最好设置action属性（指定url）和method属性（通常是get或post）</p>
<p>其他表单内元素（如label、input、textarea）都要包裹在form元素中，并且最好用列表布局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/my-handling-form-page&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入姓名&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>Message:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_message&quot;</span>&gt;</span>xxxxxxxxxxx<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Send your message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- button元素的type可以是：submit、reset、button（专用于JavaScript定制按钮） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>学习</category>
        <category>web前端‘</category>
        <category>HTML专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器扩展开发简单记录</title>
    <url>/2022/11/03/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%93%E9%A2%98/chrome%E6%89%A9%E5%B1%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一下谷歌扩展开发的一些要点，预期制作一个辅助测试的简单插件</p>
<span id="more"></span>

<h1 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h1><p>chrome扩展没有严格的项目结构要求，只需本目录有一个 manifest.json 即可。从chrome浏览器“右上角菜单-&gt;更多工具-&gt;扩展程序”进入扩展程序管理界面，勾选开发者模式，即可以文件夹形式直接加载</p>
<h1 id="核心介绍"><a href="#核心介绍" class="headerlink" title="核心介绍"></a>核心介绍</h1><h2 id="manifest-json文件"><a href="#manifest-json文件" class="headerlink" title="manifest.json文件"></a>manifest.json文件</h2><p>必须放置于根目录，用来设置所有相关配置，完整配置文档见<a href="https://developer.chrome.com/extensions/manifest">谷歌官方文档</a>。其中，manifest_version、name、version 必不可少</p>
<h2 id="content-script"><a href="#content-script" class="headerlink" title="content-script"></a>content-script</h2><p>content-script是扩展程序向页面注入脚本（还有css）的一种形式，它们本身是普通的JS文件，没有被赋予特殊的权限。可以实现通过配置它们方式，向指定页面注入JS和CSS。最常见的用处是广告屏蔽和页面CSS定制</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">  <span class="attr">&quot;content_scripts&quot;</span><span class="punctuation">:</span> </span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],</span></span><br><span class="line">      <span class="comment">// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址</span></span><br><span class="line">      <span class="attr">&quot;matches&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;all_urls&gt;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">      <span class="attr">&quot;js&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;js/jquery-1.8.3.js&quot;</span><span class="punctuation">,</span> <span class="string">&quot;js/content-script.js&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">      <span class="attr">&quot;css&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;css/custom.css&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">      <span class="comment">//特别地，如果涉及“DOM加载结束事件”的监听，只能用&quot;document_start&quot;</span></span><br><span class="line">      <span class="attr">&quot;run_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;document_start&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>content-script和原始页面共享DOM，但是不共享JS，如果要访问页面JS（如某个页面的JS变量），只能通过injected-js实现。</p>
<p>content-script仅可以访问4个chrome.xxx 类型的API：</p>
<ul>
<li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li>
<li>chrome.i18n</li>
<li>chrome.runtime(connect,getManifest, getURL , id , onConnect , onMessage , sendMessage)</li>
<li>chrome.storage</li>
</ul>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>background是一个常驻页面，它的生命周期随着浏览器打开而打开，随着浏览器关闭而关闭。所以需要把一直运行的、启动就运行的全局代码放在background-js里，所谓background-js是指background页面的JS部分</p>
<p>background-js的权限非常高，几乎可以调用所有chrome扩展API（除了devtools），而且可以无限制跨域（无需对方设置CORS。通过chrome-extension:&#x2F;&#x2F;id&#x2F;xx.html方式打开的网页也可以无限制跨域）</p>
<p>background可以是一个html页面，也可以是一个js脚本（chrome会自动为它生成一个默认网页）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在mainifest.json文件中</span></span><br><span class="line">  <span class="comment">// 会一直常驻的后台JS或后台页面，通过设置打开</span></span><br><span class="line">  <span class="comment">//手动打开的指定页面没有background效果</span></span><br><span class="line">  <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">    <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background.html&quot;</span></span><br><span class="line">    <span class="comment">//&quot;scripts&quot;: [&quot;js/background.js&quot;]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h2><p>popup（它仅能是一个html网页）是点击browser_action或page_action图标时打开的一个小窗口网页。popup可以包含任意你想要的HTML内容，并且会自适应大小</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="attr">&quot;browser_action&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/icon.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">    <span class="attr">&quot;default_title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这是一个示例Chrome插件&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 也可以调用setPopup()方法设置popup页面</span></span><br><span class="line">    <span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在权限上，popup页面和background页面十分类似，它们最大的不同时声明周期的不同。popup-js（popup页面的JS部分）中可以直接通过chrome.extension.getBackgroundPage()获取background的windows对象</p>
<h2 id="“injected-script”"><a href="#“injected-script”" class="headerlink" title="“injected-script”"></a>“injected-script”</h2><p>“injected-script”是一种注入方式，它可以弥补原始网页无法访问content-script中JS的缺陷。虽然content-script可以操作DOM，但是DOM却不能调用它，这导致无法在DOM中绑定content-script中的代码</p>
<p>这种注入方式似乎并无难度（从示例代码来看），但目前没有需要，为降低难度暂时忽略</p>
<h2 id="homepage-url"><a href="#homepage-url" class="headerlink" title="homepage_url"></a>homepage_url</h2><p>可以设置“开发者网站”，是自己网站的“免费广告位”：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="attr">&quot;homepage_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.ice-cooca.net&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Chrome插件的8种展现形式"><a href="#Chrome插件的8种展现形式" class="headerlink" title="Chrome插件的8种展现形式"></a>Chrome插件的8种展现形式</h1><h2 id="browserAction-浏览器右上角"><a href="#browserAction-浏览器右上角" class="headerlink" title="browserAction(浏览器右上角)"></a>browserAction(浏览器右上角)</h2><p>配置browser_action可以在浏览器右上角增加一组显示设置:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="attr">&quot;browser_action&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//默认图标。会被自动缩小到19px</span></span><br><span class="line">    <span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/icon.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//焦点放置时现实的文字</span></span><br><span class="line">    <span class="attr">&quot;default_title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这是一个示例Chrome插件&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//点击时跳出的小窗口网页</span></span><br><span class="line">    <span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">    <span class="comment">//此外，还可以设置badge，就是在图标上显示文本，但是只支持4个英文字符，也可以设置它的背景，但必须通过代码实现</span></span><br><span class="line">    <span class="comment">//实现代码需要放在background：</span></span><br><span class="line">    <span class="comment">//chrome.browserAction.setBadgeText(&#123;text: &#x27;new&#x27;&#125;);</span></span><br><span class="line">    <span class="comment">//chrome.browserAction.setBadgeBackgroundColor(&#123;color: [255, 0, 0, 255]&#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="options（选项页）"><a href="#options（选项页）" class="headerlink" title="options（选项页）"></a>options（选项页）</h2><p>options页时插件的设置页面，可以通过“右键插件图标-选项”来进入这个自适应缩小的页面。建议的数据存储使用chrome.storage，这回随用户自动同步</p>
<h2 id="pageAction（地址栏右侧）"><a href="#pageAction（地址栏右侧）" class="headerlink" title="pageAction（地址栏右侧）"></a>pageAction（地址栏右侧）</h2><p>只有当打开特定页面时，才点亮图标，默认置灰（早期版本是隐去）。使用这种方法除了在manifest.json中设置pageAction，还需要在background中添加一个监听器</p>
<p>（没有需要，忽略）</p>
<h2 id="其他没有需要，暂时忽略的功能"><a href="#其他没有需要，暂时忽略的功能" class="headerlink" title="其他没有需要，暂时忽略的功能"></a>其他没有需要，暂时忽略的功能</h2><ul>
<li>自定义浏览器右键菜单</li>
<li>使用override页覆盖特定页</li>
<li>自定义devtools工具</li>
<li>omnibox向用户提供搜索建议</li>
<li>桌面通知</li>
</ul>
<h1 id="扩展的几种JS对比"><a href="#扩展的几种JS对比" class="headerlink" title="扩展的几种JS对比"></a>扩展的几种JS对比</h1><h2 id="权限对比"><a href="#权限对比" class="headerlink" title="权限对比"></a>权限对比</h2><table>
<thead>
<tr>
<th>JS种类</th>
<th>API访问</th>
<th>DOM访问</th>
<th>原始JS访问</th>
<th>直接跨域</th>
</tr>
</thead>
<tbody><tr>
<td>background-js</td>
<td>除devtools绝大部分API</td>
<td>不可直接访问</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>popup-js</td>
<td>除devtools绝大部分API</td>
<td>不可直接访问</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>content-script</td>
<td>只能访问extension、runtime等部分API</td>
<td>可以访问</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>“injected-script”</td>
<td>和普通JS无任何差别，不能访问任何扩展API</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不可以</td>
</tr>
<tr>
<td>（省略了devtool js）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="调试方式对比"><a href="#调试方式对比" class="headerlink" title="调试方式对比"></a>调试方式对比</h2><table>
<thead>
<tr>
<th>JS种类</th>
<th>调试方式</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>插件管理中，点击背景页</td>
</tr>
<tr>
<td>popup-js</td>
<td>popup页面，右键审查元素</td>
</tr>
<tr>
<td>content-script</td>
<td>打开Console,如图切换</td>
</tr>
<tr>
<td>“injected-script”</td>
<td>直接普通的F12</td>
</tr>
<tr>
<td>devtools-js</td>
<td>省略</td>
</tr>
</tbody></table>
<h1 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h1><h2 id="详细通信介绍"><a href="#详细通信介绍" class="headerlink" title="详细通信介绍"></a>详细通信介绍</h2><h3 id="popup和background互相通信"><a href="#popup和background互相通信" class="headerlink" title="popup和background互相通信"></a>popup和background互相通信</h3><p> popup可以直接调用background中的JS方法和DOM（如果获取不到，可能是background的js报错，但不主动查看可能不会提示出）：<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//popup-js</span></span><br><span class="line"><span class="keyword">var</span> bg = chrome.<span class="property">extension</span>.<span class="title function_">getBackgroundPage</span>();</span><br><span class="line">bg.<span class="title function_">test</span>(); <span class="comment">// 访问bg的函数，这个test函数是在background.js中定义的</span></span><br><span class="line"><span class="title function_">alert</span>(bg.<span class="property">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); <span class="comment">// 访问bg的DOM</span></span><br></pre></td></tr></table></figure></p>
<p>background访问popup的前提是popup已经打开(即已经在网页中执行)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> views = chrome.<span class="property">extension</span>.<span class="title function_">getViews</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;popup&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(views.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(views[<span class="number">0</span>].<span class="property">location</span>.<span class="property">href</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="popup、background向content主动发送信息"><a href="#popup、background向content主动发送信息" class="headerlink" title="popup、background向content主动发送信息"></a>popup、background向content主动发送信息</h3><p>background-js或者popup-js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">  chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, message, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(callback) <span class="title function_">callback</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sendMessageToContentScript</span>(&#123;<span class="attr">cmd</span>:<span class="string">&#x27;test&#x27;</span>, <span class="attr">value</span>:<span class="string">&#x27;你好，我是popup！&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;来自content的回复：&#x27;</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>content-script主动接收：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// console.log(sender.tab ?&quot;from a content script:&quot; + sender.tab.url :&quot;from the extension&quot;);</span></span><br><span class="line">  <span class="keyword">if</span>(request.<span class="property">cmd</span> == <span class="string">&#x27;test&#x27;</span>) <span class="title function_">alert</span>(request.<span class="property">value</span>);</span><br><span class="line">  <span class="title function_">sendResponse</span>(<span class="string">&#x27;我收到了你的消息！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p>
<h3 id="content-script主动发消息给后台"><a href="#content-script主动发消息给后台" class="headerlink" title="content-script主动发消息给后台"></a>content-script主动发消息给后台</h3><p>（先不学）</p>
<h3 id="injected-script和content-script通信"><a href="#injected-script和content-script通信" class="headerlink" title="injected script和content-script通信"></a>injected script和content-script通信</h3><p>（先不学）</p>
<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>Chrome扩展中有两种通信方式，一个是短连接(chrome.tabs.sendMessage和chrome.runtime.sendMessage)，一个是长连接(chrome.tabs.connect和chrome.runtime.connect)</p>
<p>短连接像是带确认回复的报文，如果没有收到回复只能重发；长连接则像是建立一个全双工信道，双发可以随时收发</p>
<p>上面演示中的例子都是短连接，这里会演示长连接</p>
<p>popup-js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长连接的发送端</span></span><br><span class="line"><span class="title function_">getCurrentTabId</span>(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> port = chrome.<span class="property">tabs</span>.<span class="title function_">connect</span>(tabId, &#123;<span class="attr">name</span>: <span class="string">&#x27;test-connect&#x27;</span>&#125;);</span><br><span class="line">  port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;你是谁啊？&#x27;</span>&#125;);</span><br><span class="line">  port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;收到消息：&#x27;</span>+msg.<span class="property">answer</span>);</span><br><span class="line">    <span class="keyword">if</span>(msg.<span class="property">answer</span> &amp;&amp; msg.<span class="property">answer</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;我是&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;哦，原来是你啊！&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>content-script:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onConnect</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">port</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(port);</span><br><span class="line">  <span class="keyword">if</span>(port.<span class="property">name</span> == <span class="string">&#x27;test-connect&#x27;</span>) &#123;</span><br><span class="line">    port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到长连接消息：&#x27;</span>, msg);</span><br><span class="line">      <span class="keyword">if</span>(msg.<span class="property">question</span> == <span class="string">&#x27;你是谁啊？&#x27;</span>) port.<span class="title function_">postMessage</span>(&#123;<span class="attr">answer</span>: <span class="string">&#x27;我是你爸！&#x27;</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h1><h2 id="动态注入JS或CSS"><a href="#动态注入JS或CSS" class="headerlink" title="动态注入JS或CSS"></a>动态注入JS或CSS</h2><p>相比content-js只能指定”document_start”、”document_end” 、”document_idle”三个调用脚本时机，动态注入的方法更加灵活</p>
<p>声明权限：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="comment">//允许标签权限，允许动态注入CSS或JS的网址</span></span><br><span class="line">  <span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;tabs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;http://*/*&quot;</span><span class="punctuation">,</span> <span class="string">&quot;https://*/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注入JS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在在background-js或popup-js之中</span></span><br><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">code</span>: <span class="string">&#x27;document.body.style.backgroundColor=&quot;red&quot;&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-script.js&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>注入CSS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line"><span class="comment">//chrome.tabs.insertCSS(tabId, &#123;code: &#x27;xxx&#x27;&#125;);</span></span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">insertCSS</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-style.css&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前窗口ID、标签页ID"><a href="#获取当前窗口ID、标签页ID" class="headerlink" title="获取当前窗口ID、标签页ID"></a>获取当前窗口ID、标签页ID</h2><p>获取当前窗口ID：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在background-js或popup-js中</span></span><br><span class="line">chrome.<span class="property">windows</span>.<span class="title function_">getCurrent</span>(<span class="keyword">function</span>(<span class="params">currentWindow</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前窗口ID：&#x27;</span> + currentWindow.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取当前标签页ID：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId</span>(<span class="params">callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">  chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还有另外一种方法，但不理解，不记录</span></span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储建议用chrome.storage，而不是普通的localStorage，主要区别在于：</p>
<ul>
<li>chrome.storage针对插件全局，background中保存的数据，在content-script中也能获取到</li>
<li>chrome.storage.sync可以跟随当前登录用户自动同步</li>
</ul>
<p>先声明storage权限:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="comment">// 权限申请</span></span><br><span class="line">  <span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;storage&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用chrome.storage.sync读取和保存数据数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">color</span>, items.<span class="property">age</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="webRequest系列API"><a href="#webRequest系列API" class="headerlink" title="webRequest系列API"></a>webRequest系列API</h2><p>通过webRequest系统API，可以对HTTP请求进行任意修改、定制，这里使用beforeRequest来演示</p>
<p>先声明相关权限:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//在manifest.json文件中</span></span><br><span class="line">  <span class="comment">// 权限申请</span></span><br><span class="line">  <span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;webRequest&quot;</span><span class="punctuation">,</span> <span class="comment">// web请求</span></span><br><span class="line">    <span class="string">&quot;webRequestBlocking&quot;</span><span class="punctuation">,</span> <span class="comment">// 阻塞式web请求</span></span><br><span class="line">    <span class="string">&quot;storage&quot;</span><span class="punctuation">,</span> <span class="comment">// 插件本地存储</span></span><br><span class="line">    <span class="string">&quot;http://*/*&quot;</span><span class="punctuation">,</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">    <span class="string">&quot;https://*/*&quot;</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>脚本代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在background-js中</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line">  showImage = items.<span class="property">showImage</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeRequest</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line">  <span class="keyword">if</span>(!showImage &amp;&amp; details.<span class="property">type</span> == <span class="string">&#x27;image&#x27;</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">  <span class="comment">// 简单的音视频检测</span></span><br><span class="line">  <span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line">  <span class="keyword">if</span>(details.<span class="property">type</span> == <span class="string">&#x27;media&#x27;</span>) &#123;</span><br><span class="line">    chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line">      <span class="attr">iconUrl</span>: <span class="string">&#x27;img/icon.png&#x27;</span>,</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;检测到音视频&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;音视频地址：&#x27;</span> + details.<span class="property">url</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>]&#125;, [<span class="string">&quot;blocking&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>插件根目录新建_locales文件夹，再在下面新建一些语言文件夹，如 en、zh_CN，然后再在每个文件夹里放入一个messages.json，同时在清单文件中设置defaule_locale</p>
<p>（不详细介绍）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>JavaScript专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript专题2--客户端API</title>
    <url>/2022/11/01/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%93%E9%A2%98/JavaScript%E4%B8%93%E9%A2%982--%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/</url>
    <content><![CDATA[<p>客户端API中的重点是DOM，它可以使用文档对象的API来控制html机器样式信息</p>
<span id="more"></span>
<h1 id="客户端API"><a href="#客户端API" class="headerlink" title="客户端API"></a>客户端API</h1><p>常见浏览器API：</p>
<ul>
<li>操作文档的API。典型的是DOM（文档对象模型）API，它允许像操作HTML和CSS完成对HTML的创建、移除、修改，以及动态的将样式应用于页面</li>
<li>从服务器获取数据的API。典型的是XHR API和Fetch API</li>
<li>用于绘制和操作图像的API。典型的是Canvas和WebGL，它们在&lt;canvas&gt;元素范围内创建2D和3D场景</li>
<li>音频和视频API。诸如HTMLMediaElement，Web Audio API和WebRTC</li>
<li>设备API。用以访问如地理位置等</li>
<li>客户端存储API。如Web Storege API</li>
</ul>
<h2 id="web-API–DOM"><a href="#web-API–DOM" class="headerlink" title="web API–DOM"></a>web API–DOM</h2><p>web API允许我们访问window（载入浏览器的标签）、navigator（浏览器的状态和表示）、document（DOM），其中最常用的是DOM</p>
<h3 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h3><p>一个文档对象模型的每个元素和文本，在构成的DOM树中都可被称为节点。有以下节点概念：</p>
<ul>
<li>元素节点：任何标签都是元素节点</li>
<li>文本节点：往往是某个元素的文本内容（如果一个文本段中间隔了其他行内元素，那么被分隔的文本段各自成为一个文本节点）</li>
<li>子节点</li>
<li>后代节点</li>
<li>父节点</li>
<li>兄弟节点：在DOM树中同是一个元素的子节点，位于同一等级</li>
</ul>
<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p><em>前提操作：在闭合的&lt;body&gt;标签上加入&lt;script&gt;&lt;/script&gt;元素</em></p>
<h3 id="选择元素并存储引用："><a href="#选择元素并存储引用：" class="headerlink" title="选择元素并存储引用："></a>选择元素并存储引用：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取第一个链接元素</span></span><br><span class="line"><span class="keyword">var</span> link=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>querySelector和querySelectorAll允许使用CSS选择器获取元素，是最常用的方法</p>
<h3 id="修改元素的已知属性："><a href="#修改元素的已知属性：" class="headerlink" title="修改元素的已知属性："></a>修改元素的已知属性：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">link.<span class="property">textContent</span>=<span class="string">&#x27;moe moe cute&#x27;</span>;</span><br><span class="line">link.<span class="property">href</span>=<span class="string">&#x27;https://moemoecute.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建并放置新的节点"><a href="#创建并放置新的节点" class="headerlink" title="创建并放置新的节点"></a>创建并放置新的节点</h3><p>document.createElement(x)会创建一个元素节点x， parentNode.appendChild(x)会把节点x追加到这个parentNode下面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在在一个section元素里添加一个p元素，并设置p的文本内容*/</span></span><br><span class="line"><span class="comment">//获取一个section元素的引用</span></span><br><span class="line"><span class="keyword">var</span> sect=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个段落元素，并修改它的文本内容</span></span><br><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">para.<span class="property">textContene</span>=<span class="string">&#x27;order a rabbit&#x27;</span>;</span><br><span class="line"><span class="comment">//把刚刚创建的段落元素作为子元素，追加到sect里</span></span><br><span class="line">sect.<span class="title function_">appendChild</span>(para);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给p元素再添加一个子文本节点*/</span></span><br><span class="line"><span class="comment">//创建文本节点</span></span><br><span class="line"><span class="keyword">var</span> endText=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;--the end of a paragraph!&#x27;</span>);</span><br><span class="line"><span class="comment">//获取段落元素的引用</span></span><br><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">//把文本追加到段落上。</span></span><br><span class="line">para.<span class="title function_">appendChild</span>(endText);</span><br></pre></td></tr></table></figure>

<h3 id="移动和删除节点"><a href="#移动和删除节点" class="headerlink" title="移动和删除节点"></a>移动和删除节点</h3><p>document.appendChild(x)方法不仅仅可以追加一个新的、未被添加进DOM的节点，还可以移动一个已经存在于DOM的节点，这并不会创建一个新的副本</p>
<p>parentNode.removeChild(x)方法会删除parentNode的子节点x。特别地，如果要从节点x开始删除节点x，需要时先获得它父元素的引用才（这个方法无法自己删除自己）</p>
<h3 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h3><p>第一种方法是，直接添加元素内联样式，这是用HTMLElement.style属性实现的，这个属性包含文档每个元素的内联样式信息</p>
<p>这些这个脚本后，内联样式会添加到元素中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">para.<span class="property">style</span>.<span class="property">color</span>=<span class="string">&#x27;while&#x27;</span></span><br><span class="line">para.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第二种方法是，事先定义好需要目的样式类，使用Element.setAttribute()来修改元素的类，这种方法更加正统：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//highlightClass需要事先在CSS文件里定义好并导入，或直接定义在html的head元素里</span></span><br><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">para.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>,<span class="string">&#x27;highlightClass&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="web-API–window-API"><a href="#web-API–window-API" class="headerlink" title="web API–window API"></a>web API–window API</h2><p>获取视窗（显示文档的内部窗口）的宽度和高度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">WIDTH</span>=<span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">HEIGHT</span>=<span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br></pre></td></tr></table></figure>

<p>使用获取的视窗长宽，动态改变元素的长宽：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">style</span>.<span class="property">width</span>=<span class="variable constant_">WIDTH</span>+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">width</span>=<span class="variable constant_">HEIGHT</span>+<span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用windows对象的onresize事件，每次调整窗口大小都会触发该事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable constant_">WIDTH</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">  <span class="variable constant_">HEIGHT</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">width</span> = <span class="variable constant_">WIDTH</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">height</span> = <span class="variable constant_">HEIGHT</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从服务器获取数据API"><a href="#从服务器获取数据API" class="headerlink" title="从服务器获取数据API"></a>从服务器获取数据API</h2><p>早期允许网页请求小数据块和仅在需要时显示的技术，被称为Ajax(Asynchronous JavaScript and XML)。现在常用XMLHttpRequest或Fetch来请求JSON数据，但仍然使用术语Ajax来描述</p>
<h3 id="使用XHR向服务器请求数据"><a href="#使用XHR向服务器请求数据" class="headerlink" title="使用XHR向服务器请求数据"></a>使用XHR向服务器请求数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个XHR对象</span></span><br><span class="line"><span class="keyword">let</span> request=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//设置请求的方法，这里是GET</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,url);</span><br><span class="line"><span class="comment">//设置请求的期望响应内容，这里是text</span></span><br><span class="line">request.<span class="property">reponseType</span>=<span class="string">&#x27;text&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用设置事件属性的方法，创造一个监听：一旦onload（响应已经返回），就触发</span></span><br><span class="line">request.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  poemDisplay.<span class="property">textContent</span>=request.<span class="property">response</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行请求发送</span></span><br><span class="line">request.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h3 id="使用Fetch向服务器请求数据"><a href="#使用Fetch向服务器请求数据" class="headerlink" title="使用Fetch向服务器请求数据"></a>使用Fetch向服务器请求数据</h3><p>Fetch API是XHR的一个现代替代品，它使异步HTTP请求更容易在JavaScript中实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">  response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="params"><span class="keyword">function</span>(text)</span>)&#123;</span><br><span class="line">    poemDisplay.<span class="property">textContent</span>=text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>基于promise.then方法也返回一个promise的特点，可以有以下等价写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123;<span class="keyword">return</span> response.<span class="title function_">text</span>()&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">text</span>=&gt;</span>&#123;<span class="keyword">return</span> poemDisplay.<span class="property">textContent</span>=text;&#125;);</span><br></pre></td></tr></table></figure>

<p>代码理解：fetch会发出一个请求，返回一个priomise对象，这个promise会解析从服务器返回的响应。一个promise对象调用then方法时，会自动传递自身所“包装”的那个对象，来作为then里面的执行函数的参数</p>
<p>使用then方法很像是加上了一个监听器</p>
<h2 id="客户端存储API"><a href="#客户端存储API" class="headerlink" title="客户端存储API"></a>客户端存储API</h2><p>传统方式cookies有些过时、存在各种安全问题，而且无法存储复杂数据。现在应该使用新的方法：</p>
<ul>
<li>Web Storage API：用于存储和检索较小的键值对，如存储用户名、用户是否登录、屏幕背景色等</li>
<li>IndexedDB API：提供了一个完整的数据库系统来存储复杂数据，除了用户记录以外，还可以是音频或视频文件</li>
</ul>
<p>（暂时用不到，以后再仔细学习）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>JavaScript专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript专题1--异步JavaScript</title>
    <url>/2022/10/31/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%93%E9%A2%98/JavaScript%E4%B8%93%E9%A2%981--%E5%BC%82%E6%AD%A5JavaScript/</url>
    <content><![CDATA[<p>记录异步JavaScript API，重点是用于和服务器交换报文的Promise API 。关于Worker的部分则省略</p>
<ul>
<li>2022-11-08 复习整理了一遍Promise</li>
</ul>
<span id="more"></span>

<h1 id="早期实现异步的XHR"><a href="#早期实现异步的XHR" class="headerlink" title="早期实现异步的XHR"></a>早期实现异步的XHR</h1><p>事件处理程序实际上就是异步编程的一种形式，函数会在事件发生的时候调用，而非立即调用</p>
<p>XMLHttpRequest（简称为XHR） API是JavaScript早期的异步API，可以发起HTTP请求，并通过给XHR对象附加事件监视器（以及配套的处理程序），在请求进展、最终完成、或其他时刻执行某些行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 假定有这样的html文件</span></span><br><span class="line"><span class="comment">&lt;button id=&quot;xhr&quot;&gt;点击发起请求&lt;/button&gt;</span></span><br><span class="line"><span class="comment">&lt;pre readonly class=&quot;event-log&quot;&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> log=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.event-log&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给点击事件加上监听。（异步）如果点击则发起发起一个http请求</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#xhr&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  log.<span class="property">textContent</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//给xhr对象加上监听。（异步）如果获取到返回，则输出相关信息</span></span><br><span class="line">  xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    log.<span class="property">textContent</span>=<span class="string">&#x27;$&#123;log.textcont&#125;完成！状态码：$&#123;xhr.status&#125;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//发送一个http请求</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;www.baidu.com&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise"></a>使用Promise</h1><p>Promise是一个对象，往往使用它的then方法、catch方法等来实现异步调用。Promise对象一般用const声明，这个声明的是对象的内存地址值不可变，但对象内容可变</p>
<p>⭐注意，异步函数总是返回一个Promise，哪怕return的就是一个非常常见的变量。如果有一个返回json变量的函数，加了async关键字，那么它的返回值也会是Promise。如果想要使用这个变量，必须在 .then()中的作为参数的函数内使用，如 xxx.then(json&#x3D;&gt;{console.log(json[0]);}); </p>
<h2 id="fetch-API返回一个Promise"><a href="#fetch-API返回一个Promise" class="headerlink" title="fetch API返回一个Promise"></a>fetch API返回一个Promise</h2><p>fetch API是一个基于Promise的，用以替代XMLHttpRequest的方法（XHR是早期实现异步编程的API）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise=<span class="title function_">fetch</span>(<span class="string">&#x27;https://cehsiceshi.com/somedata.json&#x27;</span>);</span><br><span class="line"><span class="comment">//注意，then方法里面的函数是作为参数的，它会等到promise变为fulfilled再执行</span></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123; <span class="comment">//收到的响应会自动为传递给这个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已收到响应：$&#123;reponse.status&#125;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;已发送请求&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个成功实现的输出应该是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已发送请求</span><br><span class="line">已收到响应：200</span><br></pre></td></tr></table></figure>

<h2 id="Promise术语"><a href="#Promise术语" class="headerlink" title="Promise术语"></a>Promise术语</h2><p>Promise有三种状态：</p>
<ul>
<li><strong>待定pending</strong>：这是调用fetch返回的Promise状态，此时请求刚刚发起，不知道能否成功返回</li>
<li><strong>已实现fulfilled</strong>：意味着操作成功“完成”，此时调用then方法，其中的resolved参数对应的函数会被调用</li>
<li><strong>已拒绝rejected</strong>：意味着操作“失败”，此时调用then方法，其中的rejected参数对应的函数会被调用；或者直接被catch捕获</li>
</ul>
<p>注意，这里“成功”或“失败”的含义取决于使用的API，如fetch会认为服务器返回（response.status）404时成功，网络错误时失败</p>
<h2 id="链式使用Promise和错误处理"><a href="#链式使用Promise和错误处理" class="headerlink" title="链式使用Promise和错误处理"></a>链式使用Promise和错误处理</h2><p>一个异步操作往往需要由多个函数构成，为了避免在一个then参数内嵌套多个then，可以使用链式调用的方法。Promise的方便在于，它的方法then本身也会返回一个Promise，并且这个Promise还会指示出作为then参数的函数的完成状态</p>
<p>Promise还有用于错误处理的catch方法，catch往往位于Promise链的最后一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise=<span class="title function_">fetch</span>(<span class="string">&#x27;https://cehsiceshi.com/somedata.json&#x27;</span>);</span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function"><span class="params">response</span> =&gt;</span> &#123; <span class="comment">//收到的响应自动传递给这个参数</span></span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();<span class="comment">//函数返回一个json对象，这个对象之后又会被then构造成一个Promise</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`error：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function"><span class="params">json</span> =&gt;</span> &#123; <span class="comment">//上一个then内（作为参数的）函数的返回值，自动传递给这个参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>( <span class="function"><span class="params">error</span>=&gt;</span>&#123;<span class="comment">//捕获错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;$&#123;error&#125;&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>简单观察这个例子，不妨简单把then()里作为参数的函数看作成功时执行的代码，cathc()里作为参数的函数看作错误出现时的代码</p>
<h2 id="合并使用多个Promise"><a href="#合并使用多个Promise" class="headerlink" title="合并使用多个Promise"></a>合并使用多个Promise</h2><p>如果几个Promise相互间没有依赖关系，那么可以使用all方法，它接收一个Promise数组作为一个参数，返回单一的Promise。这个all方法返回的Promise使用then方法，给予处理函数的参数是一个响应数组（顺序与传入all的Promise的顺序相同）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略三个fetch</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function"><span class="params">responses</span> =&gt;</span> &#123; <span class="comment">//注意，这个自动传递的response是一个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`status：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>( <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="comment">//只要有一个fetch失败就会触发错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p><strong>同步变异步：</strong>async关键字能够让自定义的一个普通函数成为异步函数。注意，此时这个函数的返回值变成了Promise，如需使用这个函数return语句返回的对象，需要在then()方法中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>)&#123; <span class="keyword">var</span> a=<span class="number">1</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">const</span> myPromise = <span class="title function_">myFunc</span>();</span><br><span class="line">myPromise.<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>异步变同步：</strong>await关键字能够使得代码在该点上等待，直到Promise被完成。此时，如fetch等默认返回Promise的对象，返回值变成return语句返回的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> response=<span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://ceshiceshi.com/ceshi.json&#x27;</span>)<span class="comment">//添加声明后，fetch返回值由Promise变为一个响应对象，且变为顺序执行</span></span><br><span class="line">  <span class="comment">//下面的代码会在fetch完成后再执行</span></span><br><span class="line">  <span class="keyword">if</span>(!response.<span class="property">ok</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求错误：$&#123;response.status&#125;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意，json方法默认也是异步的</span></span><br><span class="line">  <span class="keyword">const</span> ceshiJson=<span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">//添加了await关键字后，json返回值由Promise变为一个普通的json对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(error)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;$&#123;error&#125;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise构造器"><a href="#Promise构造器" class="headerlink" title="Promise构造器"></a>Promise构造器</h2><p>如果需要自己实现一个异步<strong>过程</strong>（区别于async关键字注重的是异步函数），此时可以使用Promise构造器创建一个Promise对象。Promise构造器使用单个函数（被称为执行器）作为参数。当创建一个新的Promise的时候需要实现这个执行器，执行器本身采用两个参数，这两个参数都是函数，通常称作resolve和reject</p>
<p>执行器本身实现一个异步函数，如果异步函数成功，则会运行执行器代码，里面可以调用resolve；如果异步函数失败（包括执行器内的代码），如fetch时网络阻止，主动的throw，，则会<strong>自动</strong>调用reject</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flag=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#flag&#x27;</span>);</span><br><span class="line"><span class="comment">//注意，resolve和reject是在外面定义好的函数</span></span><br><span class="line"><span class="comment">//其中resolve需要自己去执行（没有需要也可以不执行）</span></span><br><span class="line"><span class="comment">//reject会自动捕获错误，无需在执行器中含有catch语句</span></span><br><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;someting wrong&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(para1,para2);<span class="comment">//如果之前的异步函数，以及执行器内前面的代码没有出现问题，这里调用了resolve</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<h1 id="worker简介"><a href="#worker简介" class="headerlink" title="worker简介"></a>worker简介</h1><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。为了避免资源消耗，worker一旦使用完成应该即时关闭</p>
<p>为了避免多线程环境下的同步问题（尤其是对相同变量的访问），主代码和worker代码永远不能直接访问彼此的变量。这一为了workers不能访问DOM</p>
<p>（暂时没有使用worker的需求和水平，暂时搁置整理）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>JavaScript专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>插柳成荫</title>
    <url>/2022/10/19/%E9%98%85%E8%AF%BB/%E6%8F%92%E6%9F%B3%E6%88%90%E8%8D%AB/</url>
    <content><![CDATA[<p>记录一些偶然间了解的道理</p>
<ol>
<li>有感“虽千万人，吾往矣”</li>
<li>有感“论心终古少完人”上下文</li>
</ol>
<span id="more"></span>

<h1 id="虽千万人，吾往矣"><a href="#虽千万人，吾往矣" class="headerlink" title="虽千万人，吾往矣"></a>虽千万人，吾往矣</h1><p><strong>原文：</strong><br>公孙丑问曰：“夫子加齐之卿相，得行道焉，虽由此霸王，不异矣。如此则动心否乎？”孟子曰：“否！我四十不动心。”曰：“若是，则夫子过孟贲远矣。”曰：“是不难，告子先我不动心。”曰：“不动心有道乎？”曰：“有。北宫黝之养勇也，不肤挠，不目逃，思以一豪挫于人，若挞之于市朝，不受于褐宽博，亦不受于万乘之君；视刺万乘之君，若刺褐夫，无严诸侯，恶声至，必反之。孟施舍之所养勇也，曰：‘视不胜犹胜也；量敌而后进，虑胜而后会，是畏三军者也。舍岂能为必胜哉？能无惧而已矣。’孟施舍似曾子，北宫黝似子夏。夫二子之勇，未知其孰贤，然而孟施舍守约也。昔者曾子谓子襄曰：‘子好勇乎？吾尝闻大勇于夫子矣。自反而不缩，虽褐宽博，吾不惴焉；自反而缩，虽千万人，吾往矣。’孟施舍之守气，又不如曾子之守约也。”</p>
<p><strong>翻译（直接抄了某个网站上的）：</strong><br>公孙丑问道：“如果让您担任齐国的卿相，能够实行您的主张了，那么即使因此而建立了霸业或王业，也不必感到奇怪的了。如果这样，您动心不动心呢？”孟子说：“不，我四十岁起就不动心了。”公孙丑说：“如果这样，老师就远远超过孟贲了。孟子说：“做到这点不难，告子在我之前就做到不动心了。”公孙丑问：“做到不动心有什么方法吗？”孟子说：“有。北宫黝这样培养勇气：肌肤被刺不退缩，双目被刺不转睛；但他觉得，受了他人一点小委屈，就像在大庭广众之中被人鞭打了一般；既不受平民百姓的羞辱，也不受大国君主的羞辱；把行刺大国君主看得跟行刺普通百姓一样；毫不畏惧诸侯，听了恶言，一定回击。孟施舍这样培养勇气，他说：‘把不能取胜看作能够取胜；估量了势力相当才前进，考虑到能够取胜再交战，这是畏惧强大的敌人。我哪能做到必胜呢？能无所畏惧罢了。’（培养勇气的方法，）孟施舍像曾子，北宫黝像子夏。这两人的勇气，不知道谁强些，但孟施舍是把握住了要领。从前，曾子对子襄说：‘你勇敢吗？我曾经在孔子那里听到过关于大勇的道理：反省自己觉得理亏，那么即使对普通百姓，我难道就不害怕吗？反省自己觉得理直，纵然面对千万人，我也勇往直前。’孟施舍的保持勇气，又不如曾子能把握住要领。”</p>
<h1 id="论迹不论心"><a href="#论迹不论心" class="headerlink" title="论迹不论心"></a>论迹不论心</h1><p><strong>原文：</strong><br>百善孝为先，论心不论迹，论迹贫家无孝子；万恶淫为首，论迹不论心，论心终古少完人</p>
<p>这句话来自《围炉夜话》。这句话本身就含有辩证的思维，本就没有绝对的“论心不论迹”、“论迹不论心”，单拎出来其中一句，或者仅从字面意思来理解两句，就会罔顾其本意。虽然之前知道很多事情要辩证来看，但是对“迹”和“心”的平衡和把握还是没有度量，稍稍理解这句话后，知道“心”“迹”都必须受环境和人的本性的考量，能在某个条件下做到力所能及便是君子了。后面一句话也有些单独的理解，圣人君子并非没有邪念，而是能不失本心，有句话可以参考，“乡为身死而不受，今位宫室之美而为之”。不失本来想法，秉持本心，面对诱惑不扭曲原本仁德淳朴的意愿，才是真君子。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习二：记录更新</title>
    <url>/2022/10/12/%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0%E4%BA%8C%EF%BC%9A%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>这篇文章主要记录一些客户端用户使用git的方法</p>
<ul>
<li>2022-10-13 记录了学习的git基础操作</li>
<li>2022-12-20 重新学习一遍基础操作，专注于使用git bash</li>
</ul>
<p>参考 <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p>
<span id="more"></span>
<h1 id="git简单理解"><a href="#git简单理解" class="headerlink" title="git简单理解"></a>git简单理解</h1><p>其他版本控制系统和git主要差别，在于对数据的<strong>不同的存储方式</strong>。其他大部分系统以文件变更列表的方式存储，如CVS、Subversion、Perforce等等，它们存储的是“文件的差异”。</p>
<p>git会把一个提交后的所有文件，看作一个版本的快照，如果其中有未修改的文件，则只会存储一个链接指向之前的文件。示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    版本随提交时间排序</span><br><span class="line">----------------------------------------------------------&gt;</span><br><span class="line"> version1    version2    version3    version4    version5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    A           A1 &lt;----- ptr_A1        A2 &lt;----- ptr_A2</span><br><span class="line"></span><br><span class="line">    B &lt;------- ptr_B ---- ptr_B         B1          B2</span><br><span class="line"></span><br><span class="line">    C           C1         C2 &lt;------ ptr_C2       C3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的文件存储方式，意味着git很容易添加数据，但很难删除数据。尽管可以回退版本后新提交（比如回退到v2，在它的基础上新提交一次），但是这时的版本应该是v6（是当前最新版本的下一个版本，而非v3），v3<del>v5仍然保存着，而v6仅表示最新且但与v3</del>v5无关</p>
<p><strong>git保证完整性</strong>。git中所有数据在存储前就计算校验和，然后以校验和来引用，这意味着不可能在git不知情的情况下修改内容或目录。如果在传送过程中丢失信息或者损坏文件，git就能发现。git用以计算校验和的机制叫做SHA-1 hash，git数据库中保存的信息都是以文件的hash值来引用，而非文件名</p>
<h1 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h1><p>通常有两种获取git仓库的方式：</p>
<ol>
<li>将尚未进行版本控制的本地目录转换为git仓库</li>
<li>从其他服务器克隆一个已经存在的git仓库</li>
</ol>
<h2 id="在本地目录中初始化仓库"><a href="#在本地目录中初始化仓库" class="headerlink" title="在本地目录中初始化仓库"></a>在本地目录中初始化仓库</h2><p>初始化仓库，需要先进入仓库所在文件夹根目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>
<p>这样会创.git子目录，包含git仓库的所有必须文件。此时项目里的文件还未被追踪</p>
<p>第一次追踪文件，并第一次提交。这里追踪了当前目录下的所有文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;first commit&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>使用 git clone <url> 可以克隆一个完整的仓库，或者仓库下的文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 myLibgit</span></span><br></pre></td></tr></table></figure>
<p>这会在当前目录下创建一个名为myLibgit的目录（如果不指定自定义仓库名，则按默认的libgit2），在其中初始化一个.git文件夹，并<strong>从远程仓库拉取所有数据</strong>放入.git文件夹，然后从中读取最新版本的文件的拷贝放到myLibgit目录下</p>
<p>克隆使用的url可以是https://协议、git://协议、SSH传输协议（如 <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:libgit2/libgit2.git）</p>
<h1 id="记录更新到仓库"><a href="#记录更新到仓库" class="headerlink" title="记录更新到仓库"></a>记录更新到仓库</h1><h2 id="检查当前文件状态–git-status"><a href="#检查当前文件状态–git-status" class="headerlink" title="检查当前文件状态–git status"></a>检查当前文件状态–git status</h2><p>工作目录下的<strong>已跟踪</strong>的文件有三种状态：未修改（unmodified），已修改（modifeid），已暂存（staged）。把未跟踪（untracked）作为状态计入，则一共有四个状态</p>
<p>文件的状态变化周期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untracked    Unmodified    Modified      Staged</span><br><span class="line">    |            |            |            |</span><br><span class="line">    |===add==============================&gt; |</span><br><span class="line">    |            |==edit====&gt; |            |</span><br><span class="line">    |            |            |==stage===&gt; |</span><br><span class="line">    | &lt;==remove==|            |            |</span><br><span class="line">    |            | &lt;===============commit==|</span><br><span class="line">    |            |            |            |</span><br></pre></td></tr></table></figure>

<p>可以使用git status命令查看哪些文件处于什么状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>如果有以上输出，则表示工作目录相当“干净”。“干净”的意思是，所有已跟踪文件自上次提交后没有修改过，且当前目录除忽略文件以外，都已被追踪。如果有未追踪的文件，则会列出。</p>
<h2 id="将文件添加下一次提交中–git-add操作群"><a href="#将文件添加下一次提交中–git-add操作群" class="headerlink" title="将文件添加下一次提交中–git add操作群"></a>将文件添加下一次提交中–git add操作群</h2><p>使用命令 git add &lt;file/dir&gt;开始<strong>追踪</strong>一个文件，或递归地追踪一个目录下所有文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add src</span></span><br></pre></td></tr></table></figure>

<p>如果修改了一个已被跟踪的文件，那么此时检查文件状态（git status），会提示 Changes not staged for commit（没有准备提交的更改），表示这些更改没有计入缓存中。再次使用git add可以将其<strong>添加到暂存区</strong>，这和开始追踪的命令相同</p>
<p><strong>简单理解暂存</strong>：有这么一种情况，在暂存文件后再进行修改，此时使用git status，会发现已修改和暂存中都有这个文件。明白git对文件的保存像是快照，就可理解，使用git add会生成了那个时刻的文件副本（即快照），并在暂存区中记录了那个快照的校验和。之后在工作目录中所修改的不会影响到暂存区中的文件，此时工作目录中的是已修改文件。</p>
<p><strong>简单理解git add</strong>：这是一个多功能命令，可以跟踪新文件，暂存已修改文件，还能把有冲突的文件标记为已解决等。这个命令应该精确地理解为“将当前工作区的这个名字的文件添加到下一次提交中”</p>
<h2 id="忽略文件–-gitignore文件"><a href="#忽略文件–-gitignore文件" class="headerlink" title="忽略文件–.gitignore文件"></a>忽略文件–.gitignore文件</h2><p>有些无需纳入git管理的文件，如日志文件和编译过程中的临时文件，可以创建名为 .gitignore的文件，列出要忽略的文件模式。以下是常见的模式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># .gitignore文件。井号将被识别为注释符号</span><br><span class="line"></span><br><span class="line"># 忽略所有后缀为.a的文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的 lib.a，即便你在前面忽略了所有.a后缀的文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的TODO文件，而不忽略子目录下的TODO文件夹</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名为 build 的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略doc目录下的.txt文件，但不忽略子目录或其他目录下的.txt文件</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<p>一个仓库一般在根目录下有一个 .gitignore文件 ，它递归地应用到整个仓库中。子目录下也可以有额外的 .gitignore文件，它只作用于它所在的目录中。</p>
<h2 id="提交更新–git-commit"><a href="#提交更新–git-commit" class="headerlink" title="提交更新–git commit"></a>提交更新–git commit</h2><p><em>每次提交前建议使用git status查看是否有未暂行的文件，若不暂存它们，则提交时不会记录这些尚未暂存的变化。这个建议对于非命令行下的git而言没有必要，很多编辑器如vscode，会自动帮你检查是否有未暂存的变更</em></p>
<p>推荐使用git commit，带一个-m参数提交，此时需要添加提交信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;test using -m flag&quot;</span></span></span><br><span class="line">[master 4a2101a] test using -m flag</span><br><span class="line"> 4 files changed, 15 insertions(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"> create mode 100644 src/src1.txt</span><br><span class="line"> create mode 100644 src/src2.txt</span><br></pre></td></tr></table></figure>
<p>提交后会显示当前提交的分支，完整SHA-1校验和，修改了多少文件，多少行添加和修改过</p>
<p><strong>跳过使用暂存区</strong>：在提交时加上-a选项，git会自动把所有跟踪的文件暂存并提交，省略手动git add的步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;test using -a flag&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="删除文件–git-rm"><a href="#删除文件–git-rm" class="headerlink" title="删除文件–git rm"></a>删除文件–git rm</h2><p>可以使用git rm &lt;file/regex&gt;命令能够移除工作目录中和暂存区文件，如果文件已修改或暂存，则需要用-f强制执行。使用系统自带的rm命令或手动删除，不会影响到暂存区，需要再暂存一次才能影响到下次提交。</p>
<p>我个人习惯是，保证该文件未修改，这样之前的修改保存到记录里，又避免暂存区里留有这个文件，然后git rm这个文件。</p>
<p>如果仅是放弃追踪，则使用 git rm –cached &lt;file&#x2F;regex&gt;选项，这不会伤害到之前的版本和工作目录，仅是放弃追踪，顺带删除暂存区文件。</p>
<h2 id="移动文件–git-mv"><a href="#移动文件–git-mv" class="headerlink" title="移动文件–git mv"></a>移动文件–git mv</h2><p>git对于移动、重命名文件使用git mv命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br></pre></td></tr></table></figure>
<p>这个重命名操作等价于:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>

<p>注意理解，git rm的行为可以理解为一个原文件的移动操作的，只是新位置却不存在那个文件，需要额外的git add那个文件</p>
<h2 id="查看提交历史–git-log"><a href="#查看提交历史–git-log" class="headerlink" title="查看提交历史–git log"></a>查看提交历史–git log</h2><p>查看提交历史的工具为git log命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>
<p>不传入任何参数的情况下，git log会按照时间先后顺序列出所有的提交。git log的参数各种各样，这里不详细列出。常用选项如下：</p>
<ul>
<li>选项–stat，额外显示每次提交的简略统计信息</li>
<li>选项-<n>，显示最近n条提交</li>
<li>选项–since,–after，如 –since&#x3D;2.weeks</li>
<li>选项–until,–before</li>
<li>选项–author,–committer ，</li>
<li>选项–grep，显示提交说明中包含指定字符串的提交</li>
<li>选项–no-merges，隐藏合并提交的历史</li>
</ul>
<h2 id="撤销操作（不建议使用）"><a href="#撤销操作（不建议使用）" class="headerlink" title="撤销操作（不建议使用）"></a>撤销操作（不建议使用）</h2><p>git中任何提交过的东西都是可以恢复的，删除文件、解除追踪也不会改变之前提交过的文件。但是对于在暂存和已修改文件，如果没有妥善操作，丢失后可能再也找不到了</p>
<p><strong>补体交</strong>：<br>运行带有–amend选项的提交命令可以补充并重新提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;first commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend [-m <span class="string">&quot;this message overwrite the before&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>这个“修补提交”命令，是对上一次提交的补充和覆盖，如果带上-m选项，则会覆盖旧提交信息。之前提交的存在不会被记录，像是撤销了上次的提交</p>
<p><em>尽管通过专业手段可以找到旧提交信息，但在一般使用时，git commit –amend 命令是有些危险的</em></p>
<p><strong>撤销文件的暂存</strong>：<br>删除暂存文件使用git restore –staged命令（以git status给出的提示为准，教程上的是git reset）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore --staged test1.txt</span></span><br></pre></td></tr></table></figure>
<p><em>撤销文件的暂存是一个很危险的命令，如果加上–hard选项更是如此。当在修改了工作目录的文件，又取消了暂存的时候，那么这个暂存的内容将会丢失</em></p>
<p><strong>撤销对文件的修改</strong>：<br>撤销对文件的修改，包括撤销文件删除操作（以git status给出的提示为准）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore file2.txt</span></span><br></pre></td></tr></table></figure>
<p><em>撤销对文件修改命令是一个很危险的命令，工作目录的文件会被最近的旧版本覆盖，不会留有记录</em></p>
<h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>使用<strong>git remote</strong>命令，可以查看已经配置的远程仓库服务器。加上-v选项可以查看对应的url：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br></pre></td></tr></table></figure>

<p>使用<strong>git remote show &lt;remote&gt;</strong> 命令可以查看这个服务器的分支状态（new、tracked、stale），fetch地址，push地址，当前所处分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br></pre></td></tr></table></figure>

<h2 id="添加和移除远程仓库"><a href="#添加和移除远程仓库" class="headerlink" title="添加和移除远程仓库"></a>添加和移除远程仓库</h2><p>使用<strong>git remote add</strong>命令添加一个新的远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add [&lt;shortname&gt;] &lt;url&gt;</span> </span><br></pre></td></tr></table></figure>
<p>shortname是在本机上自定义的远程仓库名称，以后在拉去和推送代码时，可以使用该名称。git remote rename oldname newname 可以更改简称</p>
<p><em>如果使用clone命令克隆了一个仓库，会自动将其添加为远程仓库，并以orgin简写</em></p>
<p>使用**git remote remove &lt;remote&gt;**移除一个远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove ppdd</span></span><br></pre></td></tr></table></figure>

<h2 id="抓取、拉去和推送"><a href="#抓取、拉去和推送" class="headerlink" title="抓取、拉去和推送"></a>抓取、拉去和推送</h2><p>命令<strong>git fetch &lt;remote&gt;<strong>会访问远程仓库，拉取本地仓库还没有的数据。这些数据下载到本地后，需要用户</strong>手动合入</strong>当前工作</p>
<p>如果你的当前分支设置了跟踪远程分支，命令<strong>git pull</strong>会抓取远程分支，并<strong>自动合并</strong>到当前分支。默认情况下git clone会自动设置本地master追踪远程仓库master</p>
<p>使用**git push &lt;remote&gt; &lt;branch&gt;**将分支推送至远程服务器。执行这条命令需要的条件是，当前用户具有写入权限，且上次拉取前没有人推送过，实际上往往 git pull，git push 是一个双连操作</p>
<h1 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h1><h2 id="标签的作用"><a href="#标签的作用" class="headerlink" title="标签的作用"></a>标签的作用</h2><p>git可以给仓库历史中某一个提交打上标签，比较有代表性的是，标记发布节点（v1.0、v2.0等）。标签有轻量标签（lightweight）和附注标签（annotated），轻量标签是某个提交的引用，附注标签是存储的一个完整数据对象，包含打标签者的名字、电子邮件、日期，此外还有一个标签信息，并且可以使用GPG签名验证。标签本身是一个文件，含有自己的校验和</p>
<h2 id="列出标签、查看标签信息"><a href="#列出标签、查看标签信息" class="headerlink" title="列出标签、查看标签信息"></a>列出标签、查看标签信息</h2><p>git tag命令可以列出已有标签，可以带上选项-l或–list：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag [-l]</span></span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br><span class="line">v2.0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&quot;v2.*&quot;</span></span></span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure>

<p>git show xxx命令可以查看这个标签的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show v1.1</span><br></pre></td></tr></table></figure>

<h2 id="打标签-1"><a href="#打标签-1" class="headerlink" title="打标签"></a>打标签</h2><p>创建<strong>附注标签</strong>最简单的方式是，运行git tag时指定-a选项。下面代码创建了最近一次提交的附注标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>创建<strong>轻量标签</strong>只需要提供标签名字，轻量标签的本质是将“提交检验和”存储到一个文件中，这个标签相当于某个提交的引用。下面代码创建了最近一次提交的轻量的标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-light</span></span><br></pre></td></tr></table></figure>

<p>可以<strong>给过去的一个提交打标签</strong>，需要额外加上一个提交的校验和（或可确定唯一提交的校验和前缀）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02 -m <span class="string">&quot;my version 1.2&quot;</span></span></span><br></pre></td></tr></table></figure>


<h2 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h2><p>默认情况下，git push命令不会传送标签到远程服务器上，需要使用git push &lt;remote&gt; &lt;tagname&gt;来显示推送标签。当标签名为 –tags 时，推送不在服务器上的所有标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br></pre></td></tr></table></figure>

<h2 id="删除并同步删除标签"><a href="#删除并同步删除标签" class="headerlink" title="删除并同步删除标签"></a>删除并同步删除标签</h2><p>要删除本地仓库上的标签，可以使用git tag -d &lt;tagname&gt;命令。移除远程仓库的标签使用 git push &lt;remote&gt; –delete &lt;tagname\：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4</span></span><br><span class="line">Deleted tag &#x27;v1.4&#x27; (was e7d5add)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete v1.4</span></span><br></pre></td></tr></table></figure>


<h2 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h2><p>如果想查看某个标签所指向的文件版本，可以使用git checkout，但这个命令有不少副作用，如分离头指针，因此最好搭配创建分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b branchVersion2 v2.0</span></span><br><span class="line">Switched to a new branch &#x27;branchVersion2&#x27; </span><br></pre></td></tr></table></figure>
<p>在这个分支下的新提交，不会影响到原来标签</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见命令记录</title>
    <url>/2022/10/12/%E5%AD%A6%E4%B9%A0/Linux%E7%9B%B8%E5%85%B3/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>暂时没有开始记录，先创建一下</p>
<span id="more"></span>
<p>linux命令大全<br><a href="https://www.runoob.com/linux/linux-command-manual.html">https://www.runoob.com/linux/linux-command-manual.html</a></p>
<p><a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux相关</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2022/10/08/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/JavaScript%E4%B8%93%E9%A2%98/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>JavaScript 是一种轻量级解释型语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画，其他等等</p>
<ul>
<li>2022-10-17 完成JavaScript基础部分的整理</li>
<li>2022-11-07 重新复习整理了一次</li>
</ul>
<span id="more"></span>

<h1 id="JavaScript基本"><a href="#JavaScript基本" class="headerlink" title="JavaScript基本"></a>JavaScript基本</h1><h2 id="JavaScript的API"><a href="#JavaScript的API" class="headerlink" title="JavaScript的API"></a>JavaScript的API</h2><p>JavaScript的应用程序接口API通常分为两类：</p>
<ul>
<li>浏览器API<br>  浏览器API内建与web浏览器中。有：<ul>
<li>文档对象模型（DOM，Document Object Model）API、</li>
<li>地理位置API </li>
<li>画布（Canvas）和WebGL API可以创建生动的2D和3D图像</li>
<li>影音类API</li>
</ul>
</li>
<li>第三方API（笔记中不会涉及这些知识）<br>  如Twitter API可以在网站上显示最新的推文，谷歌地图API 可以在网站上嵌入定制的地图</li>
</ul>
<h2 id="JavaScript在页面上工作"><a href="#JavaScript在页面上工作" class="headerlink" title="JavaScript在页面上工作"></a>JavaScript在页面上工作</h2><p>在HTML和CSS集合组装成一个网页后，浏览器的JavaScript引擎将执行JavaScript代码。这样的顺序是比较合理的，因为JavaScript的普遍用处是通过DOM API动态修改HTML和CSS。</p>
<p>实际上在未加载完HTML时就执行Javascript代码是可能的，但这需要妥善安排脚本调用策略</p>
<p>每个浏览器标签页就是其自身用来运行代码的独立容器，大多数情况下代码是独立运行的 <em>（以安全方式在不同标签页中传输代码和数据的方式是存在的，笔记中不会涉及）</em></p>
<h2 id="向页面添加JavaScript"><a href="#向页面添加JavaScript" class="headerlink" title="向页面添加JavaScript"></a>向页面添加JavaScript</h2><h3 id="外部脚本调用策略"><a href="#外部脚本调用策略" class="headerlink" title="外部脚本调用策略"></a>外部脚本调用策略</h3><p>CSS使用&lt;link&gt;元素连接外部样式表，用&lt;style&gt;添加内嵌样式表；而外部JavaScript的在HTML文件中使用&lt;script&gt;来调用脚本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--async是异步属性，这个脚本不会中断后续html--&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于可能引起文档体改变的代码，如DOMContentLoaded时触发的js的调用，应该放在body标签的底部。对于需要顺序执行的脚本，需要使用defer属性</p>
<p>上面执行js了脚本后，文件内的变量、函数都会存在于当前标签页的<strong>环境</strong>中，此时在控制台或者html中调用其中函数都是可能的，下面的代码添加的事件的处理方法是已引入脚本中的函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--内联事件处理器，正常情况下不要使用。这里仅是为了提高理解而做演示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;xxxFunc()&#x27;</span>&gt;</span>btn1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调用js的script标签甚至可以在这个标签后面--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里处理过程可能还没加载好，触发点击事件后才会用函数名进行查找--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内部脚本调用策略"><a href="#内部脚本调用策略" class="headerlink" title="内部脚本调用策略"></a>内部脚本调用策略</h3><p>内部JavaScript写在HTML文件中，代码内容包围在 &lt;script&gt; 元素中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//这是一个推荐结构</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//...</span></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内部JavaScript采用添加监听“DOMContentLoaded”事件（即HTML文档提加载、解释完毕）的结构调用代码，这样穿插在html文档中也不会造成未知行为</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释，使用双斜杠( // )添加单行注释</p>
<p>多行注释，使用 /* … */ 的方式添加多行注释</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量是存储值的容器，可以是数字、字符串、函数、对象等。JavaScript是一种“动态类型语言”，不需要指定变量是什么类型（也许容器本就没有类型），浏览器使用变量时会根据内容自动推断类型</p>
<p>变量类型有：</p>
<ul>
<li>Number：数值类型，包括整数和浮点数</li>
<li>String：字符串类型，需要单引号或双引号包围，会视为别的变量名</li>
<li>Boolean：逻辑值类型</li>
<li>Array：数组类型，用方括号括起来，用逗号分隔多个值</li>
<li>Object：对象类型，它是一种代码结构，如 let dog&#x3D;{name:’Spot’,shout:’wangwang’};  定义了一个对象实例</li>
</ul>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>JavaScript有两种声明变量的方法，使用var关键字和使用let关键字。现在推荐使用let，因为let不会引起“变量提升”，也不允许重复声明一个变量</p>
<p>变量提升是指，由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中任意位置声明总是等效于在代码开头声明。<strong>这意味着变量可以在声明之前使用</strong>，这个行为叫做变量提升（hoisting）。</p>
<h3 id="变量初始化与更新"><a href="#变量初始化与更新" class="headerlink" title="变量初始化与更新"></a>变量初始化与更新</h3><p>声明变量的同时或者之后，使用赋值符号（&#x3D;）即可对变量初始化或更新</p>
<p><em>可以在控制台通过输入变量名的方式，来验证这个变量是否存在，值是什么。空值的变量会返回 undefined，不存在的变量会得到一个报错信息</em></p>
<h2 id="数字与运算符"><a href="#数字与运算符" class="headerlink" title="数字与运算符"></a>数字与运算符</h2><p>注意一下比较运算符（&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D;），其余与一般语言类似，暂时不记录</p>
<h2 id="字符串作为对象"><a href="#字符串作为对象" class="headerlink" title="字符串作为对象"></a>字符串作为对象</h2><p>字符串对象方法：</p>
<ul>
<li><strong>字符串连接：</strong>字符串字面值和字符串变量之间可以用 ‘+’ 操作符随意连接。此外，数字也可以和字符串连接</li>
<li><strong>获取长度：</strong>length 属性，如 str1.length</li>
<li><strong>查找子字符串：</strong>indexOf() 方法，会返回子字符串的索引，如 str1.indexOf(‘apple’)</li>
<li><strong>提取子字符串：</strong>slice() 方法，如 str1.slice(0,3); str1.slice(2);</li>
<li><strong>转换大小写：</strong>toLowerCase() 方法、 toUpperCase() 方法，将所有字符分别转为小写或大写，如 str1.toLowerCase();</li>
<li><strong>替换字符串某部分：</strong>replace() 方法，会替换第一次匹配成功的地方，如 str1&#x3D;str1.replace(‘beforeStr’,’afterStr’);</li>
<li><strong>字符串分割为数组：</strong>split() 方法，参数为分隔符号，如 let myArray&#x3D;myData.split(‘,’);</li>
</ul>
<p>其他对象的有关字符串方法：</p>
<ul>
<li><strong>数组转为字符串</strong>：Array的join()方法，可以指定分隔符，如 let myNewString &#x3D; myArray.join(‘;’); </li>
<li><strong>数字转化成字符串：</strong>Number对象的toString() 方法，参数可以指定进制，如 (-10).toString(2)</li>
<li><strong>字符串转化成数字：</strong>Number对象可以把参数转换成数字 （失败返回NAN，这也是一个数字类型的值），如 Number(price)</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组用方括号包围，内部用逗号分隔元素。数组内的元素不要求类型相同，甚至数组也可以作为元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> randomArr = [<span class="string">&#x27;milk&#x27;</span>, <span class="number">89</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h3><p>使用索引可以访问和修改数组中的元素，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问</span></span><br><span class="line">shopping[<span class="number">0</span>];<span class="comment">//控制台会返回该元素值</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">shopping[<span class="number">0</span>]=<span class="string">&#x27;milk&#x27;</span>;</span><br><span class="line"><span class="comment">//数组中数组的修改</span></span><br><span class="line">fruitMap[<span class="number">2</span>][<span class="number">2</span>]=<span class="string">&#x27;apple&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="把数组当作对象"><a href="#把数组当作对象" class="headerlink" title="把数组当作对象"></a>把数组当作对象</h3><p>数组对象属性或方法：</p>
<ul>
<li><strong>获取数组长度:</strong> length属性</li>
<li><strong>把数组组合为字符串：</strong>toString() 方法，如 dogNames.toString(); 这个方法会自动产生一个逗号分隔符</li>
<li><strong>把数组组合为字符串（可指定分隔符）：</strong>join()方法，如 let myNewString &#x3D; myArray.join(‘;’);</li>
</ul>
<p>数组对象元素操作的方法：</p>
<ul>
<li><strong>push()方法：</strong>如 myArray.push(‘milk’); </li>
<li><strong>pop()方法：</strong>如 let removedItem &#x3D; myArray.pop()</li>
<li><strong>unshift()方法：</strong>作用于数组开始的添加元素</li>
<li><strong>shift()方法：</strong>作用域数组开始的删除元素</li>
</ul>
<h1 id="JavaScript流程控制"><a href="#JavaScript流程控制" class="headerlink" title="JavaScript流程控制"></a>JavaScript流程控制</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="条件语句前言"><a href="#条件语句前言" class="headerlink" title="条件语句前言"></a>条件语句前言</h3><p>条件控制的很多细节，在代码形式上与C外观一直，如果某个细节没有介绍应该就是如此了</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>JavaScript中的条件判断语句 if…else… 与C外观一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Javascript中判断是否相等使用 &#x3D;&#x3D;&#x3D; 和 ！&#x3D;&#x3D; ，这个与C不同</em></p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>在JavaScript中switch的用处应该比较多，因为在网页中可能有大量的列表存在，形如以下伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice) &#123; <span class="comment">//expression可以是表达式或值</span></span><br><span class="line">  <span class="keyword">case</span> <span class="attr">choice1</span>: <span class="comment">//choice1可以是一个表达式或值</span></span><br><span class="line">    run <span class="variable language_">this</span> code;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//跳出switch语句，否则继续往下匹配</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="attr">choice2</span>:</span><br><span class="line">    run <span class="variable language_">this</span> code instead;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">default</span>: <span class="comment">//如果没有break，则default总会执行；default句子可以省略</span></span><br><span class="line">    actually, just run <span class="variable language_">this</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句中的 choice（上面伪代码中的）经常是一个html的select元素的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> select = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;select&#x27;</span>);</span><br><span class="line"></span><br><span class="line">select.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, onChangeFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onChangeFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> choice = select.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">switch</span> (choice)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三元或条件运算符"><a href="#三元或条件运算符" class="headerlink" title="三元或条件运算符"></a>三元或条件运算符</h3><p>三元或条件运算符适用于只有true和else的条件选择，可以向像表达式一样给变量赋值，也可以向代码一样独立成行（这取决于它的返回类型），形如以下伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">( condition ) ? (run <span class="variable language_">this</span> code) : (run <span class="variable language_">this</span> code instead);</span><br></pre></td></tr></table></figure>
<p><em>三元或条件运算符的第二、三个操作数可以是表达式或代码块(末尾不带分号)，这会由JavaScript解释器来识别和处理。显然C是无法这样的</em></p>
<h2 id="条件循环语句"><a href="#条件循环语句" class="headerlink" title="条件循环语句"></a>条件循环语句</h2><p>JavaScript中for、while、do-while语句循环与C外观一致，只有for语句在初始化迭代变量时使用var&#x2F;let关键字 ，而C中一般用int等具体类型声明</p>
<p><em>某些对象，如数组对象有forEach方法</em></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="浏览器内置函数"><a href="#浏览器内置函数" class="headerlink" title="浏览器内置函数"></a>浏览器内置函数</h3><p>JavaScript有许多内置的函数，它们大多数不是由JavaScript实现的，更像是C++这样更低级的系统语言编写的</p>
<p>这些内置浏览器函数并非JavaScript语言的一部分，而是浏览器API的一部分</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>形如 function() {…} 的是一个匿名函数，没有名字，自己也不会做任何事情。匿名函数通常与事件处理程序一起使用，如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myButton.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用域和冲突"><a href="#函数作用域和冲突" class="headerlink" title="函数作用域和冲突"></a>函数作用域和冲突</h3><p>所有函数的最外层被称为全局作用域，全局作用域定义的值可以在任意地方访问</p>
<p>调用外部脚本可能会产生问题，可能会因为外部脚本与本处脚本用同一个名字定义变量。因此将代码封装在函数中可以极力避免这个问题</p>
<h3 id="函数内部的函数"><a href="#函数内部的函数" class="headerlink" title="函数内部的函数"></a>函数内部的函数</h3><p>定义函数时，可以比较安全地调用函数，但对作用域的理解有区别的C等语言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myBigFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myValue;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subFunction1</span>();<span class="comment">//调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subFunction1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//这个变量要想成功调用，只有“调用时”环境里存在这个名字的变量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要从脚本语言理解变量：第二个函数自身本不知道有个myValue变量（如果是编译型语言肯定会报错），但是代码执行到“调用时”环境中，并且调用这个函数时，浏览器可以从当前环境里寻找名为myValue的变量</p>
<p>看上去，实际上大量的JavaScript代码都是通过“函数内部的函数”来实现封装，这样既避免了加载html时调用，也避免了变量名冲突</p>
<h2 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h2><h3 id="事件和事件处理器"><a href="#事件和事件处理器" class="headerlink" title="事件和事件处理器"></a>事件和事件处理器</h3><p>在Web中可能发生很多事件，如：在某个元素上鼠标点击或悬停，用户按下某个按键，用户调整浏览器大小，一个网页停止加载，提交表单，播放视频，关闭错误。<em>网络事件不是JavaScript语言的核心，它们被定义成内置于浏览器的APIs</em></p>
<p>每个可用的事件都会有一个事件处理器（也叫事件监听器），也就是事件触发时会运行的代码块，这个代码块既监听事件也处理事件</p>
<h3 id="添加事件处理器"><a href="#添加事件处理器" class="headerlink" title="添加事件处理器"></a>添加事件处理器</h3><p><strong>内联事件处理器（不建议的方法）</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;bgChange()&quot;</span>&gt;</span>Press me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>事件处理属性</strong>：处理事件的函数可以被赋给元素对象的特定属性并实现监听效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//它明显的缺点是不能添加多个处理器</span></span><br><span class="line">btn.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>监听函数addEventListener</strong>：能给同一个监听器触发多个处理器，复杂项目更建议使用这种方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,cliFun);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cliFun</span>(<span class="params"></span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移除处理器"><a href="#移除处理器" class="headerlink" title="移除处理器"></a>移除处理器</h3><p>对于使用事件处理器属性，移除处理器只要对该属性赋空即可。对于使用监听函数添加的处理器，使用removeEventListener函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,cliFun);</span><br><span class="line"><span class="comment">//究竟是怎样匹配到它的，这里不做研究</span></span><br></pre></td></tr></table></figure>

<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>有时候在事件处理函数内部，会带上一个event、evt、e，它们的意思是相同的，表示一个<strong>事件对象</strong>，它会被自动传递给处理函数</p>
<p>e的值是刚刚发生这个事件的元素转化成的对象。如果事件发生在一个按钮上，e.taregt表示按钮元素的引用，e.target.style.backgroundColor&#x3D;’red’就是修改这个按钮的背景色为红色</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bgChange</span>(<span class="params">e</span>) &#123; <span class="comment">//e这个参数会自动传递到函数这里</span></span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">&#x27;rgb(&#x27;</span> + <span class="title function_">random</span>(<span class="number">255</span>) + <span class="string">&#x27;,&#x27;</span> + <span class="title function_">random</span>(<span class="number">255</span>) + <span class="string">&#x27;,&#x27;</span> + <span class="title function_">random</span>(<span class="number">255</span>) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = rndCol;<span class="comment">//修改触发事件的按钮的背景色</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);<span class="comment">//输出这个对象的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, bgChange);</span><br></pre></td></tr></table></figure>

<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>有些浏览器支持自动的表单验证功能，但这很可能不是想要的，因此需要自己添加一个事件处理程序。在这个处理程序里面，要先显示调用e.preventDefault()来阻止默认行为，然后再写上自定义行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">form.<span class="property">onsubmit</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();<span class="comment">//覆盖默认行为</span></span><br><span class="line">    <span class="comment">//自定义其他行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>默认情况下，所有事件处理程序都是在冒泡阶段注册的。冒泡是先执行本身事件处理程序，再执行外部的。这可能会引起讨厌的行为，标准事件对象具有名为 stopPropagation() 的函数来阻止冒泡行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">video.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();<span class="comment">//阻止冒泡</span></span><br><span class="line">  <span class="comment">//当前处理程序行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>子节点的事件可以委托父节点监听，让这个事件冒泡到父节点上。常用的情形是，想要让每个列表项&lt;li&gt;点击时弹出信息，则可以将click单击事件监听器放在父元素上，这样事件就会冒泡到父元素&lt;ul&gt;上了</p>
<h1 id="JavaScript对象介绍"><a href="#JavaScript对象介绍" class="headerlink" title="JavaScript对象介绍"></a>JavaScript对象介绍</h1><h2 id="创建对象并访问"><a href="#创建对象并访问" class="headerlink" title="创建对象并访问"></a>创建对象并访问</h2><p>创建一个对象的方式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  name : &#123;</span><br><span class="line">    firstName : <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    lastName : <span class="string">&#x27;Smith&#x27;</span>, </span><br><span class="line">  &#125;,</span><br><span class="line">  age : <span class="number">32</span>,</span><br><span class="line">  greeting : <span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;,</span><br><span class="line">  intersts : [<span class="string">&#x27;music&#x27;</span>, <span class="string">&#x27;skiing&#x27;</span>]</span><br><span class="line">  all</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问对象可以使用点表示法和括号表示法，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问对象内一般变量</span></span><br><span class="line">person.<span class="property">age</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="comment">//访问对象内数组</span></span><br><span class="line">person.<span class="property">intersts</span>[<span class="number">0</span>]</span><br><span class="line">person[intersts][<span class="number">0</span>]</span><br><span class="line"><span class="comment">//访问对象内对象</span></span><br><span class="line">person.<span class="property">name</span>.<span class="property">first</span></span><br><span class="line">person[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;first&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><em>使用括号表示法看上去很像数组–对象做了字符串到值得映射，数组做的是数字到值得映射</em></p>
<p>设置成员对象时，如果该成员本不存在，那么会自动创建</p>
<h2 id="基于原型"><a href="#基于原型" class="headerlink" title="基于原型"></a>基于原型</h2><p>JavaScript的每个对象都拥有一个原型对象，对象以其原型为模板，继承其方法和属性（通过链接）。原型对象也可能拥有一个原型，一层一层继承，形成原型链。特别地，函数也有属性，且每个函数都有一个特殊属性–原型（prototype）</p>
<p>（更多部分暂时不记录）</p>
<h2 id="JavaScript中的类"><a href="#JavaScript中的类" class="headerlink" title="JavaScript中的类"></a>JavaScript中的类</h2><p>在函数一节中，提到过在JavaScript中，函数具有封装能力（函数本身就是对过程的封装，而JS中函数封装的过程得范围更大）。而类是对对象的封装，本节记录的类的封装和函数实现的封装有何不同，需要细细观察</p>
<p>有所了解的是，函数是一个具体的对象，可以被别的函数继承，别的函数可以通过委托的方式沿着原型链调用函数（这些细节没有记录在本帖）；类则是一类对象的抽象，可以被别的类继承</p>
<h3 id="声明一个类"><a href="#声明一个类" class="headerlink" title="声明一个类"></a>声明一个类</h3><p>声明一个类有多种方法，一种是是用class关键字声明一个类，进行比较严格的封装；另一种是在“外部环境”下，定义一个与类名相同的构造器函数</p>
<p><strong>在“外部环境”定义构造器</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个构造器，来实现声明一个类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Ball</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在“外部环境”使用prototype，定义这个类的方法</span></span><br><span class="line"><span class="title class_">Ball</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">drawBall</span>=<span class="keyword">function</span>&#123;...&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用class关键字</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="comment">//定义变量</span></span><br><span class="line">  name;</span><br><span class="line">  age=<span class="string">&#x27;&#x27;</span>；<span class="comment">//指定默认值的方式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现一个构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name;<span class="comment">//注意，要想用到对象内变量，必须显示指定this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义函数</span></span><br><span class="line">  <span class="title function_">introduceSelf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p>在class关键字定义一个类时，构造函数使用constructor关键字声明，执行这个函数时，它会：</p>
<ul>
<li>创建一个新的对象</li>
<li>在对象内，将this绑定到这个对象上，然后构造函数中就可以使用this来引用这个对象</li>
<li>执行构造函数中的代码</li>
<li>返回这个新对象</li>
</ul>
<p>使用类的构造函数，创建一个实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用类的名字来调用构造函数</span></span><br><span class="line"><span class="keyword">const</span> jojo = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jojo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果不需要特殊的初始内容，可以省略构造函数，而默认的构造函数会被自动生成</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>可以使用extends关键字声明这个类继承自另一个类，注意子类的构造函数的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Professor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">  teaches;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">personName, professorTeaches</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(personName);<span class="comment">//先构造父类</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">teaches</span> = professorTeaches;<span class="comment">//再构造仅属于子类部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的构造函数的第一件事情，是使用super()来调用父类的构造方法，然后再设置仅属于子类的部分</p>
<h3 id="封装–定义私有变量"><a href="#封装–定义私有变量" class="headerlink" title="封装–定义私有变量"></a>封装–定义私有变量</h3><p>JavaScript定义一个私有变量的方法，是从命名规则上实现的，对于以井号(#)开头的属性或函数，都会被定义为私有的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">  #somePrivateVar;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">somePrivateMethod</span>(<span class="params"></span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用JSON数据"><a href="#使用JSON数据" class="headerlink" title="使用JSON数据"></a>使用JSON数据</h2><p>注意事项：</p>
<ul>
<li>JSON是一种纯数据格式，只包含属性，没有方法；</li>
<li>JSON要求属性名和字符串用双引号包围，单引号无效</li>
<li>JSON文件的容错较低，一个错位的逗号或分号就会导致JSON文件出错</li>
</ul>
<h3 id="在HTML页面中加载json对象"><a href="#在HTML页面中加载json对象" class="headerlink" title="在HTML页面中加载json对象"></a>在HTML页面中加载json对象</h3><p>为了载入json到页面中，需要使用一个名为XMLRequset的API</p>
<p>XHR是一个非常有用的JavaScript对象，能够通过代码向服务器请求资源文件（图片、文本、JSON、HTML片段）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestURL = <span class="string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//设置这个请求的参数</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,requestURL);</span><br><span class="line">request.<span class="property">responseType</span>=<span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"><span class="comment">//send方法发送请求</span></span><br><span class="line">request.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//onload事件是浏览器解析完页面之后就会自动触发的。处理返回的数据</span></span><br><span class="line">request.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aJsonObj = request.<span class="property">response</span>;<span class="comment">//获得json对象</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  现在已经获取到请求响应的json格式数据</span></span><br><span class="line"><span class="comment">  可以用它修改页面显示，或做其他操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在HTML页面上显示json数据"><a href="#在HTML页面上显示json数据" class="headerlink" title="在HTML页面上显示json数据"></a>在HTML页面上显示json数据</h3><p>上面的步骤中已经获得了一个json对象，利用它在页面的上添加数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;header&#x27;</span>);</span><br><span class="line"><span class="comment">//在html页面添加一个h1标签，标签内容为获得的json数据的某部分</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addJsonData</span>(<span class="params">aJsonObj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> myHearder=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">  myHeader.<span class="property">textContent</span>=aJsonObj[<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line">  header.<span class="title function_">append</span>(myHeader)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON对象和文本的转换"><a href="#JSON对象和文本的转换" class="headerlink" title="JSON对象和文本的转换"></a>JSON对象和文本的转换</h3><p>对于一个XHR而言，获得json对象只需要设定这个请求的返回格式是json，然后获取“返回报文”即可（此时返回值自动设定为是json对象类型）</p>
<p>但是，有时需要将一些字符串转为json数据，或者把一些数据转为json对象，这时需要使用浏览器内置的两个方法：</p>
<ul>
<li>JSON.parse()：以文本字符串形式接收json数据，返回一个json对象</li>
<li>JSON.stringify()：接受一个对象作为参数，返回一个对应的json字符串</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>JavaScript专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习一：初次配置</title>
    <url>/2022/09/29/%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0/git%E5%AD%A6%E4%B9%A0%E4%B8%80%EF%BC%9A%E5%88%9D%E6%AC%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>第一次安装和配置git，以及初始化一个仓库</p>
<p>参考 <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p>
<span id="more"></span>

<h1 id="安装和初次配置git"><a href="#安装和初次配置git" class="headerlink" title="安装和初次配置git"></a>安装和初次配置git</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在CentOS上安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install git</span></span><br></pre></td></tr></table></figure>

<p>在windows上安装则可以到官网下载。源码安装的方式不记录了。</p>
<p>参考资料中使用的是git2.8，下面的所有代码演示都以我系统上的版本git2.27为准</p>
<h2 id="git的配置文件"><a href="#git的配置文件" class="headerlink" title="git的配置文件"></a>git的配置文件</h2><p>git自带一个 git config 工具，帮助设置外观和行为的配置变量。这些变量存储在三类文件中（以linux的文件系统为例）：</p>
<ol>
<li>全局级别，优先级最低。 &#x2F;etc&#x2F;gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。传递–system参数会读写该文件</li>
<li>用户级别，优先级高于全局。 ~&#x2F;.gitconfig 或 ~&#x2F;.git&#x2F;.gitconfig文件，只针对当前用户。传递–global参数会读写该文件，对系统上当前用户的所有仓库生效</li>
<li>仓库级别，优先级高于用户级。当前使用仓库的的.git&#x2F;config文件，只针对该仓库，传递–local参数会让git强制读写该文件（默认情况下用的就是它）</li>
</ol>
<h2 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h2><p>列出git当前可以找到的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br></pre></td></tr></table></figure>
<p>会从三个级别的配置文件中读取，可能会读到重复的变量名，git实际应用的是最后一项</p>
<p>可以输入 git config &lt;key&gt; 检查git的某一项配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br></pre></td></tr></table></figure>

<p>可以使用以下命令查看所有配置，及所在文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list --show-origin</span></span><br></pre></td></tr></table></figure>

<p>可以使用 git config –show-origin &lt;var&gt; 查看某个变量的所在的配置文件，及变量值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --show-origin user.name</span></span><br></pre></td></tr></table></figure>

<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>设置用户名和邮件地址，每一个git提交都会使用这些信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;xxx&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;xxx@xxx.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>通常情况下git config使用–global参数，配置全局设置，除非需要对特定项目使用特别的配置。如果想针对某个特定项目（仓库级别）配置，则需要将进入那个项目，使用没有该参数的命令来配置</p>
<p>此外，还常常用SSH连接的方式，在github等代码托管平台上进行拉取推送。这里把创建一对密钥也作为基本的配置工作。生成密钥对的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面的密钥生成指令，用的是当前github推荐的加密算法的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>密钥文件建议按默认位置保存，密码按需设定后，可以在 ~&#x2F;.ssh 目录下看到两个密钥文件 id_rsa 和 id_rsa.pub ，其中带pub后缀的是公钥，需要让git服务器知晓，在github上则是把id_rsa.pub配置上去</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>记录--centos下vsftpd配置</title>
    <url>/2022/09/27/%E5%AD%A6%E4%B9%A0/Linux%E7%9B%B8%E5%85%B3/%E8%AE%B0%E5%BD%95--centos%E4%B8%8Bvsftp%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>为方便不懂计算机的朋友配置一个博客，启用一个ftp服务来传输文件。配置过程中发现 Xshell + Xftp 工具及其方便（而且更安全），最终没有采用ftp方法，但还是简要记录一下关键地方</p>
<span id="more"></span>
<h1 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y vsftp</span><br></pre></td></tr></table></figure>

<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><h2 id="配置vdftp-conf"><a href="#配置vdftp-conf" class="headerlink" title="配置vdftp.conf"></a>配置vdftp.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure>
<p>修改以下字段：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO #禁止匿名登录</span><br><span class="line"></span><br><span class="line">local_unmask=750 #便于用户修改</span><br><span class="line"></span><br><span class="line">chroot_local_users=YES #启用这个会让 local_users 文件里的用户无法在ftp客户端更改目录</span><br><span class="line">chroot_list_enable=NO #设置为NO会让 user_list 里的用户无法登录</span><br><span class="line"></span><br><span class="line">local_root=/var/www/ftphome #指定访问ftp时的默认目录</span><br><span class="line"></span><br><span class="line">#配置被动模式</span><br><span class="line">pasv_enabl=YES</span><br><span class="line">pasv_address=服务器的公网ip</span><br><span class="line">pasv_min_port=允许的最小高位端口 #需要在安全组上通过</span><br><span class="line">pasv_min_port=允许的最高高位端口 #需要在安全组上通过</span><br></pre></td></tr></table></figure>

<h2 id="用户和文件管理"><a href="#用户和文件管理" class="headerlink" title="用户和文件管理"></a>用户和文件管理</h2><p>添加用户、修改文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd -g 1001 ftpusers</span><br><span class="line">mkdir /var/www</span><br><span class="line">mkdir /var/www/ftphome</span><br><span class="line">useradd -d /var/www/ftphome -g ftpusers -s /sbin/nologin fuser</span><br><span class="line">passwd fuser</span><br><span class="line"></span><br><span class="line">chown -R fuser:ftpusers /var/www/ftphome</span><br><span class="line">chmod -R 770 /var/www/ftphome</span><br></pre></td></tr></table></figure>

<h2 id="需要注意的pam修改"><a href="#需要注意的pam修改" class="headerlink" title="需要注意的pam修改"></a>需要注意的pam修改</h2><p>注意，由于设置了用户无法登录shell，则要修改pam的认证方式：<br>编辑相关文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim  /etc/pam.d/vsftpd</span><br></pre></td></tr></table></figure>
<p>修改配置a uth required pam_shells.so修改为-&gt;auth required pam_nologin.so </p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>简单介绍firewalld配置</title>
    <url>/2022/09/25/%E5%AD%A6%E4%B9%A0/Linux%E7%9B%B8%E5%85%B3/firewall%E5%9C%A8centos7%E4%B8%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>从centos7开始，默认使用firewalld来配置防火墙（旧版的默认安装iptables）。本文简要记录一下firewalld的简单用法。</p>
<span id="more"></span>

<h1 id="firewalld简介"><a href="#firewalld简介" class="headerlink" title="firewalld简介"></a>firewalld简介</h1><p>firewalld 是由红帽开发的防火墙守护进程， 默认使用 nftables（一个网络过滤器）</p>
<p>firewalld支持动态管理（无需关闭用户连接即可更新），支持使用区域zone来标识可信等级，使用分离的运行时配置和永久设置。</p>
<p>firewall配置文件存储在 &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F; 和 &#x2F;etc&#x2F;firewall&#x2F; 目录中：</p>
<ol>
<li>系统配置目录，目录中存放定义好的网络服务和端口参数，系统参数，不要修改 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 /usr/lib/firewalld/</span><br><span class="line">2 /usr/lib/firewalld/services</span><br><span class="line">3 /usr/lib/firewalld/zones</span><br></pre></td></tr></table></figure></li>
<li>用户配置目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 /etc/firewalld/</span><br><span class="line">2 /etc/firewalld/services</span><br><span class="line">3 /etc/firewalld/zones</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="centos下安装和基本使用"><a href="#centos下安装和基本使用" class="headerlink" title="centos下安装和基本使用"></a>centos下安装和基本使用</h1><ul>
<li>yum install firewalld</li>
<li>启用服务 systemctl start firewalld.service</li>
<li>可以使用控制台工具 firewall-cmd 来控制防火墙规则，firewall-offline-cmd是服务离线时的配置工具</li>
<li>firewall-config命令提供了一个图形界面</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用 firewall-cmd 可用于运行时更改配置，这些大部分配置会在重启后失效，使用–permanent参数可以永久配置（这不会更改运行时配置，可以使用–reload重载规则）</p>
<h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><p>区域（zone）是一系列可用于指定接口的规则</p>
<h3 id="区域命令"><a href="#区域命令" class="headerlink" title="区域命令"></a>区域命令</h3><p>有关区域的命令：</p>
<ul>
<li>查看当前区域机器应用的接口  firewall-cmd –get-active-zone</li>
<li>列出所有区域的配置  firewall-cmd –list-all-zone</li>
<li>列出指定区域的配置  firewall-cmd –info-zone&#x3D;<em>zone_name</em></li>
<li>更改接口的区域  firewall-cmd –zone&#x3D;<em>zone_name</em> –change-interface&#x3D;<em>interface_name</em></li>
</ul>
<p>一些命令需要传递区域参数 –zone&#x3D;<em>zone_name</em> ，若不指定则使用默认区域</p>
<p>可以查询、更改默认区域：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询默认区域</span></span><br><span class="line">firewall-cmd --get-default-zone</span><br><span class="line"><span class="comment">#更改默认区域为public；注意，这个改变时临时的</span></span><br><span class="line">firewall-cmd --set-default-zone=public</span><br></pre></td></tr></table></figure>

<p>区域特性的规则集为：</p>
<ul>
<li>drop：丢弃任何接收的网络数据包，仅有能发送出的去网络连接</li>
<li>block：任何接收的网络连接都被ipv4的cmp-host-prohibited信息和ipv6的icmp6-adm-prohibited信息拒绝</li>
<li>public：这个是firewalld的默认值，不相信网络内其他计算机，只能接受经过选取的连接</li>
<li>external：似乎与public（，目前查到的资料对这一点描述混乱）</li>
<li>dmz：非军事区</li>
<li>work：可以基本相信网络内其他计算机，仅仅接收经过选择的连接</li>
<li>home：基本相信网络内其他计算机，仅仅接收经过选择的连接</li>
<li>internal：内部，基本相信网络内其他计算机，仅仅接受经过选择的连接</li>
<li>trusted：可接受所有网络连接</li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务时为特定守护程序预配置的规则，例如匹配SSH的服务在被分配到一个区域后会开放22端口</p>
<p>列出、查询服务信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出所有可用服务</span></span><br><span class="line">firewall-cmd --get-service</span><br><span class="line"><span class="comment">#查询特定服务的信息</span></span><br><span class="line">firewall-cmd --info-service service_name</span><br></pre></td></tr></table></figure>

<p>添加、移除服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加一个服务到public区域</span></span><br><span class="line">firewall-cmd --zone=public --add-service service_name</span><br><span class="line"><span class="comment">#从public区域移除一个服务</span></span><br><span class="line">firewall-cmd --zone=public --remove-service service_name</span><br></pre></td></tr></table></figure>

<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>可以直接在指定区域上端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给public区域开放10034端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port 10034</span><br><span class="line"><span class="comment">#给public区域移除10034端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port 10034</span><br></pre></td></tr></table></figure>

<h2 id="NAT地址伪装"><a href="#NAT地址伪装" class="headerlink" title="NAT地址伪装"></a>NAT地址伪装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#firewall和iptable都可进行NAT地址伪装的效果；以下两条命令有相同效果</span></span><br><span class="line">firewall-cmd --zone=public --add-masquerade</span><br><span class="line">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>

<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>如果在路由器上配置了firewalld，而且还如上开启了NAT地址伪装，则通过firewalld设置端口转发很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将外部端口上的 12345/tcp 端口转发到内部网络 10.20.30.40 的 22 （标准 SSH） 端口</span></span><br><span class="line">firewall-cmd --zone=public --add-forward-port=12345:proto=tcp:toport=22:toaddr=10.20.30.40</span><br><span class="line"><span class="comment">#移除此端口转发</span></span><br><span class="line">firewall-cmd --zone=public --remove-forward-port=port=12345:proto=tcp:toport=22:toaddr=10.20.30.40</span><br></pre></td></tr></table></figure>

<h1 id="设置有效时间"><a href="#设置有效时间" class="headerlink" title="设置有效时间"></a>设置有效时间</h1><h2 id="设置端口或服务的有效时间"><a href="#设置端口或服务的有效时间" class="headerlink" title="设置端口或服务的有效时间"></a>设置端口或服务的有效时间</h2><p>使用 –timeout&#x3D;<em>value</em> 可以设置端口或服务的有效时间，默认单位为秒，可添加后缀m（分）、h（小时）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置SSH服务的有效时间为3小时</span></span><br><span class="line">firewall-cmd --add-service ssh --<span class="built_in">timeout</span>=3h</span><br></pre></td></tr></table></figure>
<p>注意， –timeout&#x3D;<em>value</em> 和 –permanent 互斥</p>
<h2 id="将运行时设置配置持久化"><a href="#将运行时设置配置持久化" class="headerlink" title="将运行时设置配置持久化"></a>将运行时设置配置持久化</h2><p>可以将运行时的配置持久化； 添加 –permanent 则是设定持久化规则，并不会生效为运行时规则（除非–reload重载）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --runtime-to-permanent</span><br></pre></td></tr></table></figure>

<h2 id="检查服务配置"><a href="#检查服务配置" class="headerlink" title="检查服务配置"></a>检查服务配置</h2><p>默认支持的服务的配置文件存放在 /usr/lib/firewalld/service/<br>用户创造的服务文件存放在 /etc/firewalld/sercices/</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux相关</category>
      </categories>
  </entry>
  <entry>
    <title>CSS页面排版</title>
    <url>/2022/09/21/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/CSS%E4%B8%93%E9%A2%98/CSS%E9%A1%B5%E9%9D%A2%E6%8E%92%E7%89%88/</url>
    <content><![CDATA[<ul>
<li>2022-09-23 暂时搁置CSS排版的整理，预计几天后重启<span id="more"></span></li>
</ul>
<h1 id="介绍CSS布局"><a href="#介绍CSS布局" class="headerlink" title="介绍CSS布局"></a>介绍CSS布局</h1><p>在CSS中实现页面布局的主要方法是设定display属性的值。正常流中所有内容都有一个display值：</p>
<ul>
<li>表现为块级设置 display:block; 如&lt;li&gt;的display默认为block</li>
<li>表现为内联设置为 display:inline;  </li>
<li>不会换行的块展示 display:inline-block; </li>
<li>弹性盒子 display:flex;</li>
<li>grid布局 display:grid;</li>
</ul>
<p>此外还有几种微调元素的操作，如浮动和定位，它们对设计特殊元素很有帮助</p>
<h2 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h2><p>Flexbox弹性盒子主要用于创建一维页面布局（横向或纵向），flex-direction默认row，即默认横向</p>
<p>这个例子中设置了父元素的display:flex ，以及子元素的flex属性（注释掉了）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/*把display:flex添加到父元素上时，三个子元素会自动按行排列，此时容器宽度会适应元素*/</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/*如果这样，子元素应用flex项，子元素会伸缩来填充容器，这样会充满一行*/</span></span></span><br><span class="line"><span class="language-css"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-css">.warpper &gt; div&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    flex: 1;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">*/</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>Grid设计用于把元素按行和列整齐排列，像一个网格一样，允许用“填色”的方法设定自己的元素的大小和位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box6&quot;</span>&gt;</span>Six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*统一设定子元素规则*/</span></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形如：</span></span><br><span class="line"><span class="comment">  --------   --------   --------</span></span><br><span class="line"><span class="comment">  |One   |   |TWO   |   |Three |</span></span><br><span class="line"><span class="comment">  --------   --------   --------</span></span><br><span class="line"><span class="comment">  --------   --------   --------</span></span><br><span class="line"><span class="comment">  |Four  |   |Five  |   |Six   |</span></span><br><span class="line"><span class="comment">  --------   --------   --------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*额外设置单独元素样式*/</span></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时形如：</span></span><br><span class="line"><span class="comment">  --------   -------------------</span></span><br><span class="line"><span class="comment">  |TWO   |   |ONE              |</span></span><br><span class="line"><span class="comment">  |      |   -------------------</span></span><br><span class="line"><span class="comment">  |      |              --------</span></span><br><span class="line"><span class="comment">  |      |              |Three |</span></span><br><span class="line"><span class="comment">  --------              --------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p><em>（与页面主要结构关系不大，但能实现对元素特定操作）</em></p>
<p>设置float，把一个元素浮动起来(从正常布局流中剔除)，改变元素和跟随它的其他元素的行为。float属性有四个可能值：left、right、none、inherit </p>
<p>这个例子把一个div浮动到一段文本左侧</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        maigin-<span class="attribute">right</span>:<span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-css">形如：</span></span></span><br><span class="line"><span class="comment"><span class="language-css"></span></span></span><br><span class="line"><span class="comment"><span class="language-css">-----   xxxxxx</span></span></span><br><span class="line"><span class="comment"><span class="language-css">|左浮|  xxxxxx</span></span></span><br><span class="line"><span class="comment"><span class="language-css">-----   xxxxxx</span></span></span><br><span class="line"><span class="comment"><span class="language-css">xxxxxxxxxxxxxx</span></span></span><br><span class="line"><span class="comment"><span class="language-css">xxxxxxxxxxxxxx</span></span></span><br><span class="line"><span class="comment"><span class="language-css">*/</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>左侧浮动<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> xxxxxxx。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h2><p>与页面主要结构关系不大，但能实现找到到某个具体元素。除了标准的静态定位，其余四种定位涉及的属性相同 </p>
<h3 id="相对定位和绝对定位"><a href="#相对定位和绝对定位" class="headerlink" title="相对定位和绝对定位"></a>相对定位和绝对定位</h3><p>把正常布局流中的元素从默认位置，微调一些距离：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*让受影响的元素顶部留出30px距离，左侧留出30px距离，</span></span><br><span class="line"><span class="comment">导致了元素的向下向右移动*/</span></span><br><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绝对定位指定的推开距离是从页面边界开始，相对于是&lt;html&gt;元素的距离</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位的推开参照物是“视口”。应用这一特性。可以轻松搞出一个固定位置的菜单，而不受页面滚动的影响：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>粘性定位是静态定位和固定定位的混合。当一个元素被指定了 position:sticky 时，它起初会在页面中正常滚动，直到到达了指定的推开距离</p>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><p>可以用column-count属性告诉浏览器需要多少列，也可以设置column-width属性，然后让浏览器自动填充</p>
<h1 id="弹性盒子-1"><a href="#弹性盒子-1" class="headerlink" title="弹性盒子"></a>弹性盒子</h1><h2 id="控制排列方向"><a href="#控制排列方向" class="headerlink" title="控制排列方向"></a>控制排列方向</h2><p>弹性盒子提供了flex-direction指定主轴方向，默认为row，其他值有：column、row-reverse、column-reverse</p>
<h2 id="控制每行flex项的数量和溢出"><a href="#控制每行flex项的数量和溢出" class="headerlink" title="控制每行flex项的数量和溢出"></a>控制每行flex项的数量和溢出</h2><p>默认情况下flex项会自动填充满一行，添加以下规则可以限制每个flex项的宽度：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-wrap</span>:wrap;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">200px</span>;</span><br></pre></td></tr></table></figure>
<p>这样的设置会让每个flex项宽度最少为200px，如果剩余空间不足则会另起一行</p>
<h2 id="flex项的动态尺寸"><a href="#flex项的动态尺寸" class="headerlink" title="flex项的动态尺寸"></a>flex项的动态尺寸</h2>]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>CSS专题</category>
      </categories>
  </entry>
  <entry>
    <title>CSS样式化文本</title>
    <url>/2022/09/18/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/CSS%E4%B8%93%E9%A2%98/CSS%E6%A0%B7%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<ul>
<li>2022-09-22 完成CSS样式化文本的整理</li>
<li>2022-11-01 又大概重新整理和复习了一下<span id="more"></span></li>
</ul>
<p><strong>引导：</strong></p>
<ul>
<li>基本文本和字体样式化<br>  文本和字体样式的所有基础，包括设置字体粗细（font weight）、字体系列及样式（family and style）、字体缩写（font shorthand）、文本排列（text alignment）和其他的效果，还有行（line）以及字符间距（letter spacing）</li>
<li>样式化列表<br>  了解一些专门用于列表的样式</li>
<li>样式化链接<br>  理解有效使用伪类取修饰链接的状态，以及怎么去修复不同的接口功能（例如导航菜单所有用的链接）</li>
<li>网络字体<br>  下载自定义字体，实现更为不同的个性化字体样式</li>
</ul>
<h1 id="基本文本和字体样式化"><a href="#基本文本和字体样式化" class="headerlink" title="基本文本和字体样式化"></a>基本文本和字体样式化</h1><p>用于样式文本的CSS属性通常可以分为两类：字体样式和文本布局风格</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>color属性设置选择元素的前景内容的颜色，通常就是文本，或者是使用 text-decoration 属性放置在文本下方活上方的线，或者是其他东西</p>
<h3 id="字体种类"><a href="#字体种类" class="headerlink" title="字体种类"></a>字体种类</h3><p>font-family属性为浏览器指定一个字体或字体列表。浏览器只会用当前机器上可用的字体应用到当前正在访问的网站上，如果字体不可用则会替代为默认字体</p>
<p>字体栈，形如 font-family: “Trebuchet MS”, Verdana, sans-serif;  从前往后查看是否可用，第一个可用的字体会被应用选中的元素</p>
<h3 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h3><p>CSS定义了5个常用的字体名称：serif、sans-serif、 monospace、cursive、fantasy</p>
<p>即使是这些默认字体，实际的使用效果也取决于浏览器。其中 serif、sans-serif 和 monospace 是比较好预测的，默认情况比较合理</p>
<h3 id="字体的大小"><a href="#字体的大小" class="headerlink" title="字体的大小"></a>字体的大小</h3><p>字体大小通过font-size属性设置，常用单位是：</p>
<ul>
<li>px 像素</li>
<li>em 在这里1em等于当前元素的父元素字体大小</li>
<li>rem 在这里1rem等于根元素的字体大小</li>
</ul>
<p>元素的font-size属性是从该元素的父元素继承的，所有所有都是从整个文档的根元素&lt;\html&gt;开始，浏览器的font-size标准设置的值为16px，其他元素如&lt;h1&gt;也许有一个2em（它的最终值为32px）的默认大小</p>
<h3 id="字体样式、文字粗细、文本大小写转换、文本装饰"><a href="#字体样式、文字粗细、文本大小写转换、文本装饰" class="headerlink" title="字体样式、文字粗细、文本大小写转换、文本装饰"></a>字体样式、文字粗细、文本大小写转换、文本装饰</h3><p>CSS提供4种常用的属性来改变文本的样子：</p>
<ul>
<li>font-style 用来打开和关闭文本的斜体，很少使用</li>
<li>font-weight 设置文字粗细，可选值有 normal、bold、lighter、bolder，也可使用 100-900 的数字来控制，具体效果视所选字体而定</li>
<li>text-transform 设置转换字体<ul>
<li>none：防止任何转型</li>
<li>uppercase：所有文本转为大写</li>
<li>lowercase：所有文本转为小写</li>
<li>cappitalize 转换所有单词首字母为大写</li>
<li>full-width：所有字形转为全角，即固定宽度的正方形，允许拉丁字符和亚洲字形对齐</li>
</ul>
</li>
<li>text-decoration 设置或取消文本装饰，可一次性接收多个值<ul>
<li>none：取消已存在的文本装饰</li>
<li>underline：文本下划线</li>
<li>overline：文本上划线</li>
<li>line-throuh：穿过文本的线（对于删除线，应该用元素指定，而非样式）</li>
</ul>
</li>
</ul>
<h3 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h3><p>为文本应用阴影，使用text-shadow属性，最多可以使用四个值，如 text-shadow: 4px 4px 5px red;<br>这四个值的意义为：</p>
<ol>
<li>第一值指定阴影与原始文本水平偏移，必须指定；</li>
<li>第二值指定垂直偏移</li>
<li>第三值指定模糊半径</li>
<li>第四值指定阴影的基础颜色</li>
</ol>
<p>甚至可以应用多个阴影，秩序将它们用逗号分隔</p>
<h2 id="文本布局"><a href="#文本布局" class="headerlink" title="文本布局"></a>文本布局</h2><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><p>使用text-align属性来控制文本如何和它所在的内容盒子对齐，可用值如下：</p>
<ul>
<li>left：左对齐</li>
<li>right：右对齐</li>
<li>center：文字居中</li>
<li>justify：使文本展开，使所有文本行宽度相同（我认为这并不美观）</li>
</ul>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><p>使用line-height属性设置文本每行之间的高，它接收一般长度单位，也可设置一个无单位数作为乘数，这也是推荐做法，如 line-height: 1.5; </p>
<h3 id="字母和单词间距"><a href="#字母和单词间距" class="headerlink" title="字母和单词间距"></a>字母和单词间距</h3><p>可以使用letter-spacing设置字母间距，word-spacing设置单词间距</p>
<h1 id="样式化列表"><a href="#样式化列表" class="headerlink" title="样式化列表"></a>样式化列表</h1><p>列表大体上和其他文本一样，此外还有一些特殊属性</p>
<h2 id="列表特定样式"><a href="#列表特定样式" class="headerlink" title="列表特定样式"></a>列表特定样式</h2><p>以下三个列表的特定属性可以在&lt;ul&gt;和&lt;ol&gt;元素上设置：</p>
<ul>
<li>list-style-type 设置列表项目符号类型，以下列举几个常用的：<ul>
<li>upper-roman：大罗马数字</li>
<li>circle：空心原点</li>
<li>didc：实心远点</li>
<li>none：不显示项目符号</li>
<li>使用@counter-style 自定义的counter样式</li>
</ul>
</li>
<li>list-style-position 设置项目符号是出现在列表项内还是列表项外，直观的表现在和父级列表项的对齐方式，可以去值 inside 和 outside</li>
<li>list-style-image 允许为项目符号设置自定义图片  <dd>相比使用自定义图片使用的图片标记，缺少“项目标记”的意义；相比设置none后定义背景background系列，缺少控制效果/dd></li>
</ul>
<p>列表样式简便写法： </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 又指定type又设置image，能够在无法加载图像的情况下使用type */</span></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square <span class="built_in">url</span>(<span class="string">example.png</span>) inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在html列表元素种设置项目计数"><a href="#在html列表元素种设置项目计数" class="headerlink" title="在html列表元素种设置项目计数"></a>在html列表元素种设置项目计数</h2><p>在列表元素种可以添加额外属性以设置样式：</p>
<ul>
<li>属性start，它允许从1以外地数字开始计数，如 &lt;ol start&#x3D;”4”&gt; </li>
<li>布尔属性reversed，它启动列表倒计数</li>
<li>属性value，它能够为列表项目指定计数，如 &lt;li value&#x3D;”3”&gt;</li>
</ul>
<h1 id="样式化链接"><a href="#样式化链接" class="headerlink" title="样式化链接"></a>样式化链接</h1><h2 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h2><p>链接存在不同状态，每一种状态都可以用一种<strong>伪类</strong>表示：</p>
<ul>
<li>Link 这是链接地默认状态，属于未被访问状态</li>
<li>Visited 这个链接已被访问（存在于浏览器地历史记录），使用 :visited 伪类来应用样式</li>
<li>Hover 用户地鼠标刚好停留在这个链接上，使用 :hover 伪类来应用样式；链接默认地悬停样式是鼠标光标变成小手</li>
<li>Active 一个链接被激活时，比如被点击时，可以使用 :active 伪类来应用样式</li>
</ul>
<p>链接应该设置以下特征：</p>
<ol>
<li>链接有下划线，这是默认地链接格式</li>
<li>悬停或聚焦于链接上时，链接有相应变化，默认地悬停为鼠标变成小手</li>
<li>color 文字颜色，用户可以自定义，默认设置也足够使用</li>
<li>cursor 鼠标光标样式</li>
<li>outline 文字的轮廓，默认设置于悬停伪类</li>
</ol>
<p>注意链接伪类的选择顺序，比如一个链接被激活的时候，也很可能处于悬停状态，所以在添加样式时，要按照 :link –&gt; :visited –&gt; :hover –&gt; :active 的顺序</p>
<h2 id="设置链接图标"><a href="#设置链接图标" class="headerlink" title="设置链接图标"></a>设置链接图标</h2><p>链接图标与为图片元素创建链接不同，链接图标是作为一个链接的背景设置的，如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为http开头（https也符合条件）的链接创建一个背景图片 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;http&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;https://mdn.mozillademos.org/files/12982/external-link-52.png&#x27;</span>) no-repeat <span class="number">100%</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">16px</span> <span class="number">16px</span>;<span class="comment">/*对于响应式网页有必要调整一下*/</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">19px</span>;<span class="comment">/*为背景图片留出空间，这样不会和文本重叠*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="样式化链接作为按钮"><a href="#样式化链接作为按钮" class="headerlink" title="样式化链接作为按钮"></a>样式化链接作为按钮</h2><p>把链接应用样式，使效果和按钮差不多，这对于设计网站导航菜单十分有用；下面是一个例子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*对于横向导航栏，设置宽度为外部容器body的100%很有必要*/</span></span><br><span class="line"><span class="selector-tag">ul</span> &#123;<span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="comment">/*对于横向导航栏，设置内联展示很有必要*/</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;<span class="attribute">display</span>: inline;&#125; </span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;    </span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;<span class="comment">/*设置它能够确保控制内容不超出外部盒子*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">19.5%</span>;<span class="comment">/*容纳5个盒子，适当留出空隙*/</span></span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.625%</span>;<span class="comment">/*为每个盒子的右侧留出少量空隙*/</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">3</span>;<span class="comment">/*让盒子有一些高度*/</span></span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*删除最右侧按钮的右侧空隙*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> <span class="selector-tag">a</span> &#123;<span class="attribute">margin-right</span>: <span class="number">0</span>;&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background</span>: orange;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">background</span>: red;<span class="attribute">color</span>: white;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Web字体"><a href="#Web字体" class="headerlink" title="Web字体"></a>Web字体</h2><h3 id="在线下载字体"><a href="#在线下载字体" class="headerlink" title="在线下载字体"></a>在线下载字体</h3><p>在CSS的开始处，有一个 @font-face ，可以指定要下载的字体文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;myFont.ttf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后，可以使应用 @font-face 中的字体</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>, <span class="string">&quot;Bitstream Vera Serif&quot;</span>, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，Web字体一般都不能自由使用，不应当在没有授权的情况下使用字体</p>
<h3 id="打包字体使用"><a href="#打包字体使用" class="headerlink" title="打包字体使用"></a>打包字体使用</h3><ol>
<li>下载字体套件到本地放置到CSS同级目录，并重命名为简易的目录，如 fonts 文件夹</li>
<li>打开 stylesheet.css 文件，把包含在网页中的 @font-face 块复制到你的 web-font-start.css 文件，并放在最上面</li>
<li>每个url()函数指向需要导入到CSS的字体文件夹，确保路径正确</li>
<li>现在可以在字体栈中添加这些字体，就像任何web安全或默认的系统字体一样</li>
</ol>
<h3 id="使用在线字体服务"><a href="#使用在线字体服务" class="headerlink" title="使用在线字体服务"></a>使用在线字体服务</h3><p>在线字体服务通常会为你存储和服务字体，这样你就不用担心写@font-face代码了</p>
<p>使用 Google Fonts 在线字体服务：</p>
<ol>
<li>前往 <a href="https://www.google.com/fonts" title=" Google Fonts">Google Fonts</a></li>
<li>选择并添加喜欢的字体</li>
<li>在生成的屏幕中，复制所显示的HTML代码行，置于现有&#x2F;<link/>元素之上</li>
<li>将CSS声明复制到CSS文件中</li>
</ol>
<h3 id="刀枪不入的-font-face语法"><a href="#刀枪不入的-font-face语法" class="headerlink" title="刀枪不入的@font-face语法"></a>刀枪不入的@font-face语法</h3><p>下面是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="comment">/*想要引用的字体名称*/</span></span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;ciclefina&#x27;</span>;</span><br><span class="line">  <span class="comment">/*这些行是指定导入的字体文件路径，以及每种提提文件的格式format（这一部分不是必要，但能让浏览器更快找到）*/</span></span><br><span class="line">  <span class="comment">/*对于eot的两行不太明白意思，但实际使用应该可以忽略它们*/</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.eot&#x27;</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.woff2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">&#x27;fonts/cicle_fina-webfont.svg#ciclefina&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="额外补充-自定义css-at-rule样式"><a href="#额外补充-自定义css-at-rule样式" class="headerlink" title="额外补充-自定义css-at-rule样式"></a>额外补充-自定义css-at-rule样式</h1><h2 id="counter-style"><a href="#counter-style" class="headerlink" title="@counter-style"></a>@counter-style</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style" title="MDN上关于@counter-style的使用介绍">MDN上关于@counter-style的使用介绍</a></p>
<p>下面的 @counter-style 规则使用图片标记，这也许在制作导航栏时十分有用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@counter-style</span> winners-list &#123;</span><br><span class="line">  system: fixed; <span class="comment">/*指定算法*/</span></span><br><span class="line">  symbols: <span class="built_in">url</span>(<span class="string">pic1.svg</span>) <span class="built_in">url</span>(<span class="string">pic2.svg</span>) <span class="built_in">url</span>(<span class="string">pic3.svg</span>);</span><br><span class="line">  suffix: <span class="string">&quot; &quot;</span>; <span class="comment">/*指定一个符号添加在标记后面*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>CSS专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium浏览器控制接口--WebDriver</title>
    <url>/2022/09/13/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/Selenium/Selenium%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A7%E5%88%B6%E6%8E%A5%E5%8F%A3--WebDriver/</url>
    <content><![CDATA[<p>记录 Selenuim+Python 实现web自动化的基本语法，主要是WebDriver部分，如用于并行测试的Grid在此处不会记录</p>
<ul>
<li>2022-09-29 完成了WebDriver常用部分的整理</li>
<li>2023-02-03 重新学习和整理了WebDriver常用部分</li>
</ul>
<span id="more"></span>

<h1 id="WebDriver的准备工作"><a href="#WebDriver的准备工作" class="headerlink" title="WebDriver的准备工作"></a>WebDriver的准备工作</h1><p>WebDriver以原生的方式驱动浏览器，在本地机器上使用就像用户在本地直接使用浏览器有一样。是一个简洁的面向对象的API，能够有效驱动浏览器</p>
<h2 id="安装类库"><a href="#安装类库" class="headerlink" title="安装类库"></a>安装类库</h2><p>安装类库取决于使用的语言，python的类库安装是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><h3 id="手动下载驱动并初始化"><a href="#手动下载驱动并初始化" class="headerlink" title="手动下载驱动并初始化"></a>手动下载驱动并初始化</h3><p>在Selenium上下载浏览器驱动（这各驱动是由浏览器供应商提供的，在selenium官网上可以下载），并放在可使用位置。下面使用所需驱动的位置作为参数，创建一个Service实例，这是当前selenium推荐的做法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service</span><br><span class="line"></span><br><span class="line"><span class="comment">#executable_path表示驱动位置，如果驱动位置存在于在环境变量PATH中，则可省略executable_path参数，从而省略service参数</span></span><br><span class="line">service = Service(executable_path=<span class="string">&quot;browser-drivers\chromedriver.exe&quot;</span>)</span><br><span class="line">driver = webdriver.Chrome(service=service)</span><br></pre></td></tr></table></figure>

<h3 id="用驱动管理软件来初始化驱动"><a href="#用驱动管理软件来初始化驱动" class="headerlink" title="用驱动管理软件来初始化驱动"></a>用驱动管理软件来初始化驱动</h3><p>使用管理软件自动更新并使用驱动，因为浏览器会自动更新，但驱动程序不会</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service <span class="keyword">as</span> ChromeService</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取管理器使用的位置，并传递到服务类中</span></span><br><span class="line">service = Service(executable_path=ChromeDriverManager().install())</span><br><span class="line"><span class="comment">#初始化驱动程序时使用Service实例</span></span><br><span class="line">driver = webdriver.Chrome(service=service)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者简化为一步</span></span><br><span class="line"><span class="comment">#driver = webdriver.Chrome(ChromeDriverManager().install())</span></span><br></pre></td></tr></table></figure>

<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><p>这里的简单演示组合了 1)启动驱动，2)请求网页，3)请求浏览器信息，4)建立等待策略，5)发送命令查找元素，6)操作元素，7)获取元素信息，8)结束会话。一个比较健全的自动化过程应该包含这八个步骤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_eight_components</span>():</span><br><span class="line">    <span class="comment">#启动驱动</span></span><br><span class="line">    service=Service(executable_path=<span class="string">&quot;browser-drivers\chromedriver.exe&quot;</span>)</span><br><span class="line">    driver = webdriver.Chrome(service)</span><br><span class="line">    <span class="comment">#请求网页</span></span><br><span class="line">    driver.get(<span class="string">&quot;https://www.selenium.dev/selenium/web/web-form.html&quot;</span>)</span><br><span class="line">    <span class="comment">#获取浏览器信息</span></span><br><span class="line">    title = driver.title</span><br><span class="line">    <span class="keyword">assert</span> title == <span class="string">&quot;Web form&quot;</span></span><br><span class="line">    <span class="comment">#建立等待策略</span></span><br><span class="line">    driver.implicitly_wait(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#查找元素，这里使用 By需要事先从包 selenium.webdriver.common.by 导入 By</span></span><br><span class="line">    text_box = driver.find_element(by=By.NAME, value=<span class="string">&quot;my-text&quot;</span>)</span><br><span class="line">    submit_button = driver.find_element(by=By.CSS_SELECTOR, value=<span class="string">&quot;button&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#操作元素，这两个元素已再上一步 经获取好了，下面两句分别执行向文本框发送键入内容，点击提交按钮</span></span><br><span class="line">    text_box.send_keys(<span class="string">&quot;Selenium&quot;</span>)</span><br><span class="line">    submit_button.click()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#查找元素后，设置元素属性</span></span><br><span class="line">    message = driver.find_element(by=By.ID, value=<span class="string">&quot;message&quot;</span>)</span><br><span class="line">    value = message.text</span><br><span class="line">    <span class="keyword">assert</span> value == <span class="string">&quot;Received!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭驱动</span></span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>

<h1 id="驱动配置（一般无需配置）"><a href="#驱动配置（一般无需配置）" class="headerlink" title="驱动配置（一般无需配置）"></a>驱动配置（一般无需配置）</h1><h2 id="驱动的capabilities"><a href="#驱动的capabilities" class="headerlink" title="驱动的capabilities"></a>驱动的capabilities</h2><p>最新的驱动capabilities介绍参考<a href="https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/options/">!官方文档文档</a></p>
<p>以下介绍的驱动选项适用于所有浏览器：</p>
<ul>
<li><p>browserName，用来设置既定会话的浏览器，如是火狐还是谷歌；通常用这个来获取浏览器名</p>
</li>
<li><p>browserVersion，设置云端的浏览器，如是火狐还是谷歌</p>
</li>
<li><p>pageLoadStrategy</p>
<p>  可以设置 normal（默认，等待所有资源）、eager（DOM访问就绪即可）、none（完全不阻塞WebDriver）三种页面加载策略</p>
</li>
<li><p>platformName，设置云端的操作系统版本，也可以获取它会返回操作系统名称</p>
</li>
<li><p>acceptInsecureCerts：如果设置为true，则浏览器将信任无效证书</p>
</li>
<li><p>timeouts：会话生存时间，可以是各类限制时间的组合</p>
</li>
<li><p>proxy：设置代理，代理的设置有助于捕获网络流量和模拟后端响应</p>
</li>
</ul>
<h2 id="在Options实例中设置一般capabilities"><a href="#在Options实例中设置一般capabilities" class="headerlink" title="在Options实例中设置一般capabilities"></a>在Options实例中设置一般capabilities</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line"><span class="comment">#上述的capabilities在此处设置</span></span><br><span class="line">options.page_load_strategy = <span class="string">&#x27;eager&#x27;</span></span><br><span class="line"><span class="comment">#options.xxx = &#x27;eager&#x27;</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br></pre></td></tr></table></figure>

<h2 id="驱动的代理配置"><a href="#驱动的代理配置" class="headerlink" title="驱动的代理配置"></a>驱动的代理配置</h2><p>代理也属于驱动的capabilities，但代码实现似乎格式不同。本机尝试使用charles进行代理，但charles会自动启用本地代理，在配置里设置代理反而会失败，故以下代码的正确性无法保证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">PROXY = <span class="string">&quot;127.0.0.1:8899&quot;</span></span><br><span class="line">webdriver.DesiredCapabilities.CHROME[<span class="string">&#x27;proxy&#x27;</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;httpProxy&quot;</span>: PROXY,</span><br><span class="line">    <span class="string">&quot;ftpProxy&quot;</span>: PROXY,</span><br><span class="line">    <span class="string">&quot;sslProxy&quot;</span>: PROXY,</span><br><span class="line">    <span class="string">&quot;proxyType&quot;</span>: <span class="string">&quot;MANUAL&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.selenium.dev/selenium/web/web-form.html&quot;</span>)</span><br></pre></td></tr></table></figure>


<h1 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h1><h2 id="关于两个wait包"><a href="#关于两个wait包" class="headerlink" title="关于两个wait包"></a>关于两个wait包</h2><p>目前发现文档中有两个不同来源的wait包，从文档的示例来看，来自selenium.webdriver.support.wait 的WebDriverWait用于克服浏览器和WebDriver的竞争问题，用于浏览器加载DOM不完全前的等待；selenium.webdriver.ui.wait 的WebDriverWait 用于按序点击，如先等弹窗弹出完全，再点击确定，似乎是用来更贴合人类视觉感觉</p>
<h2 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h2><p>为了克服浏览器和WebDriver脚本之间的竞争问题，需要使用等待功能。显式等待允许代码暂停程序执行，或冻结线程，直到满足条件（这个条件判断会以一定频率调用，直到超时）</p>
<p>可以使用等待来让 findElement 调用等待直到脚本中动态添加的元素被添加到DOM中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">driver.navigate(<span class="string">&quot;file:///race_condition.html&quot;</span>)</span><br><span class="line"><span class="comment">#等待实用程序默认情况下会忽略 no such element 的错误</span></span><br><span class="line"><span class="comment">#这个lambda表达式里的参数d由前面的driver传递</span></span><br><span class="line"><span class="comment">#似乎会返回until内查找查询器的返回值</span></span><br><span class="line">el = WebDriverWait(driver, timeout=<span class="number">3</span>).until(<span class="keyword">lambda</span> d: d.find_element(By.TAG_NAME,<span class="string">&quot;p&quot;</span>)) </span><br><span class="line"><span class="keyword">assert</span> el.text == <span class="string">&quot;Hello from JavaScript!&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个until()函数内参数最终值是个逻辑值，里面经常是函数或lambda表达式。等待的结束条件使用until内逻辑值来决定。对于until内部的这个函数或匿名函数，始终会自动把前面的driver作为参数传递。对于触发了逻辑值为真的元素，似乎会最终被返回</p>
<p>timeout有默认缺省值，可以显示指定。如果等待时间超过timeout指定的时间，会报错”no such element”</p>
<h2 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h2><p>隐式等待是告诉WebDriver，如果在查找一个或多个不是立即可用的元素时轮询DOM一段时间。<strong>这是设置在一个WebDriver上的</strong>，在它有效期间会一直生效。隐式等待和显示等待不能混用，否则可能会发生未知错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = Firefox()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)<span class="comment">#隐式等待10s，如果设置为0表示禁用。这个对该WebDriver的所有查找元素时生效</span></span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line">my_dynamic_element = driver.find_element(By.ID, <span class="string">&quot;myDynamicElement&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="流畅等待"><a href="#流畅等待" class="headerlink" title="流畅等待"></a>流畅等待</h2><p>流畅等待实例定义了等待条件的最大时间量以及检查条件的频率，且可以配置忽略等待时特定类型异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># poll_frequency 定义查询频率，ignored_exceptions定义了忽略异常类型的列表</span></span><br><span class="line">wait = WebDriverWait(driver, timeout=<span class="number">10</span>, poll_frequency=<span class="number">1</span>, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException])</span><br></pre></td></tr></table></figure>


<h1 id="元素查询定位与交互"><a href="#元素查询定位与交互" class="headerlink" title="元素查询定位与交互"></a>元素查询定位与交互</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://the-internet.herokuapp.com/upload&quot;</span>);</span><br><span class="line">driver.find_element(By.ID,<span class="string">&quot;file-upload&quot;</span>).send_keys(<span class="string">&quot;\imgs\xxx.jpg&quot;</span>) <span class="comment">#实现点击【上传图片】，然后选择好图片点击【确定】，这个过程</span></span><br><span class="line"><span class="comment">#依不同的文件上传设计而定，有的在上一步点击【确定】时就进行上传，有的上一步仅选择好文件，需要在这一步上传</span></span><br><span class="line">driver.find_element(By.ID,<span class="string">&quot;file-submit&quot;</span>).submit()</span><br><span class="line"><span class="keyword">if</span>(driver.page_source.find(<span class="string">&quot;File Uploaded!&quot;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file upload success&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file upload not successful&quot;</span>)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查询器"><a href="#查询器" class="headerlink" title="查询器"></a>查询器</h2><p>定位元素时，匹配第一个元素用 find_element ，匹配所有元素（获取一个列表）用 find_elements ，两者在函数名上有末尾否多一个s的区别</p>
<p>选择定位元素方式的参数有：</p>
<ul>
<li>By.ID             根据标签名</li>
<li>By.CLASS_NAME     根据了类名</li>
<li>By.TAG_NAME       根据标签类型</li>
<li>By.CSS_SELECTOR   根据CSS，可以指定ID、类名等，如CSS选择器一样</li>
<li>By.LINK_TEXT      在可链接文本中查找，查询器所需第二参数为链接文本的文本内容</li>
<li>其他</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CSS选择，匹配第一个。像在CSS文件中指定要适用的范围一样指定第二个参数</span></span><br><span class="line">fruit = driver.find_element(By.CSS_SELECTOR,<span class="string">&quot;#fruits .tomatoes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用标签类型选择，匹配所有</span></span><br><span class="line">elements = driver.find_elements(By.TAG_NAME, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前焦点标签</span></span><br><span class="line">element = driver.switch_to.active_element</span><br></pre></td></tr></table></figure>

<h2 id="与元素交互"><a href="#与元素交互" class="headerlink" title="与元素交互"></a>与元素交互</h2><p>有五种基本命令可用于元素操作：</p>
<ul>
<li>点击，这是用于任何元素</li>
<li>发送键位，仅适用于可编辑文本字段和内容可编辑元素，选择图片上传也需要用到发送键位的命令来发送待上传图片的路径</li>
<li>清除，仅适用于可编辑文本字段和内容可编辑元素</li>
<li>提交，这是不推荐的，应该在提交按钮上使用点击命令</li>
<li>选择，仅适用于列表元素，参见选择列表元素</li>
</ul>
<p><strong>元素点击命令</strong>执行在<strong>元素中央</strong>，如果元素中央被遮挡，selenium将返回一个“元素点击中断（element click intercepted）”的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设el已经查询到一个可点击元素</span></span><br><span class="line">el.click()</span><br></pre></td></tr></table></figure>

<p><strong>元素发送键位命令</strong>将录入提供的键位到可编辑的元素，如果不可编辑返回“无效元素状态（invalid element state）”错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设已经获取到一个网页</span></span><br><span class="line">driver.find_element(By.NAME, <span class="string">&quot;q&quot;</span>).send_keys(<span class="string">&quot;webdriver&quot;</span> + Keys.ENTER)</span><br></pre></td></tr></table></figure>

<p><strong>元素清除命令</strong>会重置元素的内容，这要求元素可编辑且可重置，这意味着元素是文本可编辑或者内容可编辑的，如果执行元素清楚命令失败会返回“无效元素状态（invalid element state）”错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(By.NAME, <span class="string">&quot;q&quot;</span>).clear()</span><br></pre></td></tr></table></figure>


<p><strong>选择命令</strong>详见选择列表元素一节</p>
<h2 id="内置元素定位器"><a href="#内置元素定位器" class="headerlink" title="内置元素定位器"></a>内置元素定位器</h2><p>在WebDriver中有8种不同的内置元素定位策略：</p>
<ul>
<li>class name    ，使用查询器或定位器，对应参数为 By.CLASS_NAME</li>
<li>css selector  ，使用查询器或定位器，对应参数为 By.CSS_SELECTOR</li>
<li>id            ，使用查询器或定位器，对应参数为 By.ID</li>
<li>name          </li>
<li>link text </li>
<li>partial link text </li>
<li>tag name</li>
<li>xpath</li>
</ul>
<p>（这些信息官方文档还在维护中，暂时省略）</p>
<h2 id="相对元素定位器"><a href="#相对元素定位器" class="headerlink" title="相对元素定位器"></a>相对元素定位器</h2><p>相对定位器（Relative Locators）可以比较容易地描述一个元素的空间上的有关元素。Selenium使用 JavaScript相关函数来检查元素们在页面上的位置和大小，因此可以用这个信息来定位相邻元素。对于一些不容易直接描述或查询的元素来说，这是一种很方便的方法</p>
<p>模拟一个布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Email Address</span><br><span class="line">+——————————————————————————————————+</span><br><span class="line">|                                  |</span><br><span class="line">+——————————————————————————————————+</span><br><span class="line"></span><br><span class="line">Password</span><br><span class="line">+——————————————————————————————————+</span><br><span class="line">|                                  |</span><br><span class="line">+——————————————————————————————————+</span><br><span class="line"></span><br><span class="line">  +————————+           +————————+</span><br><span class="line">  | Cancel |           | Submit |</span><br><span class="line">  +————————+           +————————+</span><br></pre></td></tr></table></figure>


<p><strong>Above</strong>位置，以下代码描述了“一个在密码元素上方的输入框”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">email_locator = locate_with(By.TAG_NAME, <span class="string">&quot;input&quot;</span>).above(&#123;By.ID: <span class="string">&quot;password&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Below</strong>位置，以下代码描述了“一个在邮件元素下面的输入框”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password_locator = locate_with(By.TAG_NAME,<span class="string">&quot;input&quot;</span>).below(&#123;By.ID: <span class="string">&quot;email&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Left of</strong>位置，<em>方位</em>部分为 to_left_of</p>
<p><strong>Right of</strong>位置，<em>方位</em>部分为 to_right_of</p>
<p><strong>Near</strong>位置，<em>方位</em>部分为 near。对于容易因为窗口大小而改变元素布局的模式来说，用near这个“模糊”一些的定位方法反而更加准确。near的作用范围是距离被提供元素最大50px</p>
<p>这些相对元素定位器可以链式使用，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">locate_with(By.TAG_NAME, <span class="string">&quot;button&quot;</span>).below(&#123;By.ID: <span class="string">&quot;email&quot;</span>&#125;).to_right_of(&#123;By.ID: <span class="string">&quot;cancel&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>简单分析相对于元素定位器的使用语法，可以猜测，locate_with首先像查询器一样找到满足宽松条件的元素，只不过locate_witch返回的是可迭代使用的对象（似乎使用元素查询器作为原点，也没有问题？）；然后再进一步用定位条件筛选</p>
<h2 id="元素信息的判断和获取"><a href="#元素信息的判断和获取" class="headerlink" title="元素信息的判断和获取"></a>元素信息的判断和获取</h2><p>检查元素是否显示（目前selenium只能基于js来做近似判断）  <em>found_element</em>.is_display() </p>
<p>检查元素是否启用  <em>found_element</em>.is_enabled() </p>
<p>元素是否被选定  <em>found_element</em>.is_selected()</p>
<p>获取元素标签名，有属性tag_name： <em>found_element</em>.tag_name </p>
<p>获取元素矩形位置，包括元素高、款、左上角x和y位置，有属性rect： <em>found_element</em>.rect</p>
<p>获取元素文本，有属性text： <em>found_element</em>.text</p>
<p>获取元素CSS值   <em>found_element</em>.value_of_css_property(‘<em>some_property</em>‘)</p>
<p>获取特性或属性  <em>found_element</em>.get_attribute(‘<em>some_attribute</em>‘)</p>
<h2 id="选择列表元素（仅适用select元素）"><a href="#选择列表元素（仅适用select元素）" class="headerlink" title="选择列表元素（仅适用select元素）"></a>选择列表元素（仅适用select元素）</h2><p>selenium的support包有一个Select类，可以帮助列表选择，但这个“选择列表”的功能仅适用于 &lt;select&gt; 元素，不适合那些通过 div 或 li 并使用JavaScript遮罩层设计的下拉列表，目前用处并不广泛</p>
<p>通过 find_element 查询到 &lt;select&gt; 元素，可以使用 Select() 来生成一个Select对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select_element = driver.find_element(By.ID,<span class="string">&#x27;selectElementID&#x27;</span>)</span><br><span class="line">select_object = Select(select_element)</span><br></pre></td></tr></table></figure>

<p>选择其中选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于内部索引选择</span></span><br><span class="line">select_object.select_by_index(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#基于value属性选择</span></span><br><span class="line">select_object.select_by_value(<span class="string">&#x27;value1&#x27;</span>)</span><br><span class="line"><span class="comment">#基于文档文本内容选择</span></span><br><span class="line">select_object.select_by_visible_text(<span class="string">&#x27;Bread&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>检视选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回一个所有已选择选项的列表</span></span><br><span class="line">all_selected_options = select_object.all_selected_options</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过遍历DOM选择第一个</span></span><br><span class="line">first_selected_option = select_object.first_selected_option</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回select元素包含的选项的列表</span></span><br><span class="line">all_available_options = select_object.options</span><br></pre></td></tr></table></figure>

<p>取消选择状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于内部索引删除</span></span><br><span class="line">select_object.deselect_by_index(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基于value属性删除</span></span><br><span class="line">select_object.deselect_by_value(<span class="string">&#x27;value1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基于文本文档内容删除</span></span><br><span class="line">select_object.deselect_by_visible_text(<span class="string">&#x27;Bread&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有项的选择状态</span></span><br><span class="line">select_object.deselect_all()</span><br></pre></td></tr></table></figure>

<p>确认&lt;select&gt;元素是否允许多选，可以观察属性select_object.is_multiple</p>
<h1 id="浏览器交互"><a href="#浏览器交互" class="headerlink" title="浏览器交互"></a>浏览器交互</h1><p>本节代码基于 driver 已成功初始化</p>
<h2 id="浏览器导航"><a href="#浏览器导航" class="headerlink" title="浏览器导航"></a>浏览器导航</h2><p>浏览器导航操作：</p>
<ul>
<li>打开网站   driver.get(<em>url</em>)</li>
<li>前进      drver.forward()</li>
<li>后退      driver.back()</li>
<li>刷新      driver.refresh()</li>
</ul>
<h2 id="消息弹窗"><a href="#消息弹窗" class="headerlink" title="消息弹窗"></a>消息弹窗</h2><p>以下的代码实例可能需要导入这些包:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.alert <span class="keyword">import</span> Alert</span><br></pre></td></tr></table></figure>

<p>Javascript有三种元素消息弹窗，Alerts警告框、Confirm确认框、Prompt提示框。<strong>在弹窗处执行的操作</strong>可以有 1)点击确认，2)点击取消，3)输入文本 三个动作，此外可用text获取弹窗内容。各功能有无取决于消息弹窗类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设已经获得alert已经获得弹窗实例</span></span><br><span class="line"></span><br><span class="line">alert.accept()<span class="comment">#对应点击确定</span></span><br><span class="line">alert.dismiss()<span class="comment">#对应点击取消</span></span><br><span class="line">alert.send_keys(<span class="string">&quot;ceshi ceshi&quot;</span>)<span class="comment">#对应键入信息</span></span><br><span class="line">alert.text<span class="comment">#获取弹窗文本</span></span><br></pre></td></tr></table></figure>

<p><strong>获取消息弹窗引用</strong>的方法有 1)“显示等待”的最终返回是触发元素 2)使用switch_to切换到弹窗元素 <s> 3)不常用的，使用Alert(driver)获取 </s></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设已经初始一个driver驱动，并在此处触发了一个弹窗</span></span><br><span class="line"></span><br><span class="line">alert1 = WebDriverWait(driver,timeout=<span class="number">10</span>).until(expected_conditions.alert_is_present())<span class="comment">#获取方法1，“显示等待”的最终返回触发元素</span></span><br><span class="line">alert2 = driver.switch_to.alert<span class="comment">#获取方法2，使用switch_to切换到弹窗，使用完成后要切换回</span></span><br><span class="line">driver.switch_to.default_content()</span><br></pre></td></tr></table></figure>

<h2 id="和Cookies交互"><a href="#和Cookies交互" class="headerlink" title="和Cookies交互"></a>和Cookies交互</h2><p>Cookie是从网站发送并存储在计算机中的一小段数据，主要用于识别用户并加载存储的信息。WebDriver提供了内置的方法与Cookie进行交互</p>
<p>添加Cookie，添加方法中只接受一个可序列化的JSON对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;http://www.example.com&quot;</span>)</span><br><span class="line"><span class="comment"># 在当前浏览器环境添加一条cookie信息</span></span><br><span class="line">driver.add_cookie(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;bar&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>获取Cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一条指定名称的cookie的数据</span></span><br><span class="line">driver.get_cookie(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="comment"># 获取全部可获取cookies</span></span><br><span class="line">driver.get_cookies()</span><br></pre></td></tr></table></figure>

<p>删除Cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除指定名称的一条cookie</span></span><br><span class="line">driver.delete_cookie(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="comment"># 删除当前访问上下文的所有cookie</span></span><br><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure>

<p>设置cookie的sameSite属性，控制是否会和来自第三方网站的请求一起发送，引入这个是为了防止CSRF（跨站请求伪造）攻击。值为 “Strict” 则不允许一起发送，值为 “Lax” 则允许cookie和第三方网站发起的get请求一起发送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加cookie时，设置这条cookie的sameSite属性为&quot;Strict&quot;</span></span><br><span class="line">driver.add_cookie(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;value&quot;</span>, <span class="string">&#x27;sameSite&#x27;</span>: <span class="string">&#x27;Strict&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 添加cookie时，设置这条cookie的sameSite属性为&quot;Lax&quot;</span></span><br><span class="line">driver.add_cookie(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;foo1&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;value&quot;</span>, <span class="string">&#x27;sameSite&#x27;</span>: <span class="string">&#x27;Lax&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="获取网页信息"><a href="#获取网页信息" class="headerlink" title="获取网页信息"></a>获取网页信息</h2><p>获取网页信息：</p>
<ul>
<li>获取当前页面的标题  driver.title</li>
<li>从浏览器地址栏获取URL  driver.current_url</li>
</ul>
<h2 id="内嵌框架"><a href="#内嵌框架" class="headerlink" title="内嵌框架"></a>内嵌框架</h2><p> frame 是一种已经舍弃的方法（不支持HTML5），iframe仍然普遍使用，本节讲述内嵌框架iframe的自动化方法</p>
<p>对于一个含有内嵌文档iframe的文档，无法通过 driver.find_element(By.TAG_NAME, ‘button’) 找到在iframe里面的按钮元素，因为Selenium只知道顶层文档中的元素，为了与按钮交互，首先要切换到框架</p>
<p>切换框架首先要选择到框架，框架的“框子”仍然属于原来的文档，这个选择的过程和普通的元素选择没有区别，之后在使用switch_to_frame 方法切换到框架；此外还有直接通过框架名切换的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一：查询iframe元素，以元素引用为参数执行 driver.switch_to.frame()</span></span><br><span class="line"><span class="comment"># 选择id为modal的元素的直接子元素中的iframe元素；也可以通过iframe的id找到它；</span></span><br><span class="line">selected_iframe = driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;#modal &gt; iframe&quot;</span>)</span><br><span class="line"><span class="comment"># 也可以通过选择的iframe索引找到它</span></span><br><span class="line">selected_iframe = driver.find_elements(By.TAG_NAME,<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>] </span><br><span class="line"><span class="comment"># 以元素引用为参数，切换到选择的iframe</span></span><br><span class="line">driver.switch_to.frame(selected_iframe)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：以框架名为参数，切换到这个iframe</span></span><br><span class="line">driver.switch_to.frame(<span class="string">&quot;myiframe&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>离开框架，返回到默认框架： driver.switch_to.default_content()</p>
<h2 id="窗口和标签"><a href="#窗口和标签" class="headerlink" title="窗口和标签"></a>窗口和标签</h2><p>WebDriver <strong>没有区分窗口和标签页</strong>。Selenium允许使用窗口句柄来处理标签页或窗口，它们都有一个唯一的标识符，获取当前窗口句柄使用 driver.current_windows_handle。所有窗口的句柄保存在 driver.window_handles 这个列表中，可以使用对它遍历，或者取长度</p>
<h3 id="窗口的建、删与切换"><a href="#窗口的建、删与切换" class="headerlink" title="窗口的建、删与切换"></a>窗口的建、删与切换</h3><p>新建一个标签页，然后切换到它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动驱动程序</span></span><br><span class="line"><span class="keyword">with</span> webdriver.Firefox() <span class="keyword">as</span> driver:</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&quot;https://seleniumhq.github.io&quot;</span>)</span><br><span class="line"><span class="comment"># 设置等待</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 存储原始窗口的句柄</span></span><br><span class="line">original_window = driver.current_window_handle</span><br><span class="line"><span class="comment"># 检查一下，还没有打开其他的窗口</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(driver.window_handles) == <span class="number">1</span></span><br><span class="line"><span class="comment"># 点击连接，然后打开一个新窗口</span></span><br><span class="line">driver.find_element(By.LINK_TEXT, <span class="string">&quot;new window&quot;</span>).click()</span><br><span class="line"><span class="comment"># 等待新窗口或标签页</span></span><br><span class="line">wait.until(expected_conditions.number_of_windows_to_be(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 循环执行，直到找到一个新的窗口句柄</span></span><br><span class="line"><span class="keyword">for</span> window_handle <span class="keyword">in</span> driver.window_handles:</span><br><span class="line">    <span class="keyword">if</span> window_handle != original_window:</span><br><span class="line">        driver.switch_to.window(window_handle)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 等待新标签页完成加载内容</span></span><br><span class="line">wait.until(expected_conditions.title_is(<span class="string">&quot;SeleniumHQ Browser Automation&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>关闭窗口，且回到之前的标签页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭当前窗口</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment"># original_window 已经事先获取了原先窗口的句柄</span></span><br><span class="line">driver.switch_to.windows(original_windowl)</span><br></pre></td></tr></table></figure>
<p>注意，关闭后必须及时切回，否则可能触发 “No Such Windows Exception” (无此窗口异常)</p>
<p>在会话结束后退出浏览器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<p>退出行为将导致：</p>
<ul>
<li>关闭所有WebDriver会话相关的窗口</li>
<li>结束浏览器进程</li>
<li>结束驱动进程</li>
<li>如果正在使用Grid，通知Grid浏览器不再可用，以便另一个会话使用它</li>
</ul>
<p>调用quit()失败将留下额外的后台进程和端口运行在机器上，在使用WebDriver期间应该保持异常处理</p>
<p>对于python，可以使用上下文管理器（with关键字）来维护这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> webdriver.Firefox() <span class="keyword">as</span> driver:</span><br><span class="line">    <span class="comment"># WebDriver 代码 </span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#此缩进位置后WebDriver会自动退出</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="某一窗口的管理"><a href="#某一窗口的管理" class="headerlink" title="某一窗口的管理"></a>某一窗口的管理</h3><p>分辨率会影响web应用的呈现方式，因此WebDriver提供了移动和调整浏览器大小的机制</p>
<p>获取窗口大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width = driver.get_window_size().get(<span class="string">&quot;width&quot;</span>)</span><br><span class="line">height = driver.get_window_size().get(<span class="string">&quot;height&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者存储尺寸并在以后查询它们</span></span><br><span class="line">size = driver.get_window_size()</span><br><span class="line">width1 = size.get(<span class="string">&quot;width&quot;</span>)</span><br><span class="line">height1 = size.get(<span class="string">&quot;height&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>设置窗口大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.set_windows_size(<span class="number">1024</span>,<span class="number">768</span>)</span><br></pre></td></tr></table></figure>

<p>得到窗口的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">position = driver.get_window_position()</span><br><span class="line">x1 = position.get(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y1 = position.get(<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>移动窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将窗口移动到主显示器的左上角</span></span><br><span class="line">driver.set_window_position(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>最大化窗口(等效于浏览器的“最大化”键)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.maximize_window()</span><br></pre></td></tr></table></figure>

<p>最小化窗口，这个命令会精准作用于一个窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.minimize_window()</span><br></pre></td></tr></table></figure>

<p>全屏窗口（等效于浏览器中按f11）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.fullscreen_window()</span><br></pre></td></tr></table></figure>
<h3 id="窗口内截屏"><a href="#窗口内截屏" class="headerlink" title="窗口内截屏"></a>窗口内截屏</h3><p><strong>屏幕截图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以捕获当前“浏览上下文”的屏幕截图，返回Base64格式编码的图片</span></span><br><span class="line">driver.save_screenshot(<span class="string">&#x27;./image.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>元素屏幕截图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#捕获当前浏览器上下文中，查询到的元素的屏幕截图，返回Base64格式编码的图片</span></span><br><span class="line">ele_h1 = driver.find_element(By.CSS_SELECTOR, <span class="string">&#x27;h1&#x27;</span>)</span><br><span class="line">ele_h1.screenshot(<span class="string">&#x27;./image.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="窗口内执行JavaScript"><a href="#窗口内执行JavaScript" class="headerlink" title="窗口内执行JavaScript"></a>窗口内执行JavaScript</h3><p>在当前窗口的上下文中，执行JavaScript代码片段。注意以下示例中，形参始终是 arguments 这样的形式，始终把传入的元素引用视为一个数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储h1标签元素</span></span><br><span class="line">header = driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;h1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行JavaScript代码：返回h1标签元素的内部文本</span></span><br><span class="line">driver.execute_script(<span class="string">&#x27;return arguments[0].innerText&#x27;</span>, header)</span><br></pre></td></tr></table></figure>
<h3 id="打印页面"><a href="#打印页面" class="headerlink" title="打印页面"></a>打印页面</h3><p>打印当前浏览的页面。这个功能需要无头模式下的Chromium浏览器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.print_page_options <span class="keyword">import</span> PrintOptions</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">print_options = PrintOptions()</span><br><span class="line">print_options.page_ranges = [<span class="string">&#x27;1-2&#x27;</span>]</span><br><span class="line">driver.get(<span class="string">&quot;printPage.html&quot;</span>)</span><br><span class="line">base64code = driver.print_page(print_options)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟身份验证器Virtual-Authenticator"><a href="#虚拟身份验证器Virtual-Authenticator" class="headerlink" title="虚拟身份验证器Virtual Authenticator"></a>虚拟身份验证器Virtual Authenticator</h2><p>根据文档说明，这个验证器是基于公钥的身份验证机制，允许存储密钥并在需要时检索。目前似乎没有这个需要</p>
<h1 id="Actions接口"><a href="#Actions接口" class="headerlink" title="Actions接口"></a>Actions接口</h1><p>用于向Web浏览器提供虚拟化设备输入操作的低级接口</p>
<h2 id="键盘行为"><a href="#键盘行为" class="headerlink" title="键盘行为"></a>键盘行为</h2><p>键盘行为只有两种：按下一个键和松开一个键。在Actions链上重复这两种行为以及send_keys()能够快速产生一个组合按键流</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ActionChains(driver)\</span><br><span class="line">    .key_down(Keys.SHIFT)\</span><br><span class="line">    .send_keys(<span class="string">&quot;a&quot;</span>)\</span><br><span class="line">    .key_up(Keys.SHIFT)\</span><br><span class="line">    .send_keys(<span class="string">&quot;b&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p>指定一个元素使用send keys：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_input = driver.find_element(By.ID, <span class="string">&quot;textInput&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .send_keys_to_element(text_input, <span class="string">&quot;abc&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p>复制和粘贴：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Keys.COMMAND是苹果系统使用的，其他平台使用 Keys.CONTROL</span></span><br><span class="line">cmd_ctrl = Keys.COMMAND <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span> <span class="keyword">else</span> Keys.CONTROL</span><br><span class="line"></span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .send_keys(<span class="string">&quot;Selenium!&quot;</span>)\</span><br><span class="line">    .send_keys(Keys.ARROW_LEFT)\</span><br><span class="line">    .key_down(Keys.SHIFT)\</span><br><span class="line">    .send_keys(Keys.ARROW_UP)\</span><br><span class="line">    .key_up(Keys.SHIFT)\</span><br><span class="line">    .key_down(cmd_ctrl)\</span><br><span class="line">    .send_keys(<span class="string">&quot;xvv&quot;</span>)\</span><br><span class="line">    .key_up(cmd_ctrl)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<h2 id="鼠标行为"><a href="#鼠标行为" class="headerlink" title="鼠标行为"></a>鼠标行为</h2><p>鼠标行为只有三种：按下鼠标一个按键、松开鼠标一个按键和移动鼠标。其中按下和松开鼠标通常组合成一个敲击行为，而移动鼠标的命令目前看来用处不大，目前忽略之</p>
<p><strong>Click and hold</strong>，这个方法结合了移动鼠标到元素中心，然后按下鼠标左键 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clickable = driver.find_element(By.ID, <span class="string">&quot;clickable&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .click_and_hold(clickable)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p><strong>Click and release</strong>，这个方法结合了移动鼠标到元素中心，然后按下、松开鼠标左键（左键敲击）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clickable = driver.find_element(By.ID, <span class="string">&quot;click&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .click(clickable)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p>对于一个鼠标总共有物种定义的按键：</p>
<ul>
<li>0 – 左键（默认）</li>
<li>1 – 中键（现在不支持）</li>
<li>2 – 右键</li>
<li>3 – X1退回键</li>
<li>4 – X2前进键</li>
</ul>
<p><strong>Context Click</strong>，这个方法结合了移动鼠标到元素中心，然后按下、松开右键（右键敲击）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clickable = driver.find_element(By.ID, <span class="string">&quot;clickable&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .context_click(clickable)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p><strong>Double click</strong>，这个方法结合了移动鼠标到元素中心，然后左键敲击两次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clickable = driver.find_element(By.ID, <span class="string">&quot;clickable&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .double_click(clickable)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>

<p>此外还有“按下、松开退回键”，“按下、送开前进键”等方法，这里不记录</p>
<h1 id="支持的一些功能"><a href="#支持的一些功能" class="headerlink" title="支持的一些功能"></a>支持的一些功能</h1><h2 id="同颜色一起工作–Color类"><a href="#同颜色一起工作–Color类" class="headerlink" title="同颜色一起工作–Color类"></a>同颜色一起工作–Color类</h2><p>需要导入该类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.color <span class="keyword">import</span> Color</span><br></pre></td></tr></table></figure>

<p>使用参数创建颜色对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生产颜色参数。指定1)十六进制颜色、2)rgb、3)rgb、4)基本颜色，四种方式生成颜色参数，此外hsl、hsla等也支持</span></span><br><span class="line">HEX_COLOUR = Color.from_string(<span class="string">&#x27;#2F7ED8&#x27;</span>)</span><br><span class="line">RGBA_COLOUR = Color.from_string(<span class="string">&#x27;rgba(255, 255, 255, 0.5)&#x27;</span>)</span><br><span class="line">RGBA_COLOUR = Color.from_string(<span class="string">&#x27;rgba(40%, 20%, 40%, 0.5)&#x27;</span>)</span><br><span class="line">BLACK_COLOR = Color.from_string(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">TRANSPARENT = Color.from_string(<span class="string">&#x27;transparent&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>查询并获取元素颜色，返回一个颜色对象： <em>found_element</em>.value_of_css_property(‘color’)</p>
<p>查询并获取元素背景色，返回一个颜色对象： <em>found_element</em>.value_of_css_property(‘background-color’)</p>
<p>颜色对象之间，颜色对象与颜色字符串之间可以比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#颜色对象与颜色对象比较</span></span><br><span class="line"><span class="keyword">assert</span> color_obj1 == color_obj2</span><br><span class="line"><span class="comment">#颜色和颜色字符串比较</span></span><br><span class="line"><span class="keyword">assert</span> color_obj1.<span class="built_in">hex</span> == <span class="string">&#x27;#ff68b4&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> color_obj1.<span class="built_in">hex</span> == <span class="string">&#x27;rgba(255,105,180,3)&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>测试工具</category>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS构建基础</title>
    <url>/2022/09/08/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/CSS%E4%B8%93%E9%A2%98/CSS%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li>2022-09-19 完成CSS构建基础的整理</li>
<li>2022-11-01 重新审阅，调整文档</li>
<li>2023-02-07 把CSS选择器单独拎出来</li>
</ul>
<span id="more"></span>
<h1 id="在html中引入css"><a href="#在html中引入css" class="headerlink" title="在html中引入css"></a>在html中引入css</h1><p>在html 文档开头链接css文件（外部样式表）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在html文档中直接添加css（内部样式表）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/*css内容*/</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置html元素的style属性（内联样式），一般不要这么做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="层叠与继承"><a href="#层叠与继承" class="headerlink" title="层叠与继承"></a>层叠与继承</h1><h2 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h2><p>元素样式的继承比较符合直觉，比如，字体很容易被子元素自然继承，但是周围设置的边框就不会被自然继承，每个CSS属性都能接收继承值，形如 color:inherit;</p>
<p>CSS为控制继承提供了五个特殊的属性值，:</p>
<ul>
<li>inherit 强制继承父元素的css值</li>
<li>revert 应用于选定元素的属性重置为浏览器默认样式</li>
<li>unset 重置该元素的样式——如果本来自然继承了父元素的值，则设置重置为父元素值，如果没有继承的值，则重置为元素默认样式</li>
<li><del>initial 设置为该元素默认样式</del>(不建议使用，在继承的属性上，这可能是意外的)</li>
<li><del>revert-layer 应用于选定元素的属性重置为上一个层叠层中建立的值</del>(不建议使用)</li>
</ul>
<p>CSS有一种简写属性all，可以（几乎）设置所有属性的继承值；这种方法十分适合撤销样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fix-this</span>&#123;</span><br><span class="line">  <span class="attribute">all</span>:unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="理解层叠"><a href="#理解层叠" class="headerlink" title="理解层叠"></a>理解层叠</h2><h3 id="样式应用的顺序"><a href="#样式应用的顺序" class="headerlink" title="样式应用的顺序"></a>样式应用的顺序</h3><p>样式应用因素的重要程度： 含!import声明（如border: none !important;） &gt; 内联样式 &gt; <strong>css选择器优先级</strong> &gt; css规则在文件中的顺序 </p>
<p>实际主要考虑css选择器的优先级。一个选择器的优先级可以说是由三个不同的分量相加:</p>
<ul>
<li>ID– 选择器中包含ID选择器，新得100分</li>
<li>类– 选择器包含类选择器、属性选择器或伪类选择器，新得10分</li>
<li>元素– 选择器中包含元素、伪元素选择器，新得1分</li>
<li>其他细节无需关注</li>
</ul>
<p>以下是几个实际的例子:</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>ID</th>
<th>类</th>
<th>元素</th>
</tr>
</thead>
<tbody><tr>
<td>h1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>h1 + p::first-letter</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>li &gt; a[href*&#x3D;”en-US”] &gt; .inline-warning</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>#identifier</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>button:not(#mainBtn, .cta)</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="CSS位置影响"><a href="#CSS位置影响" class="headerlink" title="CSS位置影响"></a>CSS位置影响</h2><p>CSS声明的优先级取决于定义它的样式表和级联层，更清楚的理清样式覆盖，还可以覆盖无法编辑的第三方样式表</p>
<p>级联层中声明css，按声明顺序决定优先级，在任何层之外声明的css会被按照声明顺序组合成未命名层，当作最后声明的一层</p>
<p>级联层这样声明：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@layer</span> firstLayer, secondLayer;</span><br><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@layer</span> firstLayer &#123;</span><br><span class="line">  <span class="selector-id">#addSpecificity</span> &#123; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@layer</span> secondLayer &#123;</span><br><span class="line">  <span class="selector-tag">p</span><span class="selector-id">#addSpecificity</span> &#123; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>相互冲突的覆盖声明的顺序如下，越往后优先级越高:</p>
<ol>
<li>浏览器（用户代理）样式表中的声明，如浏览器默认样式</li>
<li>用户样式表中的常规声明</li>
<li>开发人员设置的样式表的常规声明</li>
<li>开发人员设置的样式表的 !important 声明</li>
<li>用户样式表中的 !important 声明</li>
<li>浏览器（用户代理）样式表中的 !important 声明</li>
</ol>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>在css种广泛使用 <strong>块级盒子(block box)</strong> 和 <strong>内联盒子(inline box)</strong> ，这两种盒子会在 <strong>页面流(page flow)</strong> 和元素之间表现不同行为</p>
<p>定义为块级(block)盒子会表现以下行为：</p>
<ul>
<li>每个盒子换行</li>
<li>width 和 height 属性可发挥作用</li>
<li>在内联方向上扩展，占据父容器在该方向的所有空间，这意味着绝大数情况下，盒子与父容器一样宽</li>
<li>内边距padding、外边距margin、边框border会将其他元素推开</li>
</ul>
<p>如果一个盒子对外显示为inline（内联盒子），那么它的行为如下：</p>
<ul>
<li>盒子不会产生换行</li>
<li>width 和 height 属性不会发挥作用</li>
<li>垂直方向的边距边框会被应用，但是不会推开其他inline盒子</li>
<li>水平方向的边距边框会被应用，且会把其他inline盒子推开</li>
</ul>
<p>&lt;a&gt;、&lt;span&gt;、&lt;em&gt;、&lt;strong&gt; 都默认处于 inline 状态</p>
<p>如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。该盒子的所有直接子元素都会成为 flex 元素，会根据弹性盒子（Flexbox）规则进行布局</p>
<h2 id="盒模型各部分"><a href="#盒模型各部分" class="headerlink" title="盒模型各部分"></a>盒模型各部分</h2><p>CSS中组成一个块级盒子需要：内容盒子、内边距盒子、边框盒子、外边距盒子；边框也可以拥有宽度，所有也应该是是盒子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+----------------------------------+</span><br><span class="line">|                           margin |</span><br><span class="line">|                                  |</span><br><span class="line">|  =============================   |</span><br><span class="line">|  ||               padding   ||   |</span><br><span class="line">|  ||   +-------------+       ||&lt;--|--border</span><br><span class="line">|  ||   |    content  |       ||   |</span><br><span class="line">|  ||   |             |       ||   |</span><br><span class="line">|  ||   +-------------+       ||   |</span><br><span class="line">|  ||                         ||   |</span><br><span class="line">|  =============================   | </span><br><span class="line">+----------------------------------+  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内容盒子、内边距盒子、外边距盒子可以设置属于它区域的上下左右的“距离”，边框盒子可以设置厚度和边框样式等</p>
<p>以上讲述的都是标准盒模型，此外，还有一个替代(IE)盒模型，这个模型中所有宽度都是可见宽度，此处不详细介绍</p>
<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>可以使用 padding 属性一次性设置，指定一个值会设置四个方向，指定两个值会设置垂直方向和水平方向</p>
<p>padding-top、padding-right、padding-bottom、padding-left 单独设置四个方向的<strong>内边距宽度</strong></p>
<p>它们设置的值可以是 长度（1px，1em）、百分比(5%，相当于包含快的宽度)、auto(让浏览器选择，一般使元素居中)</p>
<h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>可以使用 margin 属性一次性设置，指定一个值会设置四个方向，指定两个值会设置垂直方向和水平方向</p>
<p>margin-top、margin-right、margin-bottom、margin-left 单独设置四个方向的<strong>外边距宽度</strong></p>
<p>外边距允许负值，此外，外边距还有<strong>折叠</strong>的特性，两个水平或垂直相邻的盒子，取它们最大的外边距作为公共外边距，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+----------------------------------+</span><br><span class="line">|                          margin1 |</span><br><span class="line">|                                  |</span><br><span class="line">|  ==========================      |</span><br><span class="line">|  ||              padding ||      |</span><br><span class="line">|  ||   +-------------+    ||&lt;-----|--border</span><br><span class="line">|  ||   |    content  |    ||      |</span><br><span class="line">|  ||   |             |    ||      |</span><br><span class="line">|  ||   +-------------+    ||      |</span><br><span class="line">|  ||                      ||      |</span><br><span class="line">|  ==========================      | </span><br><span class="line">|                ^                 |</span><br><span class="line">|  max(margin1-buttom,margin2-top) |</span><br><span class="line">|                v                 |</span><br><span class="line">|  =============================   |</span><br><span class="line">|  ||               padding   ||   |</span><br><span class="line">|  ||   +-------------+       ||&lt;--|--border</span><br><span class="line">|  ||   |    content  |       ||   |</span><br><span class="line">|  ||   |             |       ||   |</span><br><span class="line">|  ||   +-------------+       ||   |</span><br><span class="line">|  ||                         ||   |</span><br><span class="line">|  =============================   | </span><br><span class="line">|                        margin2   |</span><br><span class="line">+----------------------------------+ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>可以使用 border 属性一次性设置四个边框的宽度、颜色和样式，也可以分别设置。</p>
<p>可以使用这些属性设置边框的颜色、样式或宽度:</p>
<ul>
<li>border-width, border-top-width, …</li>
<li>border-style, border-top-style, …</li>
<li>border-color, border-top-color, …</li>
</ul>
<p>如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;div class=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;div class=&quot;box&quot;&gt;Change my borders.&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">5px</span> dotted green;             </span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">20px</span> double <span class="built_in">rgb</span>(<span class="number">23</span>,<span class="number">45</span>,<span class="number">145</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  <span class="attribute">border-top-style</span>: dotted;</span><br><span class="line">  <span class="attribute">border-right-width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: hotpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-display-inline-block"><a href="#使用-display-inline-block" class="headerlink" title="使用 display: inline-block"></a>使用 display: inline-block</h2><p>这个值在内联和块之间提供了一个中间状态，这个不会切换到新行<br>，但是可以谁当宽度和高度，避免垂直方向上文档内容重叠</p>
<p>如果一个元素使用 display:inline-block ，那么设置 width 和 height 属性会生效，padding、margin、border 会推开其他元素；普通的内联盒子，垂直方向上不会推开其他元素</p>
<p>对于链接元素，如 &lt;a&gt; ，如果想要有更大命中区域，设置这个属性十分有用</p>
<h1 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color 属性定义了CSS中任何元素的背景颜色</p>
<p>CSS数据类型color表示一种标准RGB色彩空间，一个颜色可以包括一个alpha通道的透明值。一个数据类型为color的值可以是如下形式：</p>
<ul>
<li>颜色关键字，如blue、red，应只使用VGA显卡所显示的颜色集合</li>
<li>透明度关键字transparent</li>
<li>继承父级的color属性–currentcolor关键字</li>
<li>RGB立体坐标(以”#”加十六进制，如我的vscode背景色是#8ddf0928 ，或者rgb()、rgba()函数表达表示)</li>
<li>HSL圆柱坐标(以hsl()和hsla()函数表达式表示)</li>
</ul>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>使用 background-image: url(xxx.png); 来设置背景图片。背景图片在默认情况下，大图不会缩小以适应容器，小图则会重复平铺填充容器。背景图片位于背景颜色上方。</p>
<p>背景图片是可以指定多个的，如 background-image:  url(big-star.png),url(star.png);  先出现的位于上方，后出现的会在下方</p>
<p>控制背景滚动方式，使用 background-attachment 属性，可以接受以下值：</p>
<ul>
<li>scroll 使背景元素在页面滚动时滚动；但作为元素的背景，滚动元素时不会滚动</li>
<li>fixed 背景固定在视图上</li>
<li>loacl 使背景和元素保持相对固定</li>
</ul>
<p>控制背景平铺，使用 background-repeat 属性，可以取值：</p>
<ul>
<li>no-repeat 不重复</li>
<li>repeat-x  水平重复</li>
<li>repeat-y  垂直重复</li>
<li>repeat    两个方向上重复</li>
</ul>
<p>调整背景图像大小，使用 background-size 属性，可以取值：</p>
<ul>
<li>长度或百分比</li>
<li>关键字cover，使图像完全展示，可能会跳出盒子</li>
<li>关键字contain，一般比较推荐这个，它使图像缩放正好装在盒子内，可能会在一侧留出空隙</li>
</ul>
<p>背景图像定位，使用 background-position 属性设置背景图像在盒子中的位置，框的左上角是（0，0），可以取值：</p>
<ul>
<li>关键字top、center、right的等，如 background-position: top center; </li>
<li>长度值或百分比</li>
<li>关键字搭配长度值，如 background-position: top 20px right 10px; 距顶部20px，距右侧10px</li>
</ul>
<p>也可以分别使用background-position-x ， background-position-y</p>
<h3 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a>渐变背景</h3><p>让渐变用于背景，可以对 background-image 属性设置。这里的取值应该为一个gradient数据类型，它由渐变函数定义</p>
<p><strong>线性渐变</strong>，颜色值沿直线方向逐渐过渡，由 linear-gardient() 产生，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.linear-gradient-class</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, red, orange, yellow, green, blue, indigo, violet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个表示朝右方向，逐渐过渡指出的颜色，这个从左到右的距离由容器决定(当然高度也由容器决定)</p>
<p><strong>径向渐变</strong>，颜色由一个中心点向外扩散过渡到其他颜色，由 radial-gradient() 函数产生，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.radial-gradient-class</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(red, yellow, <span class="built_in">rgb</span>(<span class="number">30</span>,<span class="number">144</span>,<span class="number">255</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重复渐变</strong>，重复多次渐变图案知道填满容器，由 repeating-linear-gradient() 和 repeat-radial-gradient() 函数产生，摘抄的语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 朝45度方向，开始蓝色，在1/3处为蓝色，中间自动填充插值以实现渐变；</span></span><br><span class="line"><span class="comment">重复上面填色区域直至填充满容器（将会重复3次） */</span></span><br><span class="line">repeating-linear-gradient(<span class="number">45deg</span>, blue, red <span class="number">33.3%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 朝左上方向，开始蓝色，在20px处为红色，中间自动填充插值以实现渐变；</span></span><br><span class="line"><span class="comment">重复上面填色区域直至填充满容器*/</span></span><br><span class="line">repeating-linear-gradient(<span class="selector-tag">to</span> <span class="attribute">left</span> <span class="attribute">top</span>, blue, red <span class="number">20px</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 朝0度方向，开始蓝色，在容器40%处为红色，终点为红色；</span></span><br><span class="line"><span class="comment">这个填色区域不会重复，结尾的颜色若不设置位置，默认为终点 */</span></span><br><span class="line">repeating-linear-gradient(<span class="number">0deg</span>, blue, green <span class="number">40%</span>, red);</span><br></pre></td></tr></table></figure>
<h3 id="使用background简写"><a href="#使用background简写" class="headerlink" title="使用background简写"></a>使用background简写</h3><p>自认为不够清晰，不应该使用这种方式</p>
<h2 id="边框-1"><a href="#边框-1" class="headerlink" title="边框"></a>边框</h2><p>使用 border 设置边框的宽度border-width、样式border-style、颜色border-color  </p>
<p>可以使用 border 一次性设置这三个属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">2px</span> dotted blue;</span><br></pre></td></tr></table></figure>

<p>关于边框样式bordr-style，有以下例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无样式 */</span></span><br><span class="line"><span class="attribute">border-style</span>: none;</span><br><span class="line"><span class="comment">/* 边框为点 */</span></span><br><span class="line"><span class="attribute">border-style</span>: dotted;</span><br><span class="line"><span class="comment">/* 边框有陷入效果 */</span></span><br><span class="line"><span class="attribute">border-style</span>: inset;</span><br><span class="line"><span class="comment">/* 上下方形虚线，左右厚实线 */</span></span><br><span class="line"><span class="attribute">border-style</span>: dashed solid;</span><br></pre></td></tr></table></figure>

<p>设置圆角，可以通过 border-radius 属性，和方框的每个角相关的长边来实现方框的圆角，示例如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 盒子的四个角都有10px的圆角半径 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 右上角的水平半径为1em，垂直半径为10% */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">1em</span> <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="处理不同方向文本"><a href="#处理不同方向文本" class="headerlink" title="处理不同方向文本"></a>处理不同方向文本</h1><p>writing-mode 属性能够指定文本的排列方向：</p>
<ul>
<li>horizontal-tb ，tb意思为top-&gt;bottom，块流从上到下，文字方向是水平的的</li>
<li>vertical-rl ，rl的意思为right-&gt;left，块流从右向左，文字方向是垂直的</li>
<li>vertical-lr ，lr的意思是left-&gt;right，块流从左向右，文字方向是垂直的</li>
</ul>
<h2 id="逻辑属性和物理属性"><a href="#逻辑属性和物理属性" class="headerlink" title="逻辑属性和物理属性"></a>逻辑属性和物理属性</h2><p>物理属性不会随着盒子的“块流”方向改变而改变，即使盒子的物理方向变了，物理属性（如 border-top）也不会改变它的位置</p>
<p>标准方向使用的物理属性，有对应的逻辑属性，它们之间的映射为：</p>
<ul>
<li>top     &lt;–&gt;  block-start  ，如边框有border-top到border-block-start</li>
<li>right   &lt;–&gt;  inline-end</li>
<li>bottom  &lt;–&gt;  block-end</li>
<li>left    &lt;–&gt;  inline-start</li>
</ul>
<p>物理属性在使用弹性布局和网格布局时非常有用，一般还是用物理属性</p>
<h1 id="调整容器尺寸"><a href="#调整容器尺寸" class="headerlink" title="调整容器尺寸"></a>调整容器尺寸</h1><h2 id="原始尺寸（固有尺寸）"><a href="#原始尺寸（固有尺寸）" class="headerlink" title="原始尺寸（固有尺寸）"></a>原始尺寸（固有尺寸）</h2><p>HTML元素有原始的尺寸。对于图像元素，它的长和宽由文件自身确定；对于一个空的div元素，它是没有尺寸的，高度为0</p>
<h2 id="具体尺寸"><a href="#具体尺寸" class="headerlink" title="具体尺寸"></a>具体尺寸</h2><p>给元素指定具体尺寸时，实际指定的是外部尺寸，如我们指定width和height，此后不论放里面是什么内容，容器都会不改变它的尺寸（这也许会导致内容溢出）</p>
<p>在使用百分数指定尺寸时，百分数是以包含盒子的块为根据解析的，如果一个盒子指定一个百分数作为宽度，那么它的百分比依据是父容器的宽度</p>
<p>在使用百分数指定内外边距时，百分数是以包含快的内联尺寸进行计算的，它的百分比依据是元素的水平宽度</p>
<h2 id="最小和最大尺寸"><a href="#最小和最大尺寸" class="headerlink" title="最小和最大尺寸"></a>最小和最大尺寸</h2><p>对于容量可以变化的盒子，可以设置最大、最小尺寸。这个在避免溢出的同时处理变化容量很有用，在制作适应屏幕大小的响应式网页布局也十分有用</p>
<p>可以使用如 max-width:100%; 限定得图像可以变小，但不会变大（默认是按照图像原文件大小，设定后在较小容器中的图片会自动缩小以展示全貌）；如 min-height：20px; 限定的文档内容的盒子即使是空内容也会占据空间</p>
<p>这个技术不会改变下载的原始图片，对于大尺寸原始图片，应该在img标签内就指定下载的图像大小</p>
<h2 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h2><p>视口是浏览器中的“可见屏幕”，可以使用视口单位，制作随用户视口改变而改变的效果。1vw为视口宽度的百分之一，1vh为视口高度的百分之一</p>
<p>对于嵌入在iframe中内容，它的视口大小是外部观察的iframe元素的尺寸</p>
<h1 id="元素内容溢出"><a href="#元素内容溢出" class="headerlink" title="元素内容溢出"></a>元素内容溢出</h1><h2 id="溢出的内容"><a href="#溢出的内容" class="headerlink" title="溢出的内容"></a>溢出的内容</h2><p>我们可以使用给width和height(或者inline-size和block-size)赋值的方式来约束盒子的尺寸，CSS假定你知道在做什么并控制好了文本内容。这时当往盒子里塞太多东西就会溢出，超出盒子的范围</p>
<p>此外，由于盒子里的文本内容并非盒子，它们不会推开其他内容，所以这些文本会占居其他盒子的空间</p>
<p>之所以允许这种“溢出”的方式，是因为CSS要尽力避免数据损失，数据的丢失（如表格中提交按钮被隐藏）可比不整洁的外观问题严重多了</p>
<h2 id="overflow-属性"><a href="#overflow-属性" class="headerlink" title="overflow 属性"></a>overflow 属性</h2><p>overflow属性控制溢出内容的显示方式，它的默认取值为 visible ；如果想要隐藏内容可以设置 overflow: hidden; 但这通常不建议这么做</p>
<p> overflow: scroll; 能让盒子附加一个滚动条（内容没有溢出时也会显示）。 overflow-y: scroll; 能更准确地仅附加垂直方向的滚动条（或者使用 overflow: visible scroll;）</p>
<p> overflow: auto; 能让盒子仅在内容溢出的情况下附加滚动条</p>
<p>在使用诸如scroll或者auto的时候，会建立了一个块级排版上下文</p>
<h1 id="图像、媒体、表单元素"><a href="#图像、媒体、表单元素" class="headerlink" title="图像、媒体、表单元素"></a>图像、媒体、表单元素</h1><h2 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h2><p>图像和视频被描述为 <strong>替换元素</strong>。替换元素是一种外部对象，样式表仅可以影响的它们的外部（位置、外边距、或宽高等）</p>
<p>处理图片溢出的常用方法是设置 max-width&#x3D;100%; ，可以让图片适应小容器，但缩小后图片在容器中的位置可能令人不满意</p>
<p>object-fit属性可以让图片，以多种方式被调整：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图片维持比例填满盒子，多余部分被盒子裁掉*/</span></span><br><span class="line"><span class="selector-class">.cover</span>&#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图片维持比例，居中并尽量最大，包含在盒子内，盒子中可能存在留空*/</span></span><br><span class="line"><span class="selector-class">.cover</span>&#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><p>许多更加复杂的输入类型是由操作系统渲染的，无法进行样式化。一些元素很容易样式化，如&lt;input type&#x3D;’email’&gt;元素以及&lt;textarea&gt;元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;email&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表单样式由于在不同浏览器上表现不同的原因，很可能在设置前“重置”一下样式，但由于浏览器更加统一的原因，已经不重要了</p>
<h1 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h1><p>（暂时不记录）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>CSS专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Web入门</title>
    <url>/2022/09/08/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/HTML%E4%B8%93%E9%A2%98/Web%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>初学了解，简要复习时可参考</p>
<span id="more"></span>


<h1 id="Web入门"><a href="#Web入门" class="headerlink" title="Web入门"></a>Web入门</h1><h2 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h2><p>index.html 示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My test page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/firefox-icon.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;My test image&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li><!DOCTYPE> 指明文档类型；当今仅用于保证文档正常读取</li>
<li>根元素<html></html>，包含住整个也没内容</li>
<li>头部元素<head><head/>，对用户不可见，包含一些元数据(meta)</li>
<li>head内<meta charset="utf-8">，指明编码</li>
<li>head内<title></title>，设置页面标题，也作为浏览器标签显示</li>
<li>主体元素<body></body></li>
</ul>
<h3 id="图像–-元素"><a href="#图像–-元素" class="headerlink" title="图像– 元素"></a>图像– <img>元素</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/firefox-icon.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;My test image&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性 src 可以指定地址嵌入图像；属性 alt 是文件的描述内容，在图像不可见时显示</p>
<h3 id="标记文本–-标题、段落、列表"><a href="#标记文本–-标题、段落、列表" class="headerlink" title="标记文本– 标题、段落、列表"></a>标记文本– 标题、段落、列表</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>主标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>顶层标题<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>子标题<span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>次子标题<span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标题对于无障碍访问和搜索引擎优化非常有意义</p>
<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>无序列表(Unorderd List)、有序列表(Ordered List)内使用列表项目元素(List Item)元素包围:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>科学家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>哲学家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>建筑家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接赋予 Web 网络属性，使用元素 &lt;a&gt; (anchor的缩写)来植入链接</p>
<p>将链接植入到文本需要以下步骤:</p>
<ol>
<li>选择文本</li>
<li>把文本包围在 &lt;a&gt;&lt;/a&gt; 元素内，给予文本“锚”的特征</li>
<li>给&lt;a&gt;添加一个 herf (代表hypertext reference)属性，把值设置为所需网址</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综合以上，应该实现了以下代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My test page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/firefox-icon.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;My test image&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>以下是一个列表<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>科学家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>哲学家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>建筑家<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>阅读<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/zh-CN/about/manifesto/&quot;</span>&gt;</span>Mozilla 宣言<span class="tag">&lt;/<span class="name">a</span>&gt;</span>，了解更多<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，整个结构称为“规则集”，各个部分释义如下:</p>
<ul>
<li>选择器(Selector)<br>  </br> 选择了需要添加样式的元素(如本例中的 p 元素)，给不同元素添加样式只需要更改选择器</li>
<li>声明(Declaration)–一个单独的规则，如 color: red; </br> 声明与声明之间用“分号”隔开 </li>
<li>属性(Properties)，如 color，是改变 HTML 元素样式的途径</li>
<li>属性的值(Property Value)，它从指定属性的众多外观中指定一个值</li>
</ul>
<h3 id="字体和文本"><a href="#字体和文本" class="headerlink" title="字体和文本"></a>字体和文本</h3><p>备注:中文字体文件不适合直接用于 Web Font </p>
<ol>
<li>为当前网页下载字体，从而使自定义CSS可以对HTML元素应用这个字体，在头部添加如下代码:</br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://fonts.font.im/css?family=Open+Sans&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>删除 style.css 中已有规则</li>
<li>在 style.css ，替代 font family 占位行，并给其他元素也设置样式代码如下:</br> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*备注: 注释不可以嵌套，并且不接受单行//注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给整个页面设置字体格式*/</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="comment">/* px 表示“像素（pixels）”: 基础字号为 10 像素 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="comment">/* Google fonts 输出的 CSS */</span></span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Open Sans&#x27;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给部分元素设置字体格式*/</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>, <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="comment">/* line-height 后面可以跟不同的参数，如果是数字，就是当前字体大小乘上数字 */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>CSS布局主要就是基于盒子模型的，页面里大部分HTML元素都可以被看作是若干层堆叠的盒子</p>
<h4 id="文档体格式设置"><a href="#文档体格式设置" class="headerlink" title="文档体格式设置"></a>文档体格式设置</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#FF9500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下解释css设置:</p>
<ul>
<li>width:600px; – 强制页面保持600像素</li>
<li>margin:0 auto; – 为margin(或padding等属性)设置两个值时，第一个值设置元素上方和下方，第二个值设置左边和右边；这里auto表示水平方向上左右对称</li>
<li>padding:0 20px 20px 20px; – 给出四个值，设置内边距上下左右的像素距离</li>
<li>border:5px solid black; – 直接为body设置5像素的黑色实线边框</li>
<li>background-color: #FF9500; – 为body设置背景色</li>
</ul>
<h4 id="定位页面主题并添加样式"><a href="#定位页面主题并添加样式" class="headerlink" title="定位页面主题并添加样式"></a>定位页面主题并添加样式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#00539F</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text-shadow: 3px 3px 1px black; 中，分别表示阴影的右移像素数、下移像素数、模糊半径、基色</p>
<h4 id="图像居中"><a href="#图像居中" class="headerlink" title="图像居中"></a>图像居中</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;body&gt; 元素是块级元素，意味着它占据页面的空间，并且能够赋予间距值；而图片是内联的，必须使用 display:block 给予块级行为，才能使图像有外边距</p>
<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>let 和 var 关键字声明变量。注意， let 关键词只可以声明一次同名变量； var 关键字遇到第二次声明时，会执行赋值行为</p>
<p>变量有以下几种数据类型:</p>
<ul>
<li>String – 值需要用单引号或双引号括起来，let v&#x3D;’李雷’;</li>
<li>Number – let v&#x3D;10;</li>
<li>Boolean – true&#x2F;false</li>
<li>Array – let v&#x3D;[1, ‘李雷’, 30]; 引用方法为 v[0], v[1], …</li>
<li>Object – JavaScript一切皆对象，包括上面几个类型</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>JavaScript 允许单行注释和多行注释:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的所有内容</span></span><br><span class="line"><span class="comment">都是注释。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> v=<span class="string">&#x27;李雷&#x27;</span>;</span><br><span class="line"><span class="comment">// 这是一条注释</span></span><br></pre></td></tr></table></figure>
<p>注意，CSS与JS一样使用相同的多行注释，但CSS没有单行注释</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>+</li>
<li>-,*,/</li>
<li>=  </li>
<li>===  测试两个值是否相等，返回布尔值</li>
<li>!=&#x3D;   测时两个值是否不相等，返回布尔值</li>
<li>!    逻辑非</li>
</ul>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fav = <span class="string">&#x27;chocolate&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (fav === <span class="string">&#x27;chocolate&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;我最喜欢巧克力&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;我的最爱不是巧克力&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = num1 * num2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">multiply</span>(<span class="number">4</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件能为网页添加交互能力；最简单的事件是点击事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名函数的行为绑定(赋值)到 html 的 onclick 属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;html&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;别戳我，我怕疼。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等价于下面的代码，但前者更简洁</span></span><br><span class="line"><span class="comment">let myHTML = document.querySelector(&#x27;html&#x27;);</span></span><br><span class="line"><span class="comment">myHTML.onclick = function() &#123; alert(&#x27;别戳我，我怕疼。&#x27;);&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">箭头函数写法，与上面等价</span></span><br><span class="line"><span class="comment">document.querySelector(&#x27;html&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">  alert(&#x27;别戳我，我怕疼。&#x27;);</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>HTML专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML构建Web</title>
    <url>/2022/09/08/%E5%AD%A6%E4%B9%A0/web%E5%89%8D%E7%AB%AF/HTML%E4%B8%93%E9%A2%98/HTML%E6%9E%84%E5%BB%BAWeb/</url>
    <content><![CDATA[<ul>
<li>2022-09-15 完成HTML构建Web的整理</li>
</ul>
<span id="more"></span>


<h1 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h1><h2 id="剖析HTML元素"><a href="#剖析HTML元素" class="headerlink" title="剖析HTML元素"></a>剖析HTML元素</h2><h3 id="块级元素和内联元素"><a href="#块级元素和内联元素" class="headerlink" title="块级元素和内联元素"></a>块级元素和内联元素</h3><p>块级元素在页面中以“块”的形式展现：同等级的块会出现在新的一行，通常展示结构化内容，如段落、列表、导航菜单、页脚等。一个以 block 形式展现的块级元素无法嵌套进内联元素，但可以嵌套在块级元素中</p>
<p>内联元素通常出现在块级元素中，作为块级元素一部分：内联元素不会导致文本换行，通常出现在一堆文字中间，如超链接元素&lt;a&gt;或强调元素&lt;em&gt;和&lt;strong&gt;</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性与元素名称和别的属性之间，存在一个空格；属性名称使用等于号赋值，属性值用一对引号包围(布尔属性没有值)</p>
<h4 id="实践–锚元素添加属性"><a href="#实践–锚元素添加属性" class="headerlink" title="实践–锚元素添加属性"></a>实践–锚元素添加属性</h4><p>元素&lt;a&gt;是锚，是被标签包围的内容成为一个超链接，它可以添加以下属性:</p>
<ul>
<li>href， 声明超链接的web地址，如 href&#x3D;”<a href="https://www.ice-cocoa.net&quot;/">https://www.ice-cocoa.net&quot;</a></li>
<li>title， 为链接地址提供额外信息，鼠标悬停时，以工具提示的形式显示；如 title&#x3D;”我的首页”</li>
<li>target， 用于指定链接如何呈现，例如 target&#x3D;”_blank” 将在打开新标签后打开链接</li>
</ul>
<h4 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h4><p>布尔属性没有值，这是合法的，他们有跟属性名一样的属性值。例如 disabled 等价于 disabled&#x3D;”disabled” </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 disabled 属性来防止终端用户输入文本到输入框中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="引号问题"><a href="#引号问题" class="headerlink" title="引号问题"></a>引号问题</h3><p>建议所有的属性都由双引号包括（也使用单引号，但更习惯于双引号），除了布尔属性的省略写法下，没有属性值，无法用引号包围</p>
<h3 id="转义引用"><a href="#转义引用" class="headerlink" title="转义引用"></a>转义引用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>HTML 中用 <span class="symbol">&amp;lt;</span>p<span class="symbol">&amp;gt;</span> 来定义段落元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML 中用 &lt;p&gt; 来定义段落元素</span><br></pre></td></tr></table></figure>
<p><a href="http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references">XML和HTML字符实体引用列表</a></p>
<h2 id="head-标签–-HTML元数据"><a href="#head-标签–-HTML元数据" class="headerlink" title="head 标签– HTML元数据"></a>head 标签– HTML元数据</h2><p>许多 &lt;mata&gt; 元素包含了 name 和 content属性：</p>
<ul>
<li>name 指定了 &lt;mate&gt; 元素的类型</li>
<li>content 指定了实际的元数据内容 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ice-cocoa&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The MDN Web Docs site</span></span></span><br><span class="line"><span class="string"><span class="tag">  provides information about Open Web technologies</span></span></span><br><span class="line"><span class="string"><span class="tag">  including HTML, CSS, and APIs for both Web sites and</span></span></span><br><span class="line"><span class="string"><span class="tag">  progressive web apps.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
指定 author ，能让一些内容管理系统自动获取作者信息；<br>指定 description 的关键字十分有用，能够让搜索引擎的相关搜索出现更多</li>
</ul>
<p>许多 &lt;meta&gt; 特性已不再使用，如 meta-keywords ，这个将被搜索引擎忽略</p>
<h3 id="为站点添加自定义图标–-添加link引用"><a href="#为站点添加自定义图标–-添加link引用" class="headerlink" title="为站点添加自定义图标– 添加link引用"></a>为站点添加自定义图标– 添加link引用</h3><p>添加图标的操作顺序为:</p>
<ol>
<li>保存在与网站的索引页面相同的目录中，以 .ico 格式保存 （大多数支持通用的png和jpg，而ico能兼容像ie6那样的古老浏览器）</li>
<li>使用添加 &lt;link&gt; 引用</br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在有很多其他的图标类型可以考虑:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 适用于第三代iPad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;144x144&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://developer.mozilla.org/static/img/favicon144.png&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 适用于第一第二代iPad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;72x72&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://developer.mozilla.org/static/img/favicon72.png&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基本图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://developer.mozilla.org/static/img/favicon32.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在HTML应用CSS和JavaScript–-添加link和script引用"><a href="#在HTML应用CSS和JavaScript–-添加link和script引用" class="headerlink" title="在HTML应用CSS和JavaScript– 添加link和script引用"></a>在HTML应用CSS和JavaScript– 添加link和script引用</h3><p>添加css引用的 &lt;link&gt; 元素，应该位于文档头部； rel&#x3D;”stylesheet” 表明这是文档的样式表，href&#x3D;”my-css-file.css” 表明了路径:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;my-css-file.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加JavaScript引用的 &lt;script&gt; 元素，没有位置限制； src&#x3D;”my-js-file.js” 指明了文件路径， defer 表明解析完HTML后再加载JavaScript；注意，&lt;script&gt;并不是一个空元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;my-js-file.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h1 id="HTML文本基础"><a href="#HTML文本基础" class="headerlink" title="HTML文本基础"></a>HTML文本基础</h1><h2 id="为文档设置诸语言"><a href="#为文档设置诸语言" class="headerlink" title="为文档设置诸语言"></a>为文档设置诸语言</h2><p>为文档设置主语言，能够帮助搜索引擎更好搜索，辅助阅读工具工作更准确:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为文档段设置语言:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Japanese example: <span class="tag">&lt;<span class="name">span</span> <span class="attr">lang</span>=<span class="string">&quot;ja&quot;</span>&gt;</span>ご飯が熱い。<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTML结构层次内容"><a href="#HTML结构层次内容" class="headerlink" title="HTML结构层次内容"></a>HTML结构层次内容</h2><p>HTML文本是结构层次的，文本内容从属于所在的标题，一般情况下应该只使用一次 h1  </p>
<h3 id="文本内容元素"><a href="#文本内容元素" class="headerlink" title="文本内容元素"></a>文本内容元素</h3><p>HTML文本内容元素可以有:</p>
<ul>
<li>h1, h2, …</li>
<li>p </li>
<li>span 是短语内容的通用<strong>行内容器</strong>，是行内元素，用来设置包围内容的统一格式</li>
<li>div 是一个通用型的<strong>流内容容器</strong>，是块元素</li>
<li>ul, ol  列表，内部项目为 li</li>
</ul>
<h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><p>文本修饰元素有:</p>
<ul>
<li>粗体强调 &lt;strong&gt;</li>
<li>粗体 &lt;b&gt;</li>
<li>斜体强调 &lt;em&gt;</li>
<li>斜体 &lt;i&gt;</li>
<li>下划线 &lt;u&gt; 尽量不使用，因为它容易与超链接混淆；</li>
<li>删除线 &lt;del&gt; 删除线</li>
</ul>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="超链接的创建"><a href="#超链接的创建" class="headerlink" title="超链接的创建"></a>超链接的创建</h2><p>通过将文本（或图片，甚至是块元素）包裹在 &lt;a&gt; 元素内，并给一个 href，可以创建一个超链接 :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文本内容超链接<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/zh-CN/&quot;</span>&gt;</span>Mozilla 主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span>的超链接。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>创建一个图像内容超链接<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/zh-CN/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mozilla-image.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;链接至 Mozilla 主页的 Mozilla 标志&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="统一资源定位符URL与路径path"><a href="#统一资源定位符URL与路径path" class="headerlink" title="统一资源定位符URL与路径path"></a>统一资源定位符URL与路径path</h2><p>统一资源定位符(URL:Uniform Resource Locator)，定义了在网络上位置的某个资源的文本字符串  </p>
<h3 id="定位到文件"><a href="#定位到文件" class="headerlink" title="定位到文件"></a>定位到文件</h3><p>网页文件(.html)指向本身所处的文件夹，它可以指向其他文件夹，引用那里的文件:</p>
<ul>
<li>指向当前目录</li>
<li>指向子目录</li>
<li>指向上级目录：返回上级目录使用两个英文点号表示(..)，如：  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击打开<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../pdfs/project-brief.pdf&quot;</span>&gt;</span>项目简介<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位到文档片段"><a href="#定位到文档片段" class="headerlink" title="定位到文档片段"></a>定位到文档片段</h3><p>超链接可以链接到HTML文档的特定部分，这个特定文档片段必须要分配一个id，才能由超链接找到</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定位到某个网页的某个id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>要提供意见和建议，请将信件邮寄至<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;contactshtml#Mailing_address&quot;</span>&gt;</span>我们的地址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定位到当前网页的某个id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本页面底部可以找到<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#Mailing_address&quot;</span>&gt;</span>公司邮寄地址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="绝对URL和相对URL"><a href="#绝对URL和相对URL" class="headerlink" title="绝对URL和相对URL"></a>绝对URL和相对URL</h3><p>绝对URL指明了<strong>协议和域名</strong>，以及“那个”服务器下的路径<br>相对URL仅仅指明了本地路径</p>
<h3 id="下载链接使用download属性"><a href="#下载链接使用download属性" class="headerlink" title="下载链接使用download属性"></a>下载链接使用download属性</h3><p>使用download属性提供一个默认的保存名:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span></span><br><span class="line">  下载最新的 Firefox 中文版 - Windows（64位）</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="电子邮件链接"><a href="#电子邮件链接" class="headerlink" title="电子邮件链接"></a>电子邮件链接</h2><p>使用 &lt;a&gt; 元素 和 mailto:URL 方案:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:wangbonsgo@163.com&quot;</span>&gt;</span>向wyc发邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，还可以添加邮件的额外参数，如，主题subject、抄送cc、暗抄送bcc、主体body；如</p>
<h1 id="高阶文字排版"><a href="#高阶文字排版" class="headerlink" title="高阶文字排版"></a>高阶文字排版</h1><h2 id="描述列表"><a href="#描述列表" class="headerlink" title="描述列表"></a>描述列表</h2><p>描述列表使用:</p>
<ul>
<li>&lt;dl&gt; – description list 描述列表</li>
<li>&lt;dt&gt; – description term 描述语</li>
<li>&lt;dd&gt; – description definition 描述定义，会自动产生四个空格的缩进</li>
</ul>
<p>如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>内心独白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>语言独白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>旁白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文本引用"><a href="#文本引用" class="headerlink" title="文本引用"></a>文本引用</h2><h3 id="块引用–-lt-blockquote-gt"><a href="#块引用–-lt-blockquote-gt" class="headerlink" title="块引用– &lt;blockquote&gt;"></a>块引用– &lt;blockquote&gt;</h3><p>如果一个块级内容（一个段落、多个段落、一个列表等）从其他地方被引用，你应该把它用&lt;blockquote&gt;元素包裹起来表示<br>例如，下面的例子引用MDN的页面:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">strong</span>&gt;</span>HTML <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="symbol">&amp;lt;</span>blockquote<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span> Element<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> (or <span class="tag">&lt;<span class="name">em</span>&gt;</span>HTML Block</span><br><span class="line">  Quotation Element<span class="tag">&lt;/<span class="name">em</span>&gt;</span>) indicates that the enclosed text is an extended quotation.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器会默认增加一个四个空格的缩进</p>
<h3 id="行内引用–-lt-q-gt"><a href="#行内引用–-lt-q-gt" class="headerlink" title="行内引用– &lt;q&gt;"></a>行内引用– &lt;q&gt;</h3><p>行内引用使用 &lt;q&gt; 元素，例如下面的标记包含了从MDN页面的引用:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The quote element — <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="symbol">&amp;lt;</span>q<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span> — is <span class="tag">&lt;<span class="name">q</span> <span class="attr">cite</span>=<span class="string">&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;</span>&gt;</span>intended</span><br><span class="line">for short quotations that don&#x27;t require paragraph breaks.<span class="tag">&lt;/<span class="name">q</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="引文元素–-lt-cite-gt"><a href="#引文元素–-lt-cite-gt" class="headerlink" title="引文元素– &lt;cite&gt;"></a>引文元素– &lt;cite&gt;</h3><p>相比 cite 属性， &lt;cite&gt;元素可以显示并且添加链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>According to the </span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">cite</span>&gt;</span>MDN blockquote page<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h2><p>缩略语元素 &lt;abbr&gt; (Abbreviation)有一个 title 属性，它包围要缩略显示的文档，当鼠标放到这个项目上时会出现提示(内容为title值)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我们使用 <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;超文本标记语言（Hyper text Markup Language）&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> 来组织网页文档。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="标记联系方式"><a href="#标记联系方式" class="headerlink" title="标记联系方式"></a>标记联系方式</h2><p>包含文档编写作者或者网站作者的联系方式，使用元素&lt;address&gt;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Contact the author of this page:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:wangbonsgo@163.com&quot;</span>&gt;</span>wangbonsgo@163.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:949000744@qq.com&quot;</span>&gt;</span>949000744@qq.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试样式时发现，这个元素在结构上应该不能够从属于段落&lt;p&gt;</p>
<h2 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h2><p>上标元素为&lt;sub&gt;，如： H&lt;sub&gt;2&lt;/sub&gt;O —- H<sub>2</sub>O<br>上标元素为&lt;sup&gt;，如： x&lt;sup&gt;3&lt;/sup&gt;3 —- x<sup>3</sup></p>
<h2 id="展示计算机代码"><a href="#展示计算机代码" class="headerlink" title="展示计算机代码"></a>展示计算机代码</h2><p>&lt;code&gt; 元素用来标记通用代码，&lt;pre&gt; 元素用来保留空白字符；一般，&lt;code&gt; 元素需要用 &lt;pre&gt; 元素来包围  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>const para = document.querySelector(&#x27;p&#x27;);</span><br><span class="line"></span><br><span class="line">  para.onclick = function() &#123;</span><br><span class="line">    alert(&#x27;js点击&#x27;);</span><br><span class="line">  &#125;<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试样式时发现，这个元素在结构上应该不能够从属于段落&lt;p&gt;</p>
<h2 id="标记时间和日期"><a href="#标记时间和日期" class="headerlink" title="标记时间和日期"></a>标记时间和日期</h2><p>使用 &lt;time&gt; 元素标记时间和日期</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 标准简单日期 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-01-20&quot;</span>&gt;</span>20 January 2016<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只包含年份和月份--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-01&quot;</span>&gt;</span>January 2016<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只包含月份和日期 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;01-20&quot;</span>&gt;</span>20 January<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只包含时间，小时和分钟数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;19:30&quot;</span>&gt;</span>19:30<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 还可包含秒和毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;19:30:01.856&quot;</span>&gt;</span>19:30:01.856<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日期和时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-01-20T19:30&quot;</span>&gt;</span>7.30pm, 20 January 2016<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="文档和网站架构"><a href="#文档和网站架构" class="headerlink" title="文档和网站架构"></a>文档和网站架构</h1><p>网页外观多种多样，但都倾向于使用类似的标准组件:</p>
<ul>
<li>页眉<br><dd>通常横跨于整个页面顶部有一个大标题 和/或 一个标志。这是网站的主要一般信息，通常存在于所有网页。</dd></li>
<li>导航栏<br><dd>指向网站各个主要区段的超链接。通常用菜单按钮、链接或标签页表示。</dd></li>
<li>侧边栏<br><dd>一些外围信息、链接、引用、广告等；也可能存在辅助导航系统</dd></li>
<li>主内容</li>
<li>页脚<br><dd>横跨页面底部的狭长区域。和标题一样，页脚是放置公共信息（比如版权声明或联系方式）的，一般使用较小字体，且通常为次要内容。还可以通过提供快速访问链接来进行 SEO。</dd></li>
</ul>
<h2 id="用于构架内容的HTML"><a href="#用于构架内容的HTML" class="headerlink" title="用于构架内容的HTML"></a>用于构架内容的HTML</h2><p>HTML提供了明确这些区段的专用标签:</p>
<ul>
<li>&lt;header&gt; 页眉<br><dd>如果作为 body 子元素，那么就是全局页眉；如果是 article 或 section 的子元素，那么这些部分特有的页眉</dd></li>
<li>&lt;nav&gt; 导航栏</li>
<li>&lt;main&gt; 主内容。著内容下有各种子内容段，如 article、section<br><dd>每个页面上只能用一次 &lt;main&gt;，应该直接位于&lt;body&gt;中</dd><br><dd> &lt;section&gt;适用于组织页面功能，如迷你地图、文章摘要</dd></li>
<li>&lt;aside&gt; 侧边栏，经常嵌套在 &lt;main&gt; 中</li>
<li>&lt;footer&gt; 页脚</li>
</ul>
<p>一般body的组织方式为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header--h1       本站统一主标题</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">nav--ul         本站统一导航栏目</span><br><span class="line">    --form       本站统一搜索栏</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">main--aside--h2--ul   本站统一侧边栏</span><br><span class="line">    --article   帖子</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">footer--p        本站统一页脚</span><br></pre></td></tr></table></figure>
<h3 id="无语义元素–-div、span"><a href="#无语义元素–-div、span" class="headerlink" title="无语义元素– div、span"></a>无语义元素– div、span</h3><p>&lt;span&gt; 是一个内联(inline)的无语义元素，&lt;div&gt; 是一个块级(block)无语义元素<br>这两个元素应当在找不到更好的语义元素，或不想怎加特定含义时才使用；应该配合class属性，易于设定样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shopping-cart&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>银耳环<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>：$99.95.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../products/3333-0985/&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Silver earrings&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>总价：$237.89<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="换行水平分割线–-br、hr"><a href="#换行水平分割线–-br、hr" class="headerlink" title="换行水平分割线– br、hr"></a>换行水平分割线– br、hr</h3><p>换行元素 &lt;br&gt;<br>水平分割线元素 &lt;hr&gt; ，会渲染成一条水平直线</p>
<h3 id="HTML验证"><a href="#HTML验证" class="headerlink" title="HTML验证"></a>HTML验证</h3><p>让网页通过W3C的标记验证服务<a href="https://validator.w3.org/">Markup Validation Service</a></p>
<h1 id="多媒体与嵌入"><a href="#多媒体与嵌入" class="headerlink" title="多媒体与嵌入"></a>多媒体与嵌入</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>像 &lt;img&gt; 和 &lt;video&gt; 这样的元素有时被称为替换元素，因为这样的元素内容和尺寸有外部资源定义，而非元素本身  </p>
<p>图片有以下属性:</p>
<ul>
<li>属性 src ，使用统一资源定位符URL指向外部资源  </li>
<li>属性 alt ，备选文本<br><dd>在图片无法显示或不能被看到的情况下(如辅助阅读)显示；某些备选文本没有意义的情况下，应该赋予空值<br></dd></li>
<li>属性 width height<br><dd>设定图片显示的高度和宽度，会造成拉伸或缩小；如果图片正在加载，则会预留空白，设定图片尺寸可以有效避免因加载图片导致的页面文本“跳动”；然而，如果需要改变图片尺寸，应该使用 CSS ；<br></dd></li>
<li>属性 title ，图片标题，鼠标悬停显示</li>
</ul>
<h3 id="图片搭配文字说明"><a href="#图片搭配文字说明" class="headerlink" title="图片搭配文字说明"></a>图片搭配文字说明</h3><p>&lt;figure&gt; 和 &lt;figcaption&gt; 元素能够更好地为图片提供一个语义容器，建立图片与说明文字的联系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/test.jpg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">height</span>=<span class="string">&quot;341&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>这是一张精美的测试图片，清晰地展示了测试的用途<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，&lt;figure&gt; 不一定是一张图片，可以是几张图片、一段代码、音视频、方程或表格等。</p>
<h3 id="CSS背景图片"><a href="#CSS背景图片" class="headerlink" title="CSS背景图片"></a>CSS背景图片</h3><p>使用 CSS 嵌入的背景图片要求不包含语义</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;images/test.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样插入图片的方法能够更好地设置图片</p>
<h2 id="插入视频和音频内容"><a href="#插入视频和音频内容" class="headerlink" title="插入视频和音频内容"></a>插入视频和音频内容</h2><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><p>&lt;video&gt;插入视频，关于视频格式和其他问题不记录，此处仅给出样例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">autoplay</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">       <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">poster</span>=<span class="string">&quot;poster.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>muted会默认关闭声音；poster指向预览图片；preload用来缓冲文件，”none”表示不缓冲</p>
<h3 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h3><p>&lt;audio&gt;插入视频。相比 &lt;video&gt; 元素，它没有预览poster和高宽度的属性</p>
<h3 id="显示音轨文本"><a href="#显示音轨文本" class="headerlink" title="显示音轨文本"></a>显示音轨文本</h3><p>需要准备WebVTT文件(.vtt)，用 &lt;tracks&gt; 标签链接到 .vtt 文件并放在 &lt;audio&gt; 或 &lt;video&gt; 视频中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;example.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;example.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">track</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">src</span>=<span class="string">&quot;subtitles_en.vtt&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="嵌入技术"><a href="#嵌入技术" class="headerlink" title="嵌入技术"></a>嵌入技术</h2><p>这里主要记录 &lt;ifarme&gt; 元素，下面是一个嵌入MDN术语表的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://developer.mozilla.org/zh-CN/docs/Glossary&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">allowfullscreen</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">sandbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://developer.mozilla.org/zh-CN/docs/Glossary&quot;</span>&gt;</span></span><br><span class="line">    Fallback link for browsers that don&#x27;t support iframes</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而，实际嵌入时，报出这样的错误：<br><br>Refused to display … it set ‘X-Frame-Options’ to ‘deny’；如果换成某个静态网站，即没有设置拒绝嵌入的，则可以成功嵌入</p>
<p>由于 &lt;ifarme&gt; 的嵌入技术存在安全问题，其中单击劫持(比如使用透明的外部网页诱导输入或点击)是一种常见的iframe攻击</p>
<p>由于安全和版权的问题，应该仅在有必要的时候嵌入（以及允许嵌入，如设置返回头 X-Frame-Options&#x3D;’deny’），并且始终使用沙盒属性sandbox</p>
<h2 id="矢量图介绍"><a href="#矢量图介绍" class="headerlink" title="矢量图介绍"></a>矢量图介绍</h2><p>SVG 是用于描述矢量图像的XML语言，SVG 用于标记图形，而不是内容<br>以下代码创建一个圆和矩形，把它写在txt文件后，改 .svg 后缀，即可被浏览器识别：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">baseProfile</span>=<span class="string">&quot;full&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">r</span>=<span class="string">&quot;90&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于简单的图像，矢量图十分容易编写，且可内嵌文字</p>
<p>在HTML页面中引入矢量图有两种方法，一是使用 &lt;img&gt; 元素，指向 .svg 文件；二是使用 &lt;svg&gt; 元素</p>
<p>以下展示使用 &lt;svg&gt; 元素的方法:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方法的明显缺点是无法像普通图片一项缓存内联SVG；不过若是少数使用，则免去了维护文件的麻烦</p>
<h1 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h1><h2 id="切换显示不同大小的图片"><a href="#切换显示不同大小的图片" class="headerlink" title="切换显示不同大小的图片"></a>切换显示不同大小的图片</h2><p>显示相同内容，但仅仅根据设备大小来显示更大或更小的图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg 320w,</span></span></span><br><span class="line"><span class="string"><span class="tag">             elva-fairy-480w.jpg 480w,</span></span></span><br><span class="line"><span class="string"><span class="tag">             elva-fairy-800w.jpg 800w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 320px) 280px,</span></span></span><br><span class="line"><span class="string"><span class="tag">            (max-width: 480px) 440px,</span></span></span><br><span class="line"><span class="string"><span class="tag">            800px&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;elva-fairy-800w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>srcset 定义了浏览器选择的图像集，以及每个图像的大小<br><dd>每项以逗号隔开，每个项目写： 一个文件名，一个空格，图像的固有宽度（480w 以像素为单位，w是宽度描述符）</dd></li>
<li>sizes 定义了一组媒体条件，如窗口宽度，并在条件下为真下指明图片尺寸<br><dd>每项以逗号隔开，每个项目写：一个媒体条件（max-width:480x 表可是窗口宽度480像素或更少），一个空格，图像填充的<strong>槽的宽度</strong></dd></li>
<li>src 这仍是有必要的，部分浏览器可能会忽略自适应特征</li>
</ul>
<p>有了这两个属性，浏览器会查看设备宽度，检查 sizes 列表中真的条件，并查看给与的槽的大小，最后引用 srcset 中最接近所选槽大小的图像</p>
<p>备注：在HTML文件的头部标签了，手机端很可能找到以下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这行代码强制让手机浏览器采用真实窗口宽度来加载网页（因为某些手机浏览器会提供不真实的宽度，然后加载大宽度页面后缩小）</p>
<h2 id="相同图片在不同分辨率下缩放"><a href="#相同图片在不同分辨率下缩放" class="headerlink" title="相同图片在不同分辨率下缩放"></a>相同图片在不同分辨率下缩放</h2><p>有些设备具有高分辨率，为了显示同样尺寸，过 srcset 和 x 语法结合 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg,</span></span></span><br><span class="line"><span class="string"><span class="tag">             elva-fairy-480w.jpg 1.5x,</span></span></span><br><span class="line"><span class="string"><span class="tag">             elva-fairy-640w.jpg 2x&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;elva-fairy-640w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，以下 CSS 会应用:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当访问页面设备具有低分辨率，一个设备像素表示一个css像素，elva-fairy-320w.jpg 会被加载；<br>如果访问页面设备的一个设备像素表示两个css像素，elva-fairy-640w.jpg 2x 会被加载</p>
<h2 id="对图片进行美术设计"><a href="#对图片进行美术设计" class="headerlink" title="对图片进行美术设计"></a>对图片进行美术设计</h2><p>在不同访问网页设备上，都能“同样”显示图片重要部分<br>使用 &lt;picture&gt; 元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 799px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-480w-close-portrait.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 800px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-800w.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;elva-800w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Chris standing up holding his daughter Elva&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的 media 属性与 sizes类似</p>
<h1 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h1><h2 id="表格基础层次"><a href="#表格基础层次" class="headerlink" title="表格基础层次"></a>表格基础层次</h2><p>表格架构:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每一个 &lt;tr&gt; 标签将创建一行；包围在 &lt;tr&gt; 内的 多个 &lt;td&gt; 为单元格(单元格为空也会创建一个空的单元格)；如果被包围的是 &lt;hd&gt; 则这个单元格被赋予标题的意义</p>
<p>使用 colspan 属性可以让一个单元格的宽度为多个单元格；同样，使用 rowspan 属性可以让一个单元格高度为多个单元格</p>
<p>此外，html中应用的表格样式很容易被css覆盖，且不好管理，应该使用 CSS 进行样式设置</p>
<h2 id="表格特性"><a href="#表格特性" class="headerlink" title="表格特性"></a>表格特性</h2><h3 id="表格描述"><a href="#表格描述" class="headerlink" title="表格描述"></a>表格描述</h3><p>&lt;caption&gt; 元素为表格增加描述    </p>
<h3 id="注明表格结构的元素"><a href="#注明表格结构的元素" class="headerlink" title="注明表格结构的元素"></a>注明表格结构的元素</h3><p>使用元素标记表格，定义为表头、页脚、正文部分，这有助于 CSS 的应用:</p>
<ul>
<li>&lt;thead&gt; 嵌套在 table 元素中，通常包围表格的标题行</li>
<li>&lt;tbody&gt; 嵌套在 table 元素中，默认会隐式包含</li>
<li>&lt;tfoot&gt; 嵌套在 table 元素中，允许包围 &lt;tr&gt;，包围的 &lt;tr&gt; 会被认定为页脚，放在表格最后一行</li>
</ul>
<p>由于 &lt;tbody&gt; 的隐式包含，实际上我们做的是把表格头和表格页脚额外标注出来</p>
<h3 id="指明行标题、列标题"><a href="#指明行标题、列标题" class="headerlink" title="指明行标题、列标题"></a>指明行标题、列标题</h3><p>&lt;th&gt; 元素表明当前单元格作为标题，如果添加 scope 属性会帮助理解是行标题，还是列标题，这对于辅助阅读十分有帮助</p>
<p>scope 属性可以取值 “col”、”row”、”colgroup”、”rowgroup”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;clogroup&quot;</span>&gt;</span>购物<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>商品名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>购买地点<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>购买日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>商品评价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>商品价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ... ...</span><br></pre></td></tr></table></figure>

<p>对于每个单元格，也可以指定它从属的标题的id，这要对 &lt;td&gt; 使用 headers 属性，但个人认为不具有实用价值</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>web前端</category>
        <category>HTML专题</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础语法</title>
    <url>/2022/08/15/%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录Markdown基本语法</p>
<ul>
<li>2022-07-13 <ul>
<li>重新整理了一些不标准和不合适的markdown语法</li>
<li>试图更新table样式，发现table样式似乎写死，指定样式无用。</li>
</ul>
</li>
</ul>
<span id="more"></span>






<h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><h1 id="Heading-level-1"><a href="#Heading-level-1" class="headerlink" title="Heading level 1"></a>Heading level 1</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Heading level 1//一级标题，注意井号后面有个空格</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">Heading level 1</span></span><br><span class="line"><span class="section">========</span></span><br></pre></td></tr></table></figure>

<h2 id="Heading-level-2"><a href="#Heading-level-2" class="headerlink" title="Heading level 2"></a>Heading level 2</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## Heading level 2//二级标题</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">Heading level 2</span></span><br><span class="line"><span class="section">---------</span></span><br></pre></td></tr></table></figure>

<h3 id="Heading-level-3"><a href="#Heading-level-3" class="headerlink" title="Heading level 3"></a>Heading level 3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">### Heading level 3//三级标题，增加井号数量可继续增加子标题等级</span></span><br></pre></td></tr></table></figure>
<h1 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h1><p>今天天气不错，<br>午饭吃了吗</p>
<p>还没有吃</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">今天天气不错，</span><br><span class="line">午饭吃了吗</span><br><span class="line"></span><br><span class="line">还没有吃</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">段落，用空白行隔开段落，段落前不要用空格或制表符缩进段落</span><br></pre></td></tr></table></figure>
<h1 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h1><p>这是第一行<br><br>这是第二行<br><br>这是第三行</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是第一行<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">这是第二行<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">这是第三行</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">也在行尾使用两个空格作为换行符</span><br></pre></td></tr></table></figure>
<h1 id="强调单词或句子"><a href="#强调单词或句子" class="headerlink" title="强调单词或句子"></a>强调单词或句子</h1><p>今天<strong>天气</strong>真不错啊<br><br>今天<em>天气</em>真不错啊<br><br>今天<em><strong>天气</strong></em>真不错啊<br><br>今天~~ 天气 ~~真不错啊</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">粗体：   </span><br><span class="line"><span class="code">    今天**天气**真不错啊</span></span><br><span class="line"><span class="code">斜体：</span></span><br><span class="line"><span class="code">    今天*天气*真不错啊</span></span><br><span class="line"><span class="code">斜粗体：</span></span><br><span class="line"><span class="code">    今天***天气***真不错啊</span></span><br><span class="line"><span class="code">删去线：</span></span><br><span class="line"><span class="code">    今天~~ 天气 ~~真不错啊</span></span><br></pre></td></tr></table></figure>


<h1 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h1><blockquote>
<p>第一段落：撅草棍儿抽长短</p>
<p>第二段落：谁长谁先干</p>
<blockquote>
<p>这里是子嵌套的</p>
</blockquote>
</blockquote>
<blockquote><p>今天天气不错</p>
</blockquote>


<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;第一段落：撅草棍儿抽长短</span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;第二段落：谁长谁先干</span></span><br><span class="line">&gt;&gt;这里是子嵌套的</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">多个段落的块引用间，空行也要加&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">今天天气不错</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项<ol>
<li>子项</li>
<li>子项</li>
</ol>
</li>
<li>第四项<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项 //注意点后有空格</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br><span class="line"><span class="bullet">    1.</span> 子项</span><br><span class="line"><span class="bullet">    2.</span> 子项</span><br><span class="line"><span class="bullet">4.</span> 第四项</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li><p>第一项</p>
<blockquote>
<p>今天天气不错</p>
</blockquote>
</li>
<li><p>第二项</p>
<ul>
<li>子项</li>
<li>子项</li>
<li>子项</li>
</ul>
</li>
<li><p>第三项</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt;今天天气不错 //列表中可嵌套其他元素</span></span><br><span class="line"><span class="code">- 第二项</span></span><br><span class="line"><span class="code">    - 子项</span></span><br><span class="line"><span class="code">    - 子项</span></span><br><span class="line"><span class="code">    - 子项</span></span><br><span class="line"><span class="code">- 第三项</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h1><p>代码语法的作用是让代码在下面这样的框里显示</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">print(&quot;%d&quot;,a);</span><br><span class="line">//代码结束</span><br></pre></td></tr></table></figure>


<hr>
<p>编辑代码内容</p>
<pre><code><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">print(&quot;%d&quot;,a);</span><br><span class="line">//代码结束   </span><br></pre></td></tr></table></figure>
</code></pre>
<p>或者<br></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock  %&#125;</span><br><span class="line">int a=10;</span><br><span class="line">print(&quot;%d&quot;,a);</span><br><span class="line">//代码结束</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><p>第一行</p>
<hr>
<p>第二行</p>
<hr>
<p>第三行</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">第二行</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">___</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">第三行</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">独立成行的三个连续的<span class="emphasis">*，或三个连续的下划线可作分隔线</span></span><br></pre></td></tr></table></figure>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="加title的链接"><a href="#加title的链接" class="headerlink" title="加title的链接"></a>加title的链接</h2><p>这是一个链接 <a href="www.baidu.com">百度</a><br><br>这是一个链接 <a href="www.baidu.com" title="百度搜素">百度</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个链接 [<span class="string">百度</span>](<span class="link">www.baidu.com</span>)<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">这是一个链接 [<span class="string">百度</span>](<span class="link">www.baidu.com &quot;百度搜素&quot;</span>)//鼠标放到链接上有“百度搜索”提示</span><br></pre></td></tr></table></figure>
<h2 id="网址和邮箱地址"><a href="#网址和邮箱地址" class="headerlink" title="网址和邮箱地址"></a>网址和邮箱地址</h2><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#x66;&#x61;&#107;&#x65;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x66;&#x61;&#107;&#x65;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://markdown.com.cn&gt;</span></span><br><span class="line"><span class="language-xml">&lt;fake@example.com&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h2><p>今天天气不错，查看 <em><strong><a href="http://www.weather.com.cn/">中国天气</a></strong></em><br><br>查看<a href="#code"><code>code</code></a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">今天天气不错，查看 <span class="strong">**<span class="emphasis">*[<span class="string">中国天气</span>](<span class="link">http://www.weather.com.cn/</span>)*</span>**</span></span><br><span class="line">查看[<span class="string">`code`</span>](<span class="link">#code</span>)</span><br></pre></td></tr></table></figure>


<h1 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h1><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p><img src="/../../themes/next_a/source/images/avatars/aoba.jpg" alt="图片1" title="aoba"><br></p>
<p><img src="/assets/images/aoba.jpg" alt="青叶" title="aoba"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片</span>](<span class="link">../../themes/next_a/source/images/avatars/aoba.jpg &quot;aoba&quot;</span>)<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>  //以该post的地址作为起始地址，这样的链接是错误的</span><br><span class="line"></span><br><span class="line">![<span class="string">青叶</span>](<span class="link">/assets/images/aoba.jpg &quot;aoba&quot;</span>)  //运行时相对地址的起始为博客的根目录文件夹，这样的链接是正确的</span><br></pre></td></tr></table></figure>

<h2 id="给图片添加链接"><a href="#给图片添加链接" class="headerlink" title="给图片添加链接"></a>给图片添加链接</h2><p><a href="http://newgame-anime.com/assets/character/c4.png" title="hifumi"><img src="/assets/images/hifumi.jpg" alt="日富美" title="hifumi"></a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![日富美</span>](<span class="link">/assets/images/hifumi.jpg &quot;hifumi&quot;</span>)](<span class="link">http://newgame-anime.com/assets/character/c4.png &quot;hifumi&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><h2 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h2><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>反斜线</td>
</tr>
<tr>
<td>&#96;</td>
<td>反引号</td>
</tr>
<tr>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>{}</td>
<td>花括号</td>
</tr>
<tr>
<td>[]</td>
<td>方括号</td>
</tr>
<tr>
<td>()</td>
<td>圆括号</td>
</tr>
<tr>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>-</td>
<td>减号，连字符</td>
</tr>
<tr>
<td>.</td>
<td>圆点</td>
</tr>
<tr>
<td>!</td>
<td>感叹号</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="特殊字符自动转义"></a>特殊字符自动转义</h2><p>如果你使用 &amp; 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 &amp;amp;。</p>
<h1 id="内嵌HTML标签"><a href="#内嵌HTML标签" class="headerlink" title="内嵌HTML标签"></a>内嵌HTML标签</h1><h2 id="lt-ruby-gt"><a href="#lt-ruby-gt" class="headerlink" title="&lt;ruby&gt;"></a>&lt;ruby&gt;</h2><p><ruby>拼音<rt>pinyin</rt></ruby></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span>拼音<span class="language-xml"><span class="tag">&lt;<span class="name">rt</span>&gt;</span></span>pinyin<span class="language-xml"><span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span></span><br></pre></td></tr></table></figure>





<h2 id="lt-detail-gt"><a href="#lt-detail-gt" class="headerlink" title="&lt;detail&gt;"></a>&lt;detail&gt;</h2><details class="note primary no-icon" open="">
<summary><p><strong>总描述</strong></p>
</summary>

<table>
<thead>
<tr>
<th align="left">栏目1</th>
<th align="center">栏目2</th>
<th align="left">栏目 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="center">反斜线</td>
<td align="left">\</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="center">反引号</td>
<td align="left">&#96;</td>
</tr>
<tr>
<td align="left">_</td>
<td align="center">下划线</td>
<td align="left">_</td>
</tr>
</tbody></table>
</details>


<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">details</span> <span class="attr">class</span>=<span class="string">&quot;note primary no-icon&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span>总描述<span class="language-xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">| 栏目1 | 栏目2 | 栏目 3|</span><br><span class="line">| :--- | :----: |:---|  //对齐方式</span><br><span class="line">| \  | 反斜线 | \ |</span><br><span class="line">| <span class="code">`  | 反引号 | `</span> |</span><br><span class="line">| <span class="emphasis">_  | 下划线 | _</span> |</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<details class="note primary no-icon" open="">
<summary><p><strong>总体介绍</strong></p></summary>
<table>
<caption style="text-align: left;">表格标题</caption>
<thead>
<tr class="header">
<th style="text-align: center;">栏目1</th>
<th style="text-align: center;">栏目2</th>
<th style="text-align: center;">栏目3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">aaa</td>
</tr>
<tr class="even">
<td style="text-align: center;">b</td>
<td style="text-align: center;">bb</td>
<td style="text-align: center;">bbb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">b</td>
<td style="text-align: center;">bb</td>
<td style="text-align: center;">bbb</td>
</tr>
</tbody>
</table>
</details>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">class</span>=<span class="string">&quot;note primary no-icon&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>总体介绍<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span> <span class="comment">&lt;!--hexo这里css文件似乎有问题，无法指定格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">caption</span> <span class="attr">style</span>=<span class="string">&quot;text-align: left;&quot;</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>栏目1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>栏目2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>栏目3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;odd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;even&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;odd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>《自控力》阅读</title>
    <url>/2022/08/01/%E9%98%85%E8%AF%BB/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<ul>
<li>2022-08-03 记录第一章到第三章的阅读体会</li>
</ul>
<span id="more"></span>

<h2 id="“我要做”、“我不要做”、“我想要”是意志力的三种力量。"><a href="#“我要做”、“我不要做”、“我想要”是意志力的三种力量。" class="headerlink" title="“我要做”、“我不要做”、“我想要”是意志力的三种力量。"></a>“我要做”、“我不要做”、“我想要”是意志力的三种力量。</h2><p>这三种力量在生理上有迹可循，由大脑前额灰质的三个区域掌控。</p>
<p>大脑保存了原始生存本能，比如，在原始社会，爱吃甜食和暴饮暴食可能是因为多储存脂肪能更容易生存下去，爱偷懒睡觉可能是为了节省能量，以备不测。这些原始生存本能显然已经不能适应现代社会了。</p>
<p>自控的过程，一定程度上是意志力三种力量和不适应现代社会的原始生存本能之间的对抗，是理性的自我和冲动的自我的对抗。冲动的自我希望你放弃思考，遵循本能行动：比如看到美味的蛋糕，大脑会释放多巴胺，通过某些化学反应降低血糖，从而让身体强烈的希望你摄入糖分。此时并不是真正地缺少能量。<br>理性的自我则会让你思考，你“要做什么”、“不要做什么”、“想要做什么”。</p>
<h3 id="意志力挑战的第一法则是：认识自己"><a href="#意志力挑战的第一法则是：认识自己" class="headerlink" title="意志力挑战的第一法则是：认识自己"></a>意志力挑战的第一法则是：认识自己</h3><p>意识到、认识到自己当前正在做选择，让理性的自我参与“选择”，避免让冲动本能直接决定结果。<br>这部分难点在于，注意力很容易被分散，比如商场的大喇叭和吵闹音乐就是让你分散注意力，让你难以集中注意力思考；看到美味蛋糕，身体通过一系列生理反应降低血糖，也让你难以集中注意力思考。它们让你在做决定时没有意识到，自己正在做出抉择。</p>
<h3 id="“认识自己”的方法："><a href="#“认识自己”的方法：" class="headerlink" title="“认识自己”的方法："></a>“认识自己”的方法：</h3><p>可以做出标记提醒自己要做出抉择，可以在冰箱上贴上标签，明确告知自己此处将会发生意志力挑战。<br>人的大脑会一定程度上适应训练，训练大脑增强专注力是可行的。书中提供的方法是每天冥想5分钟。</p>
<h2 id="面对“诱惑”需要”三思而后行”"><a href="#面对“诱惑”需要”三思而后行”" class="headerlink" title="面对“诱惑”需要”三思而后行”"></a>面对“诱惑”需要”三思而后行”</h2><p>书中举了两种“威胁”，一个是剑齿虎，一个是草莓奶酪蛋糕。剑齿虎是直接威胁，身体直接感知并认定为威胁，这与你的理性认知一致；草莓奶酪蛋糕是间接威胁，你的理性认知中会把它当作间接威胁，但是你的身体却会把它当作“多多益善”的资源。</p>
<p>看到剑齿虎会让人产生应激反应，阻止你的前额皮质发挥作用，呼吸加粗血流加大，能量会进入血液，集中所有能量用于身体力量的管理；哪怕一瞬间做出的决定不是最佳策略，大脑也没有多余的能量让你重新思考。举个例子：</p>
<p>学校里有人在转角处扔出来一只玩具大老虎，尽管我知道这是在学校里，周围也有很多同学，但这些疑问仅仅是一闪而过，我大脑一瞬间的想法是“别管了，盯住这只老虎”，然后身体处于备战状态，死死盯住这只玩具老虎。</p>
<p>看到草莓奶酪蛋糕，则大脑会释放多巴胺，通过复杂化学反降低血糖，那么身体就会强烈希望你去摄取糖分，吃下这个蛋糕。此时你能够面对的敌人是内心。面对草莓奶酪蛋糕，我们需要“三思而后行”，“心率变异度”则是衡量能否有效进行思考的生理学测量指标。疼痛、压力、焦虑、垃圾食品、糟糕的空气都会影响心率变异度。</p>
<h3 id="提高“心率变异度”的方法："><a href="#提高“心率变异度”的方法：" class="headerlink" title="提高“心率变异度”的方法："></a>提高“心率变异度”的方法：</h3><p>除了主动集中注意力，尝试思考意外，我们还需要外力来帮助降低心率变异度（较低的有助于自控）。改善心情、健康良好的饮食、放松身心都可以降低心率变异度；此外充足的睡眠能够也能有所帮助，因为睡眠不足会影响葡萄糖吸收，降低你的血糖。</p>
<h2 id="自控力和肌肉一样有极限"><a href="#自控力和肌肉一样有极限" class="headerlink" title="自控力和肌肉一样有极限"></a>自控力和肌肉一样有极限</h2><p>意志力有“肌肉一样的模式”:<br>    - 长时间的使用会无力<br>    - 睡一觉或睡几觉会恢复<br>    - 有节制地使用和锻炼会增强力量<br>    - 拥有潜能，可以在某些条件下激发，如“加油”<br>    - 避免“意志力肌肉拉伤”</p>
<p>这四点特性要求我们有方向地锻炼意志力，除了锻炼自己地意志力意外，还要合理利用当前的意志力。</p>
<p><strong>长时间使用会无力，它的对策是合理分配意志力能量。</strong>要先做消耗“力量”的，再做消耗“耐力”的。比如，做完引体向上后能有余力再跑一千五百米，但是跑完一千五百米后却没有余力再做引体向上（适用于体能一般的人，比我如）。在意志力仍有余力地时候，人总是会不自觉地加大投入以完善当前任务，哪怕它可能不需要太多意志力地投入。此外琐事也可能大量消耗你的意志力，不要在它们上面重复消耗你的意志力，有序地处理可以避免因琐事“失控”（有时不得不立刻处理它们，此时希望你尽量保持内心平静吧）。</p>
<p><strong>休息后意志力会恢复，以及锻炼会增强意志力，这两点特性告诉我们，勤于锻炼意志力（尽管锻炼过程中会消耗意志力）而不必过度担忧意志力的丧失。</strong>当然，锻炼意志力需要你合理分配意志力能量，当留有你需要集中精力去处理的事务的时候，应该避免任何意志力的消耗。锻炼意志力需要你在“不会失控”的环境中进行，平时做些“微小的自控力锻炼”也是很有效的方法，它们对自控力的消耗微乎其微但却能有效锻炼，比如每天起床时用左手打开房门，不说特定语句的脏话（当然全都不说最好，但这或许有些难度），这些事情消耗的仅仅是当下一瞬间的意志力，因为你从意识到到抉择完毕只需要一瞬间，甚至习惯后后不需要消耗意志力，又培养了一个好习惯。</p>
<p>接下来会探讨意志力有类似肌肉模式的原因，了解原因后，你会对激发意志力潜能和避免“意志力肌肉拉伤”有更加深入的了解。</p>
<p>回想一下你沉下心，专注学习的过程，起初你全神贯注，对书中任何一个问题都进行仔细地分析；学习一段时间后（也许时半小时，也许是两个小时），你会发现脑袋有些难受，你告诉自己专注专注，可是看了一会书，不自觉的又发起呆来。此时你应该很想吃些甜食，或者打会游戏放松一下，但理智的你告诉自己，一旦松懈下来，今天就再也无法再静下心看书了。这本书的作者的所了解的研究表明，大脑专注学习时消耗的能量远不如运动时消耗的能量，但是为什么你的大脑会出现“能量短缺”？</p>
<p>因为大脑在自作主张地帮你管理能量，它是个小气鬼，一旦发现能量有流失的趋势，就开始削减预算。就像银行一样，资金充裕就会始放贷（考虑长远利益），尽管有时候利率比较低，但它也想着不能浪费每一分每一秒，迫不及待地开始放贷。因此在“资金充裕”的时候，尽管大脑会谋划长期利益，也需要你考虑一下，到底给谁放贷收益更高，贷多少资金比较合适。银行在资金紧缩时，哪怕利益再高也不会放贷，因为一旦储备掏空就会面临破产，比起长远利益，保住当下更为重要。银行的这种行为符合“原始生存本能”，但是到了现代社会，银行所谓的“资金紧缩”并不是真正地紧缩，因为我们总是会按时吃饭来补充“能量资金”。所以我们要想办法让大脑多掏出一些“意志力储备资金”，有时候也需要适当补充“意志力”资金，给大脑一个资金充裕的印象，诱使大脑放贷（但这不是随意饮食的理由，暴饮暴食反而会冲垮你的意志力）。</p>
<p>书中给出的“适当补充意志力资金”的方法是，低血糖饮食。低血糖饮食给了大脑，这是不多但是长期的“能量”投资，这种方法或许会让大脑掏出更多比率的“意志力储备金”。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>可扩展标记语言XML学习记录</title>
    <url>/2022/08/01/%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80XML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li>2022-08-02 完成了“XML基础”的更新<span id="more"></span></li>
</ul>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>EXtensible Markup Language，XML被设计用来传输和存储数据，HTML被设计用来显示数据。</p>
<h2 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h2><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><ul>
<li>XML文本内容是以标签描述的数据信息</li>
<li>XML标签不是预先定义的，以纯文本格式进行存储，独立于软件和硬件，便于在不兼容的系统之间交换数据（这依赖于针对具体XML格式编写的程序）</li>
<li>通过XML可以把数据从HTML中分离（这需要使用JS来读取XML文档）</li>
<li>XML用于创建新的Internet语言：<ul>
<li>WSDL - 用于描述可用的 web service </li>
<li>RSS - 用于 RSS feed 的语言</li>
</ul>
</li>
</ul>
<h3 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h3><p>XML以数结构组织数据内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><span class="comment">&lt;!-- XML声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span> <span class="comment">&lt;!-- 根元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span> <span class="comment">&lt;!-- 一级子元素，指定&quot;category&quot;自定义？属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span>     <span class="comment">&lt;!-- 二级子元素，指定&quot;lang&quot;自定义？属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span>  <span class="comment">&lt;!-- 二级子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> <span class="comment">&lt;!-- 二级子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span>  <span class="comment">&lt;!-- 二级子元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h3><ul>
<li>所有XML元素必须有关闭标签；声明部分不属于XML本身，不需要关闭标签</li>
<li>标签对大小写敏感</li>
<li>必须要有根元素</li>
<li>属性值必须加引号，如<note id="07">xxx</note></li>
<li>部分特殊符号需要使用实体引用来替代<table>
<thead>
<tr>
<th>实体引用</th>
<th>特殊符号</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td>&amp;gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>&amp;amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;apos;</td>
<td>&#39;</td>
</tr>
<tr>
<td>&amp;quot;</td>
<td>&quot;</td>
</tr>
</tbody></table>
  在XML中，直接使用 &lt; 和 &amp; 确实是非法的，直接使用 &gt; 是合法的，但使用实体引用代替是个好习惯 </li>
<li>注释语法  &lt;!– xxx –&gt;</li>
<li>XML中多个空格会被保留，HTML则会把连续多个空格合并为一个</li>
<li>XML以LF(换行符)表示新行</li>
</ul>
<h3 id="XML元素和XML属性"><a href="#XML元素和XML属性" class="headerlink" title="XML元素和XML属性"></a>XML元素和XML属性</h3><ul>
<li>元素命名避免 -  .  :  等字符，支持下划线</li>
<li>元素可扩展，扩展元素后的XML文档能够适应旧XML文档</li>
<li>在XML中，除了 id&#x3D;’07’ 此类源数据应当存储为属性，其余数据应避免成为属性</li>
<li>可以拆分的元素应拆分成子元素，如以下代码：  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">day</span>&gt;</span>02<span class="tag">&lt;/<span class="name">day</span>&gt;</span>       <span class="comment">&lt;!-- date=&#x27;2022/08/02&#x27;拆分为年月日三个子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">month</span>&gt;</span>08<span class="tag">&lt;/<span class="name">month</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>2022<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>属性值必须加引号，单引号双引号均可；如果属性值本身包含双引号，那么必须用单引号包围它（或使用实体引用）</li>
</ul>
<h3 id="XML验证"><a href="#XML验证" class="headerlink" title="XML验证"></a>XML验证</h3><p>W3C 的 XML 规范声明：如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。理由是，XML 软件应当轻巧，快速，具有良好的兼容性。<br>如果浏览器打开了某个有错误的 XML 文件，那么它会报告错误</p>
<p>XML文档可以声明用来遵守文档类型定义（DTD，Document Type Definition）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;Note.dtd&quot;</span>&gt;</span> <span class="comment">&lt;!-- DOCTYPE声明是对外部DTD文件的引用,其中note.dtd是自定义的DTD文件 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.w3school.com.cn note.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  对XML Schema 的引用，其中note.xsd是自定义的XML Schema文件 --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="XML-JavaScript"><a href="#XML-JavaScript" class="headerlink" title="XML JavaScript"></a>XML JavaScript</h2><h3 id="XML-Http-Request"><a href="#XML-Http-Request" class="headerlink" title="XML Http Request"></a>XML Http Request</h3><p>XMLHttpRequest对象用于在后台与服务器交换数据，它能够:</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<h2 id="XML-进阶内容"><a href="#XML-进阶内容" class="headerlink" title="XML 进阶内容"></a>XML 进阶内容</h2><h1 id="SOAP——基于XML的建议协议"><a href="#SOAP——基于XML的建议协议" class="headerlink" title="SOAP——基于XML的建议协议"></a>SOAP——基于XML的建议协议</h1><p>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换<br><strong>什么是 SOAP？</strong></p>
<ul>
<li>SOAP 指简易对象访问协议</li>
<li>SOAP 是一种通信协议</li>
<li>SOAP 用于应用程序之间的通信</li>
<li>SOAP 是一种用于发送消息的格式</li>
<li>SOAP 被设计用来通过因特网进行通信</li>
<li>SOAP 独立于平台</li>
<li>SOAP 独立于语言</li>
<li>SOAP 基于 XML</li>
<li>SOAP 很简单并可扩展</li>
<li>SOAP 允许您绕过防火墙</li>
<li>SOAP 将被作为 W3C 标准来发展</li>
</ul>
<h3 id="SOAP语法"><a href="#SOAP语法" class="headerlink" title="SOAP语法"></a>SOAP语法</h3><p>一条SOAP消息就是一个普通的XML文档，包含以下元素:</p>
<ul>
<li>必要的 Envelope 元素，可把此 XML 文档标识为一条 SOAP 消息</li>
<li>可选的 Header 元素，包含头部信息</li>
<li>必要的的 Body 元素，包含所有的调用和响应信息</li>
<li>可选的 Fault 元素，提供有关在处理此消息所发生错误的信息</li>
<li>不能包含 DTD 引用</li>
<li>不能包含 XML 处理指令</li>
</ul>
<p>所有以上的元素均被声明于针对 SOAP 封装的默认命名空间中：<a href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a><br>以及针对 SOAP 编码和数据类型的默认命名空间：<a href="http://www.w3.org/2001/12/soap-encoding">http://www.w3.org/2001/12/soap-encoding</a></p>
<p>SOAP消息基本结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SOAP-Envelope-元素"><a href="#SOAP-Envelope-元素" class="headerlink" title="SOAP Envelope 元素"></a>SOAP Envelope 元素</h3><p>添加命名空间  xmlns:soap&#x3D;”<a href="http://www.w3.org/2001/12/soap-envelope&quot;">http://www.w3.org/2001/12/soap-envelope&quot;</a><br>添加编码方式属性  soap:encodingStyle&#x3D;”<a href="http://www.w3.org/2001/12/soap-encoding&quot;&gt;">http://www.w3.org/2001/12/soap-encoding&quot;&gt;</a></p>
<h3 id="SOAP-Header-元素"><a href="#SOAP-Header-元素" class="headerlink" title="SOAP Header 元素"></a>SOAP Header 元素</h3><p>如果 Header 元素被提供，则它必须是 Envelope 元素的第一个子元素。它可包含有关 SOAP 消息的应用程序专用信息（比如认证、支付等）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python基本语法记录-总览</title>
    <url>/2022/07/18/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<ul>
<li>2022-08-23 完成官方文档上，教程部分的初步记录</li>
</ul>
<span id="more"></span>


<h1 id="Python文件开头声明"><a href="#Python文件开头声明" class="headerlink" title="Python文件开头声明"></a>Python文件开头声明</h1><p>python源文件的开头可以指出调用的解释器位置，声明默认编码。如果指出了调用解释器的位置，它只生效于py作为一个单独脚本时，就像shell脚本一样。第二行指出编码规则，一般无需指出，默认都为utf-8</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br></pre></td></tr></table></figure>

<h1 id="Python数字、字符、列表速览"><a href="#Python数字、字符、列表速览" class="headerlink" title="Python数字、字符、列表速览"></a>Python数字、字符、列表速览</h1><h2 id="数字用于计算"><a href="#数字用于计算" class="headerlink" title="数字用于计算"></a>数字用于计算</h2><ol>
<li>运算符+、-、*、/(除法，返回浮点数)、//（除法，向下取整）、%、**(乘方)、&#x3D;  </li>
<li>混合运算中整数会自动转为float</li>
</ol>
<h2 id="字符串–immutable"><a href="#字符串–immutable" class="headerlink" title="字符串–immutable"></a>字符串–immutable</h2><ol>
<li>单引号与双引号标注结果相同，一般在单引号里使用双引号无需转义，反之亦然  </li>
<li>原始字符串标记r,在单引号或双引号面前添加r即可   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\some\name&#x27;</span>)</span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure></li>
<li>字符串与字符串，字符串与变量可以使用 +  *  运算符拼合 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix = <span class="string">&#x27;Py_&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix + <span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;Py_unununium&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>字符串也可以使用空符分隔来合并，这一功能在拆分长字符串换行显示是特别有用；但不能用于变量和字符串的合并 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;Put several strings within parentheses &#x27;</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;to have them joined together.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;Put several strings within parentheses to have them joined together.&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>字符串支持索引，索引从0开始，支持负数索引，负数索引中0和-0一样</li>
<li>字符串支持切片，形如 word[start:end]，若省略start的默认0，省略end则默认len(word);切片越界会自动处理，但索引会报错</li>
</ol>
<h2 id="列表–sequence，mutable"><a href="#列表–sequence，mutable" class="headerlink" title="列表–sequence，mutable"></a>列表–sequence，mutable</h2><ol>
<li>方括号分隔，元素之间使用逗号隔开，列表内元素可以不同类型，元素可以是列表</li>
<li>支持索引和切片，列表是mutable类型，可以通过索引和切片改变内容</li>
<li>支持使用 + 合并列表，支持list.append(e)添加元素，支持使用切片赋值、扩展、缩小、情况列表 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] <span class="comment">#使用切片扩展列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:<span class="number">0</span>]=[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基本编程语句"><a href="#基本编程语句" class="headerlink" title="基本编程语句"></a>基本编程语句</h2><ol>
<li>条件值判断标准：Python 和 C 一样，任何非零整数都为真，零为假。这个条件也可以是字符串或列表的值，事实上，任何序列都可以；长度非零就为真，空序列则为假。</li>
<li>print()函数输出给定参数的值，能实现格式化操作 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">256</span>*<span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The value of i is&#x27;</span>, i)   <span class="comment"># 指定参数i</span></span><br><span class="line">The value of i <span class="keyword">is</span> <span class="number">65536</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a, end=<span class="string">&#x27;,&#x27;</span>)   <span class="comment"># end替换默认换行符</span></span><br><span class="line">a,</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h1><p>Python 项目大多都遵循以下风格:</p>
<ul>
<li>缩进，用 4 个空格，不要用制表符。</li>
<li>4 个空格是小缩进（更深嵌套）和大缩进（更易阅读）之间的折中方案。制表符会引起混乱，最好别用。</li>
<li>换行，一行不超过 79 个字符。</li>
<li>用空行分隔函数和类，及函数内较大的代码块。</li>
<li>最好把注释放到单独一行。</li>
<li>使用文档字符串。</li>
<li>运算符前后、逗号后要用空格，但不要直接在括号内使用： a &#x3D; f(1, 2) + g(3, 4)。</li>
<li>类和函数的命名要一致；按惯例，命名类用 UpperCamelCase，命名函数与方法用 lowercase_with_underscores。命名方法中第一个参数总是用 self (类和方法详见 初探类)。</li>
<li>编写用于国际多语环境的代码时，不要用生僻的编码。Python 默认的 UTF-8 或纯 ASCII 可以胜任各种情况。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>python类的定义和使用</title>
    <url>/2022/07/18/%E5%AD%A6%E4%B9%A0/python/python%E5%9F%BA%E6%9C%AC/python%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>记录在python中类的使用方式</p>
<span id="more"></span>


<h1 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>namespace (命名空间)是映射到对象的名称。 abs 函数、内置异常等的内置函数集合；模块中的全局名称；函数调用中的局部名称；对象的属性集合都属于命名空间。不同命名空间的名称之间没有绝对关系。</p>
<p>点号之后的名称是属性，模块属性和模块中定义的全局名称之间存在直接的映射，它们属于相同的命名空间。属性可以是只读或可写的。可写的模块属性可以用 del modelname.funcname 删除该对象模块中的这个属性。</p>
<p>命名空间是在不同时刻创建的，拥有不同的生命周期；各类模块都有自己的命名空间:</p>
<ul>
<li>内置名称的命名空间是在python解释器启动时创建的，永远不会删除；它存在于模块 builtins</li>
<li>模块的全局命名空间在读取模块定义时创建；一般也会持续到解释器退出</li>
<li>从脚本文件读取或交互式读取的，由解释器顶层调用执行的 <strong>main</strong> 的一部分也拥有自己的全局命名空间</li>
<li>函数的本地命名空间在调用该函数时创建，并在函数返回或抛出不在函数内部处理的错误时”遗忘”。每次递归都有自己的本地命名空间</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是命名空间可直接访问的 Python 程序的文本区域。 “可直接访问” 的意思是，对名称的非限定引用会在命名空间中查找名称。  </p>
<p>作用域是静态确定的，但会被动态使用。执行期间的任何时刻，都会有3或4个命名空间可被直接访问的嵌套作用域:</p>
<ol>
<li>最内层作用域，首先搜索，包含局部名称(如果不存在生效的global 和 nonlocal 语句)</li>
<li>封闭的函数作用域，包含非全局和非局部名称，从最近的封闭作用域开始搜索</li>
<li>当前模块的作用域，包含当前模块的全局名称</li>
<li>最外层作用域，最后搜索，包含内置名称的命名空间</li>
</ol>
<p>del x 实际是从当前作用域的命名空间移除对 x 的绑定。</p>
<p>所有引入新名称的操作都是所用于局部作用域的，import 语句和函数定义会在局部作用域里绑定模块或函数名称。</p>
<p>global 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；nonlocal 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。</p>
<h2 id="作用域和命名空间示例"><a href="#作用域和命名空间示例" class="headerlink" title="作用域和命名空间示例"></a>作用域和命名空间示例</h2><p>下例演示了 global 和 nonlocal 对变量绑定的影响:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line">        spam = <span class="string">&quot;local spam&quot;</span>     <span class="comment"># 默认局部赋值没有改变对变量的绑定，这个赋值对外层无意义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> spam           <span class="comment"># nonlocal 赋值改变了当前作用域对变量的绑定(绑定到了外层的同名变量)</span></span><br><span class="line">        spam = <span class="string">&quot;nonlocal spam&quot;</span>  <span class="comment"># 这个赋值影响了外一层的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line">        <span class="keyword">global</span> spam             <span class="comment"># global 赋值给与变量全局的绑定(本身就没有对局部的绑定)</span></span><br><span class="line">        spam = <span class="string">&quot;global spam&quot;</span>    <span class="comment"># 这个赋值影响到了全局的变量，但不会影响外一层的变量</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line">    do_local()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br></pre></td></tr></table></figure>
<p>示例代码的输出是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">After local assignment: test spam</span><br><span class="line">After nonlocal assignment: nonlocal spam</span><br><span class="line">After global assignment: nonlocal spam</span><br><span class="line">In global scope: global spam</span><br></pre></td></tr></table></figure>

<h1 id="初探类"><a href="#初探类" class="headerlink" title="初探类"></a>初探类</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类定义时应该包含一个构造函数，定义一个初始状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, i</span>):</span><br><span class="line">    self.i = i</span><br></pre></td></tr></table></figure>
<p>注意，构造函数中的 self 参数不需要实例化时给出，它会自动赋为所在对象的引用</p>
<h2 id="类对象及其属性"><a href="#类对象及其属性" class="headerlink" title="类对象及其属性"></a>类对象及其属性</h2><p>类定义(class语句)和函数定义(def)一样，必须先执行才能生效，<strong>仅当（从结尾处）正常离开类定义时，才会创建一个类对象</strong>；如果类定义在条件语句和函数内部，没有进入内部前，类仍处于未定义。当进入类定义时，将会创建一个新的命名空间，用作局部作用域。 </p>
<p>假设定义这样的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, i</span>):</span><br><span class="line">        self.i = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>MyClass.i 和 MyClass.f 可以引用这个类对象的变量i和函数f。上面这个MyClass类对象中，i就像是静态变量，为类和类的所有实例共有。要定义仅属于实例的属性，建议在初始化函数__init__()中添加，也可以在方法中添加，此时添加的变量仅存在于这个实例的命名空间。</p>
<p>__doc__ 是一个有效的属性，将返回所属类的文档字符串</p>
<p>类的实例化使用函数表示方法，实例时无需指出self:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x= MyClass(<span class="number">7</span>) </span><br></pre></td></tr></table></figure>

<h2 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h2><p>所有实例对象公用其类对象的属性和函数（这样的函数被成为方法），而实例对象本身也可以添加属性，也可以使用del来删除实例对象的属性，此外类对象的属性也是可以用del删除的</p>
<p>此外，实例对象和类对象各有命名空间。用实例对象引用属性的方法，如果实例中没有这个变量，则会在类对象中的命名空间查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass.i=<span class="number">123456</span><span class="comment">#创建实例属性</span></span><br><span class="line">x.i = <span class="number">777</span>   <span class="comment">#创建实例属性</span></span><br><span class="line"><span class="keyword">del</span> x.i     <span class="comment">#删除实例属性，此时使用 x.i，引用的是类对象的 i属性</span></span><br><span class="line"><span class="keyword">del</span> MyClass.i   <span class="comment">#删除类属性，此时无法使用 x.i</span></span><br></pre></td></tr></table></figure>

<p>比较需要注意的是列表类型，是要所有实例共享，还是一个实例独占，要有不同的初始化方式</p>
<h4 id="实例的方法引用"><a href="#实例的方法引用" class="headerlink" title="实例的方法引用"></a>实例的方法引用</h4><p>方法的特殊指出在于，实例对象会作为类定义函数的第一个参数被传入，调用 x.f() 相当于 MyClass.f(x)</p>
<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>补充说明:</p>
<ul>
<li>python中没有任何东西能强制隐藏数据，它完全是基于约定的（除非用C编写python的扩展）</li>
<li>客户端应该谨慎使用数据属性，直接操作可能破坏由方法维护的固定变量；python没有限制对实例对象的添加和修改数据属性</li>
<li>每个值都是一个对象，因此也都具有类，并存储为 object.__class__</li>
<li>方法的第一个参数self是一个约定俗成的命名</li>
</ul>
<h1 id="继承暂时不需要了解派生的基础特性"><a href="#继承暂时不需要了解派生的基础特性" class="headerlink" title="继承暂时不需要了解派生的基础特性"></a>继承<div style="display:none">暂时不需要了解派生的基础特性</div></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(modname.BaseClassName):</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>

<h1 id="私有变量和名称改写"><a href="#私有变量和名称改写" class="headerlink" title="私有变量和名称改写"></a>私有变量和名称改写</h1><p>python并不存在仅限内部访问的真正的私有变量，但是大多数python代码都遵循这样的约定：带有一个下划线的名称（如 _spam）应该被当作是API的非公有部分</p>
<p>python还带有，名称改写的功能，虽然或许一般不会使用。在基类中含有如 __spam 这样的含有两个下划线前缀的标识符，它的文本将会被替换为 _classname__spam 。名称改写有助于让子类重载方法而不破坏类内方法调用，当前类只需要专注于当前类内私有变量的使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseNum</span>:</span><br><span class="line">     <span class="comment"># 定义时这么写，定义外单独引用该变量时，需要使用 x._BaseNum__num</span></span><br><span class="line">    __num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrivedNum</span>:</span><br><span class="line">    <span class="comment"># 定义时这么写，定义外单独引用该变量时，需要使用 x._DrivedNum__num</span></span><br><span class="line">    __num = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = DrivedNum()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x._BaseNum__num</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="基于类的迭代器"><a href="#基于类的迭代器" class="headerlink" title="基于类的迭代器"></a>基于类的迭代器</h1><p>大多数容器对象都可以使用for语句；在幕后，for语句会在容器对象上调用 iter() ，该函数返回定义了 __next__() 方法的迭代器对象，此方法将逐一访问容器中元素。可以使用 next() 内置函数来调用 __next()__ 方法  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;str_iterator <span class="built_in">object</span> at <span class="number">0x10c90e650</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">next</span>(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>给自定义类添加迭代器行为，定义一个 __iter__() 方法来返回一个带有 __next__() 的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure>
<p>这个类使用迭代器（实际使用中配合for语句）实现了伪翻转</p>
<p>可以用生成器完成的操作，同样可以使用基于类的迭代器来完成，但生成器的写法更为紧凑。此处不记录，仅考虑类迭代器的方法</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机零碎知识记录</title>
    <url>/2022/07/12/%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一些常用的又零碎的计算机知识</p>
<ul>
<li>2022-07-13 完成正则表达式基本整理</li>
</ul>
<span id="more"></span>

<h1 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h1><h2 id="回车CR、换行LF"><a href="#回车CR、换行LF" class="headerlink" title="回车CR、换行LF"></a>回车CR、换行LF</h2><p>CR: Carriage Return ，对应ASCII转义字符’\r’,表示回车<br>LF: Linefeed ，对应ASCII转义字符’\n’，表示换行<br>CRLF: Carriage Return &amp; Linefeed，对应ASCII转义字符 “\r\n”，表示回车并换行</p>
<p>windows系统下使用CRLF进行“换行”，即新行以”\r\n”存储<br>unix&#x2F;linux&#x2F;mac系统下，使用LF进行“换行”，即新行以’\n’存储</p>
<h2 id="命令行文件校验"><a href="#命令行文件校验" class="headerlink" title="命令行文件校验"></a>命令行文件校验</h2><p>windows和linux下都自带certutil工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\user1&gt;certutil -hashfile &lt;文件名&gt; SHA256</span><br></pre></td></tr></table></figure>
<p>打印sha256</p>
<h2 id="windows下查看部分查看信息命令"><a href="#windows下查看部分查看信息命令" class="headerlink" title="windows下查看部分查看信息命令"></a>windows下查看部分查看信息命令</h2><ul>
<li>事件查看器 eventvwr.msc</li>
<li>证书查看 certmgr.msc</li>
</ul>
<h1 id="非系统知识整理"><a href="#非系统知识整理" class="headerlink" title="非系统知识整理"></a>非系统知识整理</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p>
<h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><details class="note primary no-icon" open="">
<summary><p><strong>普通字符</strong></p>
</summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>匹配字符数量</th>
<th>描述</th>
<th>等价模式</th>
</tr>
</thead>
<tbody><tr>
<td>[ABC]</td>
<td>1</td>
<td>匹配 <strong>A B C</strong> 中任意一个</td>
<td></td>
</tr>
<tr>
<td>[^ABC]</td>
<td>1</td>
<td>匹配除 <strong>A B C</strong> 以外任意字符</td>
<td></td>
</tr>
<tr>
<td>[A-C0-4]</td>
<td>1</td>
<td>匹配 **A B C  0 1 2 3 4 **任意一个</td>
<td></td>
</tr>
<tr>
<td>[.]</td>
<td>1</td>
<td>匹配除 <strong>\n \r</strong> 以外任意字符</td>
<td></td>
</tr>
<tr>
<td>[\s]</td>
<td>1</td>
<td>匹配单个空白符</td>
<td></td>
</tr>
<tr>
<td>[\S]</td>
<td>1</td>
<td>匹配单个非空白符</td>
<td></td>
</tr>
<tr>
<td>[\w]</td>
<td>1</td>
<td>匹配是字母，数字，下划线中任意一个字符</td>
<td>[A-Z0-9_]</td>
</tr>
<tr>
<td></detail></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<details class="note primary no-icon" open="">
<summary><p><strong>非打印</strong></p>
</summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>匹配字符数量</th>
<th>描述</th>
<th>等价模式</th>
</tr>
</thead>
<tbody><tr>
<td>[\cx]</td>
<td>1</td>
<td>匹配由x指定的控制字符，识别失败则匹配 <strong>c</strong></td>
<td></td>
</tr>
<tr>
<td>[\f]</td>
<td>1</td>
<td>匹配一个换页符</td>
<td>[\x0c],  [\cL]</td>
</tr>
<tr>
<td>[\n]</td>
<td>1</td>
<td>匹配一个回车符</td>
<td>[\x0a], [\cJ]</td>
</tr>
<tr>
<td>[\r]</td>
<td>1</td>
<td>匹配一个换行符</td>
<td>[\x0d],  [\cM]</td>
</tr>
<tr>
<td>[\t]</td>
<td>1</td>
<td>匹配一个制表符</td>
<td>[\x09],  [\cI]</td>
</tr>
<tr>
<td>[\v]</td>
<td>1</td>
<td>匹配一个垂直制表符</td>
<td>[\x0b], [\cK]</td>
</tr>
<tr>
<td>[\s]</td>
<td>1</td>
<td>匹配任何空白字符,包括空格、制表、回车、换行、换页、垂直制表符</td>
<td>[ \t\n\r\f\v]</td>
</tr>
<tr>
<td>[\S]</td>
<td>1</td>
<td>匹配任意非空白字符</td>
<td>[^ \t\n\r\f\v]</td>
</tr>
<tr>
<td></detail></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<details class="note primary no-icon" open="">
<summary><p><strong>特殊字符</strong></p></summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>匹配字符数量</th>
<th>描述</th>
<th>等价模式</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>不确定</td>
<td>匹配输入字符串的结尾位置，注意 \r \n的匹配情况</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>-</td>
<td>标记一个子表达式,表示范围内为一个表达式</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>-</td>
<td>标记一个中括号表达式的开始</td>
<td></td>
</tr>
<tr>
<td>\</td>
<td>-</td>
<td>转义使用</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>-</td>
<td>匹配输入字符串的开始位置，在方括号内除外</td>
<td></td>
</tr>
<tr>
<td>[^ABC]</td>
<td>-</td>
<td>表示不接受该方括号表达式中的字符集合</td>
<td></td>
</tr>
<tr>
<td>{</td>
<td>-</td>
<td>标记限定符表达式的开始</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>-</td>
<td>指明两项中一项</td>
<td></td>
</tr>
</tbody></table>
</details>

<details class="note primary no-icon" open="">
<summary><p><strong>限定符</strong></p></summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>匹配字符数量</th>
<th>描述</th>
<th>等价模式</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0,1,2,…</td>
<td>匹配前方子表达式0次或多次；它是贪婪</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>1,2,3,…</td>
<td>匹配前方子表达式1次或多次；它是贪婪</td>
<td></td>
</tr>
<tr>
<td>{n}</td>
<td>n</td>
<td>匹配前方子表达式n次</td>
<td></td>
</tr>
<tr>
<td>{n,}</td>
<td>n,n+1,…</td>
<td>匹配前方子表达式至少n次</td>
<td></td>
</tr>
<tr>
<td>{n,m}</td>
<td>n,n+1,…,m</td>
<td>匹配前方字表达式最少n次最多m次</td>
<td></td>
</tr>
</tbody></table>
<p><i> <strong>*</strong> 和 <i> <strong>+</strong>  是贪婪的，尽可能匹配多的字符，在它们的后面加上一个 <strong>?</strong> 就可以实现非贪婪或最小匹配。</i></p>
<p>对于<strong>&lt;h1&gt; abcdefg &lt;&#x2F;h1&gt;</strong>这个字符换，<br> <strong>&lt;.*&gt;</strong> 可以匹配这一行内容，但 <strong>&lt;.*?&gt;</strong> 仅匹配  &lt;h1&gt;这四个字符</p>
</details>

<details class="note primary no-icon" open="">
<summary><p><strong>定位符</strong></p></summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>匹配字符数量</th>
<th>描述</th>
<th>等价模式</th>
</tr>
</thead>
<tbody><tr>
<td>^xxx</td>
<td>尽可能少</td>
<td>匹配输入字符串的开始位置；在方括号内则表示<strong>非</strong>的意义</td>
<td></td>
</tr>
<tr>
<td>xxx$</td>
<td>尽可能少</td>
<td>匹配输入字符串的结尾位置</td>
<td></td>
</tr>
<tr>
<td>\bxxx , xxx\b</td>
<td>与x数目一致</td>
<td>匹配一个单词的边界，在不考虑此次输入开始或末尾的单词的情况下，相当于<strong>空格</strong>字符的意义</td>
<td></td>
</tr>
<tr>
<td>\Bxxx , xxx\B</td>
<td>与x数目一致</td>
<td>匹配非单词边界，在不考虑此次输入开始或末尾的单词的情况下，相当于 <strong>非空格</strong>字符的意义</td>
<td></td>
</tr>
</tbody></table>
<p>如： \bCha 匹配单词 <strong>Chapter</strong> 中开头三个字符， ter\b 匹配单词 <strong>Chapter</strong> 中末尾三个字符</p>
</details>


</details>

<details class="note primary no-icon" >
<summary><p><strong>选择符(复杂，若无必要一般不考虑)</strong></p></summary>

<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(xxx)</td>
<td>捕获分组，可以表示内容为一个子表达式，同时把匹配的值保存起来，用(?:xxx)可以消除缓存</td>
</tr>
<tr>
<td>exp1(?&#x3D;exp2)</td>
<td>查找到exp2，然后仅匹配前方的exp1</td>
</tr>
<tr>
<td>(?&lt;&#x3D;exp2)exp1</td>
<td>查找到exp2，然后仅匹配后方的exp1</td>
</tr>
<tr>
<td>exp1(?!exp2)</td>
<td>查找到exp2，然后仅匹配后方的非exp1</td>
</tr>
<tr>
<td>(?&lt;!exp2)exp1</td>
<td>查找到exp2，然后仅匹配前方的非exp1</td>
</tr>
</tbody></table>
<p>如： runoob(?&#x3D;[\d+]) 匹配<strong>数字</strong>前面的<strong>runoob</strong> </p>
</details>

<p><br><br></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>日语基本语法学习与整理</title>
    <url>/2022/07/10/%E5%AD%A6%E4%B9%A0/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>记录《中日交流标准日本语》初级、中级常用语法</p>
<ul>
<li>2022-07-12 完成五十音的整理</li>
</ul>
<span id="more"></span>

<h1 id="《标准日本语》初级语法记录"><a href="#《标准日本语》初级语法记录" class="headerlink" title="《标准日本语》初级语法记录"></a>《标准日本语》初级语法记录</h1><h2 id="五十音"><a href="#五十音" class="headerlink" title="五十音"></a>五十音</h2><details class="note primary no-icon" open="" >
<summary><p><strong>平假名/片假名</strong></p></summary>

<table>
<thead>
<tr>
<th>a</th>
<th>i</th>
<th>u</th>
<th>e</th>
<th>o</th>
</tr>
</thead>
<tbody><tr>
<td>あア</td>
<td>いイ</td>
<td>うウ</td>
<td>えエ</td>
<td>おオ</td>
</tr>
<tr>
<td>かカ</td>
<td>きキ</td>
<td>くク</td>
<td>けケ</td>
<td>こコ</td>
</tr>
<tr>
<td>さサ</td>
<td>しシ</td>
<td>すス</td>
<td>せセ</td>
<td>そソ</td>
</tr>
<tr>
<td>たタ</td>
<td>ちチ</td>
<td>つツ</td>
<td>てテ</td>
<td>とト</td>
</tr>
<tr>
<td>なナ</td>
<td>に二</td>
<td>ぬヌ</td>
<td>ねネ</td>
<td>のノ</td>
</tr>
<tr>
<td>はハ</td>
<td>ひヒ</td>
<td>ふフ</td>
<td>ヘへ</td>
<td>ほホ</td>
</tr>
<tr>
<td>まマ</td>
<td>みミ</td>
<td>むム</td>
<td>めメ</td>
<td>もモ</td>
</tr>
<tr>
<td>やヤ</td>
<td>いイ</td>
<td>ゆユ</td>
<td>ええ</td>
<td>よヨ</td>
</tr>
<tr>
<td>らラ</td>
<td>りリ</td>
<td>るル</td>
<td>れレ</td>
<td>ろロ</td>
</tr>
<tr>
<td>わワ</td>
<td>いイ</td>
<td>うウ</td>
<td>えエ</td>
<td>おオ</td>
</tr>
<tr>
<td>んン</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>がガ</td>
<td>ぎギ</td>
<td>ぐグ</td>
<td>げゲ</td>
<td>ごゴ</td>
</tr>
<tr>
<td>ざザ</td>
<td>じジ</td>
<td>ずズ</td>
<td>ぜゼ</td>
<td>ぞゾ</td>
</tr>
<tr>
<td>だザ</td>
<td>ぢヂ</td>
<td>づヅ</td>
<td>でデ</td>
<td>どド</td>
</tr>
<tr>
<td>ばバ</td>
<td>びビ</td>
<td>ぶブ</td>
<td>べベ</td>
<td>ぼボ</td>
</tr>
<tr>
<td>ぱパ</td>
<td>ぴピ</td>
<td>ぷプ</td>
<td>ぺペ</td>
<td>ぽポ</td>
</tr>
</tbody></table>
</details>
<details class="note primary no-icon" open="" >
<summary><p><strong>平假名独表</strong></p></summary>

<table>
<thead>
<tr>
<th>a</th>
<th>i</th>
<th>u</th>
<th>e</th>
<th>o</th>
</tr>
</thead>
<tbody><tr>
<td>あ</td>
<td>い</td>
<td>う</td>
<td>え</td>
<td>お</td>
</tr>
<tr>
<td>か</td>
<td>き</td>
<td>く</td>
<td>け</td>
<td>こ</td>
</tr>
<tr>
<td>さ</td>
<td>し</td>
<td>す</td>
<td>せ</td>
<td>そ</td>
</tr>
<tr>
<td>た</td>
<td>ち</td>
<td>つ</td>
<td>て</td>
<td>と</td>
</tr>
<tr>
<td>な</td>
<td>に</td>
<td>ぬ</td>
<td>ね</td>
<td>の</td>
</tr>
<tr>
<td>は</td>
<td>ひ</td>
<td>ふ</td>
<td>ヘ</td>
<td>ほ</td>
</tr>
<tr>
<td>ま</td>
<td>み</td>
<td>む</td>
<td>め</td>
<td>も</td>
</tr>
<tr>
<td>や</td>
<td>い</td>
<td>ゆ</td>
<td>え</td>
<td>よ</td>
</tr>
<tr>
<td>ら</td>
<td>り</td>
<td>る</td>
<td>れ</td>
<td>ろ</td>
</tr>
<tr>
<td>わ</td>
<td>い</td>
<td>う</td>
<td>え</td>
<td>お</td>
</tr>
<tr>
<td>ん</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>が</td>
<td>ぎ</td>
<td>ぐ</td>
<td>げ</td>
<td>ご</td>
</tr>
<tr>
<td>ざ</td>
<td>じ</td>
<td>ず</td>
<td>ぜ</td>
<td>ぞ</td>
</tr>
<tr>
<td>だ</td>
<td>ぢ</td>
<td>づ</td>
<td>で</td>
<td>ど</td>
</tr>
<tr>
<td>ば</td>
<td>び</td>
<td>ぶ</td>
<td>べ</td>
<td>ぼ</td>
</tr>
<tr>
<td>ぱ</td>
<td>ぴ</td>
<td>ぷ</td>
<td>ぺ</td>
<td>ぽ</td>
</tr>
</tbody></table>
</details>
<details class="note primary no-icon" open="">
<summary><p><strong>片假名独表</strong></p></summary>

<table>
<thead>
<tr>
<th>a</th>
<th>i</th>
<th>u</th>
<th>e</th>
<th>o</th>
</tr>
</thead>
<tbody><tr>
<td>ア</td>
<td>イ</td>
<td>ウ</td>
<td>エ</td>
<td>オ</td>
</tr>
<tr>
<td>カ</td>
<td>キ</td>
<td>ク</td>
<td>ケ</td>
<td>コ</td>
</tr>
<tr>
<td>サ</td>
<td>シ</td>
<td>ス</td>
<td>セ</td>
<td>ソ</td>
</tr>
<tr>
<td>タ</td>
<td>チ</td>
<td>ツ</td>
<td>テ</td>
<td>ト</td>
</tr>
<tr>
<td>ナ</td>
<td>二</td>
<td>ヌ</td>
<td>ネ</td>
<td>ノ</td>
</tr>
<tr>
<td>ハ</td>
<td>ヒ</td>
<td>フ</td>
<td>へ</td>
<td>ホ</td>
</tr>
<tr>
<td>マ</td>
<td>ミ</td>
<td>ム</td>
<td>メ</td>
<td>モ</td>
</tr>
<tr>
<td>ヤ</td>
<td>イ</td>
<td>ユ</td>
<td>え</td>
<td>ヨ</td>
</tr>
<tr>
<td>ラ</td>
<td>リ</td>
<td>ル</td>
<td>レ</td>
<td>ロ</td>
</tr>
<tr>
<td>ワ</td>
<td>イ</td>
<td>ウ</td>
<td>エ</td>
<td>オ</td>
</tr>
<tr>
<td>ン</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ガ</td>
<td>ギ</td>
<td>グ</td>
<td>ゲ</td>
<td>ゴ</td>
</tr>
<tr>
<td>ザ</td>
<td>ジ</td>
<td>ズ</td>
<td>ゼ</td>
<td>ゾ</td>
</tr>
<tr>
<td>ザ</td>
<td>ヂ</td>
<td>ヅ</td>
<td>デ</td>
<td>ド</td>
</tr>
<tr>
<td>バ</td>
<td>ビ</td>
<td>ブ</td>
<td>ベ</td>
<td>ボ</td>
</tr>
<tr>
<td>パ</td>
<td>ピ</td>
<td>プ</td>
<td>ペ</td>
<td>ポ</td>
</tr>
</tbody></table>
</details>


<h2 id="形容词语法"><a href="#形容词语法" class="headerlink" title="形容词语法"></a>形容词语法</h2><p><em>两类形容词在作谓语时的肯定、否定、现在、过去的各种形式</em><br><strong>一类形容词</strong>: 词尾い段，以假名形式出现，不作为汉字的一部分。<br>一类形容词作谓语:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">            --现在肯定--&gt; 词尾后加です  </span><br><span class="line">词尾い      --过去肯定--&gt; かったです </span><br><span class="line">词尾い      --现在否定--&gt; くないです，くありません  </span><br><span class="line">词尾い      --过去否定--&gt; なっかです，ありませんでした  </span><br><span class="line"></span><br><span class="line">*いい       --现在肯定--&gt; いいです</span><br><span class="line"> いい       --过去肯定--&gt; よっかたです</span><br><span class="line"> いい       --现在否定--&gt; よくないです，よくありません  </span><br><span class="line"> いい       --过去否定--&gt; よっかたです，よくありませんでした  </span><br></pre></td></tr></table></figure>


<p><strong>二类形容词</strong>: 也叫形容动词，词尾非假名い段，如 嫌い(完整形式是嫌いだ)、綺麗 等就是二类形容词。<br>二类形容词作谓语:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--现在肯定--&gt; 词尾后加です  </span><br><span class="line">--过去肯定--&gt; 词尾后加でしす </span><br><span class="line">--现在否定--&gt; 词尾后加ではありません </span><br><span class="line">--过去否定--&gt; 词尾后加ではありませんでした</span><br></pre></td></tr></table></figure>


<h2 id="动词语法"><a href="#动词语法" class="headerlink" title="动词语法"></a>动词语法</h2><p>一类动词：绝大部分去ます形い段尾部<br>二类动词：小部分去ます形い段尾部(okimaasu、miます)；去ます形え段尾部<br>三类动词：使用します的动词；特殊地，还有来ます、します<br><em>动词的ます形，て形，…等，分别用于不同情况</em></p>
<p><strong>动词ます形</strong></p>
<p><strong>动词去ます形</strong></p>
<p><strong>动词て形</strong>  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一类动词:</span><br><span class="line">    动词尾き       --&gt;　いて</span><br><span class="line">    动词尾ぎ       --&gt;　いで</span><br><span class="line">    动词尾び、み、に--&gt;　んて</span><br><span class="line">    动词尾ち、り、い--&gt;　って</span><br><span class="line">    动词尾し       --&gt;　して</span><br><span class="line">二类动词：</span><br><span class="line">    去ます后，加て</span><br><span class="line">三类动词：</span><br><span class="line">    します        --&gt;　して</span><br><span class="line">    来ます        --&gt;　来て</span><br><span class="line">特殊于以上几类:</span><br><span class="line">    行きます      --&gt;　行って</span><br></pre></td></tr></table></figure>
<p><a href="/assets/images/xxx" title="常用て形变换">!常用て形变换</a></p>
<p><strong>动词ない形</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一类动词:</span><br><span class="line">    把尾音变为a段，再加nai；如果尾音i段，则把i变为wa，再加nai</span><br><span class="line">二类动词：</span><br><span class="line">    去ます后，加nai</span><br><span class="line">三类动词：</span><br><span class="line">    把ます变成nai(注意，尽管变化的形式与二类动词一样，但意义不同)；shimasu变成shinai</span><br></pre></td></tr></table></figure>
<p><a href="/assets/images/xxx" title="常用ない形变换">!常用ない形变换</a></p>
<p><strong>动词基本形</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一类动词:</span><br><span class="line">    去masu形尾音u段     </span><br><span class="line">二类动词:</span><br><span class="line">    去masu形</span><br><span class="line">三类动词:</span><br><span class="line">    去masu形尾部为ki</span><br><span class="line">    去masu形尾部为shi   --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数量词的搭配使用（13）"><a href="#数量词的搭配使用（13）" class="headerlink" title="数量词的搭配使用（13）"></a>数量词的搭配使用（13）</h2>]]></content>
      <categories>
        <category>学习</category>
        <category>日语</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter学习笔记</title>
    <url>/2022/07/10/%E5%AD%A6%E4%B9%A0/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/jmeter/JMeter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>观看《JMeter 2021 Masterclass》视频，学习并实践视频内容</p>
<ul>
<li>2022-08-08 完成观看视频的同步学习记录</li>
</ul>
<span id="more"></span>
<h1 id="初学笔记"><a href="#初学笔记" class="headerlink" title="初学笔记"></a>初学笔记</h1><h2 id="观看《JMeter-2021-Masterclass》学习并记录"><a href="#观看《JMeter-2021-Masterclass》学习并记录" class="headerlink" title="观看《JMeter 2021 Masterclass》学习并记录"></a>观看《JMeter 2021 Masterclass》学习并记录</h2><h3 id="开始一个JMeter测试计划"><a href="#开始一个JMeter测试计划" class="headerlink" title="开始一个JMeter测试计划"></a>开始一个JMeter测试计划</h3><ol>
<li>点击根目录下&#x2F;bin&#x2F;jmeter.bat ，打开GUI界面</li>
<li>右击Test Plan,添加Thread-Thread Group <ol>
<li>设置线程数</li>
<li>设置爬坡时间(Ramp-up period)</li>
<li>设置循环次数</li>
<li>其余默认</li>
</ol>
</li>
<li>右击已创建线程组,添加Simpler-HTTP Request<ol>
<li>Protocol留空，即默认http协议</li>
<li>Server Name or IP 设置要测试的网站，不要添加http(s)的前缀</li>
<li>Port Number留空</li>
<li>选择需要测试url的方法和路径</li>
<li>点击下方Add添加所需参数</li>
</ol>
</li>
<li>右击已创建线程组,添加 Listener-View Results Tree和View Results Tree</li>
<li>点击绿色箭头start,开始测试,测试结果可在两个监听器中看到</li>
</ol>
<h3 id="监听器Listener"><a href="#监听器Listener" class="headerlink" title="监听器Listener"></a>监听器Listener</h3><p>主要监听器:</p>
<ul>
<li>View Results in Table</li>
<li>View Results Tree</li>
<li>Aggregate Report</li>
<li>Graph Results</li>
<li>Summary Report</li>
<li>Simple Data Writer</li>
</ul>
<h3 id="断言Assertions"><a href="#断言Assertions" class="headerlink" title="断言Assertions"></a>断言Assertions</h3><p><em>注意，不同位置的Assertion适用的采样器范围不同</em><br>当请求不满足断言条件，则会被判断为fail</p>
<h3 id="HTTP-s-测试的脚本记录器"><a href="#HTTP-s-测试的脚本记录器" class="headerlink" title="HTTP(s)测试的脚本记录器"></a>HTTP(s)测试的脚本记录器</h3><!-- [脚本记录器debug]( /source/assets/WorkImages/JMeterScriptRecorder.png "脚本记录器") -->

<p><img src="/assets/WorkImages/JMeterScriptRecorder.png" alt="脚本记录器" title="脚本记录器"><br>步骤:</p>
<ol>
<li>给测试计划添加测试脚本记录器Test Script Recorder，并在脚本记录器上添加监听器</li>
<li>给测试计划添加线程组</li>
<li>给线程组添加记录控制器Recording Controllor，配置端口和渔民，并添加监听器</li>
<li>给火狐浏览器设置手动代理，并导入JMeter根目录的证书(如果没有则需要start一下会生成临时证书)</li>
<li>开始测试计划</li>
</ol>
<p>模板的使用:</p>
<h3 id="Blazemeter"><a href="#Blazemeter" class="headerlink" title="Blazemeter"></a>Blazemeter</h3><p><em>用于在云端运行性能测试的工具，相比使用JMeter内置脚本记录器，更加简便)</em></p>
<p>视频内容:</p>
<ol>
<li>create Blazemeter account</li>
<li>get Blazemeter extension</li>
<li>login </li>
<li>record test</li>
<li>save jmx</li>
<li>add JMX in JMeter and Run</li>
</ol>
<p>使用方法：</p>
<ol>
<li>使用扩展，开始记录，在网页上进行操作，完成记录，</li>
<li>Run，然后自动跳转至Blazemeter Dashbord</li>
<li>Edit</li>
<li>Save，下载指定JMX文件，可以导入到JMeter文件，只要再加两个监听器即可直接运行</li>
</ol>
<h3 id="关联CSV数据"><a href="#关联CSV数据" class="headerlink" title="关联CSV数据"></a>关联CSV数据</h3><p>步骤：</p>
<ol>
<li>添加CSV Data Set Config，和线程组同级别意味着可以用于该线程组</li>
<li>在CSV Data Set Config添加CSV文件，使之文件关联到JMeter</li>
<li>使用语法${FeatureName}引用对应特征名的变量</li>
<li>其他设置，如重命名特征名，文件编码，是否识别第一行，文件分隔符，到达EOF后停止或循环或结束线程</li>
</ol>
<h3 id="HTTP-Web测试中的设置元素-（其他类型的可到官方文档查看）"><a href="#HTTP-Web测试中的设置元素-（其他类型的可到官方文档查看）" class="headerlink" title="HTTP Web测试中的设置元素 （其他类型的可到官方文档查看）"></a>HTTP Web测试中的设置元素 （其他类型的可到官方文档查看）</h3><p><em>结果树监听器View Results Tree Listener消耗内存，调试测试测试计划时可以使用，但真正要测性能时要禁用</em></p>
<p><em>使用Blazemeter录制完保存为jmx文件后，导入到JMeter，会生成完整的配置元素和采样器</em></p>
<p>demo app - <a href="https://opensource-demo.orangehrmlive.com/">https://opensource-demo.orangehrmlive.com/</a></p>
<p>有以下几种设置元素:</p>
<ul>
<li>用户定义变量</li>
<li>HTTP头管理器</li>
<li>HTTP请求默认设置</li>
<li>DNS缓存管理器</li>
<li>HTTP认证（Authorization）管理器</li>
<li>HTTP Cookie管理器</li>
<li>HTTP缓存管理器</li>
</ul>
<h3 id="一般设置元素"><a href="#一般设置元素" class="headerlink" title="一般设置元素"></a>一般设置元素</h3><ul>
<li>Counter 可以存储迭代变量， ${num} 使用它，默认循环</li>
<li>JDBC Connection Config 用于连接，JDBC Request不负责连接 </li>
<li>Keystore 配置密钥，如何加载密钥，加载哪个由它配置</li>
<li>Random Variable 产生随机值，有必要看看要不要配置随机值</li>
<li>SImple Config Element 组建多对“变量名-值”的组合</li>
<li>User Defined Variable</li>
</ul>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>好处：</p>
<ul>
<li>没有图形界面的资源消耗</li>
<li>能与任何外部CI&#x2F;CD进行整合在一起</li>
</ul>
<p>视频内容</p>
<ol>
<li><p>进入bin文件夹，在命令行运行测试	<br>jmeter -n -t “测试文件.jmx -l “结果文件.csv”<br>jmeter或jmeter.bat<br>-n  no gui<br>-t  必须给出测试计划的地址<br>-l  必须给出结果文件位置<br>sh jmeter -n -t “测试文件位置”  -l “结果文件位置”</p>
</li>
<li><p>查看命令行帮助和选项 jmeter -h</p>
</li>
<li><p>添加环境变量，在任何系统位置运行</p>
</li>
</ol>
<h3 id="从命令行或GUI界面生成HTML报告"><a href="#从命令行或GUI界面生成HTML报告" class="headerlink" title="从命令行或GUI界面生成HTML报告"></a>从命令行或GUI界面生成HTML报告</h3><p>内容：</p>
<ul>
<li>从命令行创建html仪表盘报告</li>
<li>从脱机的cvs结果文件创建html仪表盘报告</li>
<li>学习html仪表盘报告</li>
<li>GUI生成html仪表盘报告</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>创建测试计划</p>
</li>
<li><p>在bin文件夹打开命令行</p>
</li>
<li><p>运行命令 jmeter -n -t “testfile.jmx” -l “resualtfile.csv”  -e -o “reports foler”<br> -e  生成html报告或仪表盘报告<br> -o  </p>
<p> 使用已有csv结果文件生成报告<br> jmeter -g “resualtfile.csv”   -o “reports foler”</p>
</li>
<li><p>Tools-Gnenrate HTML report在可视化界面生成HTML报告</p>
</li>
</ol>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>内容:寻找、安装、卸载、升级插件</p>
<ol>
<li>从<a href="https://jmeter-plugins.org/wiki/PluginsManager/%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8jar%EF%BC%8C%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/lib/ext">https://jmeter-plugins.org/wiki/PluginsManager/下载插件管理器jar，放到指定目录/lib/ext</a></li>
<li>在GUI界面OPTIONS-Plugins Manager里可以管理JMeter</li>
<li>寻找其他插件 <a href="https://jmeter-plugins.org/">https://jmeter-plugins.org/</a>   <a href="https://jmeter-plugins.org/wiki/Start/">https://jmeter-plugins.org/wiki/Start/</a></li>
</ol>
<h3 id="测试REST-API"><a href="#测试REST-API" class="headerlink" title="测试REST API"></a>测试REST API</h3><ul>
<li>REST API：Representational State Transfer，需要了解一下概念</li>
<li>网址reqres.in，这里有一些用于测试的简单 REST API</li>
<li>REST API在浏览器上的表现形式似乎与一般HTTP报文并无区别，测试时当成普通HTTP报文即可（待日后研究）</li>
<li>使用POST方法，交换的json数据需要编辑在在body</li>
</ul>
<h3 id="测试SOAP-API"><a href="#测试SOAP-API" class="headerlink" title="测试SOAP API"></a>测试SOAP API</h3><ol>
<li>请求采样器</li>
<li>添加Headers</li>
<li>添加Authorisation</li>
<li>添加body</li>
<li>添加断言</li>
<li>运行和检查结果</li>
</ol>
<p>测试网站 dneonline.com&#x2F;calculator.asmx<br>SOAP API 都是POST方式，内容为SOAP格式文档<br>可以扩展wizdler查看SOAP文档内容</p>
<p>视频过程：</p>
<ol>
<li><p>使用模板 Building a SOAP WebService Test Plan 构建一个SOAP API测试<br> 其中 SOAP Request 的Body Data部分是SOAP格式文档<br> 需要调整HTTP头管理器<br> 可选添加Authorization管理器</p>
</li>
<li><p>不使用模板，自己手动建立一个SOAP API测试计划</p>
<ol>
<li>添加HTTP请求采样器，方法需要设置为POST，body需要添加SOAP格式内容<br> 视频中在body里添加了 SOAP Envelope 元素下内容(这里传送数据)</li>
<li>添加头管理器，跳转其内容，包括 Content-Type , SOAPAction（这里告诉服务器对接收道德数据的进行什么行为）</li>
<li>添加了Authorization管理器，但测试网站没有认证需要</li>
<li>添加了Response断言，断言了 SOAP内容下的一个元素，如 <AddResult>5</AddResult></li>
<li>添加监视器以查看结果，View Results Tree，Assertion Results</li>
</ol>
</li>
</ol>
<h3 id="函数-JMeter内置-和变量的使用"><a href="#函数-JMeter内置-和变量的使用" class="headerlink" title="函数(JMeter内置)和变量的使用"></a>函数(JMeter内置)和变量的使用</h3><p>Funtions句法:<br>    ${_funcName}<br>    ${_funcName(var1,var2,…)}<br>Variable句法:<br>    ${VarName}</p>
<p>视频过程:</p>
<ol>
<li>添加Java Request</li>
<li>点击 Function Helper Dialog	，可以找些一些JMeter的内置函数，如 log，time，threadNum等</li>
<li>一个函数可以使用别的函数返回的变量，如 存在函数 ${_intSum(2,3,result)}，则在别的请求中可以使用 ${result}，也可以当作一个函数内的参数<br>所有函数可以参考官方文档 <a href="https://jmeter.apache.org/usermanual/functions.html">https://jmeter.apache.org/usermanual/functions.html</a></li>
</ol>
<h2 id="JMeter官方文档阅读笔记"><a href="#JMeter官方文档阅读笔记" class="headerlink" title="JMeter官方文档阅读笔记"></a>JMeter官方文档阅读笔记</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><ul>
<li>线程组是测试计划的起点，所有控制器和采样器必须位于线程组下，监听器可以与线程组同级；</li>
<li>每个线程完全独立；</li>
<li>爬坡时间指定要用多少时间完成所有线程，一定程度上指定了延迟，下限必须足够长以免负载过大</li>
<li>可以指定线程生存周期，包括持续时间和启动延迟</li>
</ul>
<h4 id="采样器"><a href="#采样器" class="headerlink" title="采样器"></a>采样器</h4><p>采样器告诉JMeter向服务器发送请求并等待响应。<br>包括 FTP、HTTP、JDBC、Java Object、JMS、JUnit Test、LDAP、Mail、OS Process、TCP 这些请求种类的采样器</p>
<h4 id="逻辑控制器"><a href="#逻辑控制器" class="headerlink" title="逻辑控制器"></a>逻辑控制器</h4><p>逻辑控制器允许自定义如何发送请求，指定发送时间，发送顺序<br>测试计划</p>
<ul>
<li>线程组<ul>
<li>仅一次控制器</li>
<li>登录请求（HTTP 请求)</li>
<li>加载搜索页面（HTTP 采样器）</li>
<li>交错控制器</li>
<li>搜索“A”（HTTP采样器）</li>
<li>搜索“B”（HTTP采样器）</li>
<li>HTTP 默认请求（配置元素）</li>
<li>HTTP 默认请求（配置元素）</li>
<li>饼干管理器（配置元素）</li>
</ul>
</li>
</ul>
<h4 id="特殊的控制器-测试片段"><a href="#特殊的控制器-测试片段" class="headerlink" title="特殊的控制器-测试片段"></a>特殊的控制器-测试片段</h4><p>这个元素仅仅用于测试计划中重用代码</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>所有的监听器都保存相同的数据，唯一的区别在于选择显示方式和选择的显示内容。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>指定其范围内采样器之间的延迟时间，多个计时器的时间会相加</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言检验返回请求是否符合自定义规则（文本、返回头等），否则视为失败，记录于监听器</p>
<h3 id="配置元素"><a href="#配置元素" class="headerlink" title="配置元素"></a>配置元素</h3><p>配置元素与采样器紧密协作，它可以添加或修改请求，作用范围为所在控制器内部；<br>子分支中的配置元素优先级高于父分支中配置元素</p>
<h3 id="预处理后处理元件"><a href="#预处理后处理元件" class="headerlink" title="预处理后处理元件"></a>预处理后处理元件</h3><p>在发出采样器请求之前和之后执行某些操作</p>
<h2 id="组件作用范围与执行顺序"><a href="#组件作用范围与执行顺序" class="headerlink" title="组件作用范围与执行顺序"></a>组件作用范围与执行顺序</h2><h3 id="范围界定规则"><a href="#范围界定规则" class="headerlink" title="范围界定规则"></a>范围界定规则</h3><p>分层结构（监听器、配置元素、预处理器、后处理器、断言、计时器内部）<br>同级有序结构（逻辑控制器、采样器之间）<br>同级无序结构（监听器、配置元素、预处理器、后处理器、断言、计时器之间）</p>
<p><img src="/assets/WorkImages/scoping-rules.png" alt="范围界定示例" title="范围界定示例"></p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>单个采样器运行的前后环境顺序：</p>
<ol>
<li>配置元素</li>
<li>预处理器</li>
<li>定时器</li>
<li>采样器</li>
<li>后处理器</li>
<li>断言</li>
<li>监听器</li>
</ol>
<h1 id="使用过程技巧记录"><a href="#使用过程技巧记录" class="headerlink" title="使用过程技巧记录"></a>使用过程技巧记录</h1><ol>
<li><p>插件 Parallel Controller &amp; Sampler<br>允许线程组内并行控制器，但不能细致操控。  如果必须要在一个线程内设置一个并行，那么只能使用该控制器；如果可以针对地并发执行这些请求，那么应该使用线程组</p>
</li>
<li><p>变量嵌套，其中有 fileCounter 是自定义迭代器变量， fileId1 ，fileId2 … 是自定义变量 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;__V(fileId$&#123;fileCounter&#125;)&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>测试工具</category>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
</search>
